{"version":3,"file":"GlobeControls-CKSk7BfI.js","sources":["../../../src/three/renderer/controls/GlobeControls.js"],"sourcesContent":["import {\n\tMatrix4,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tMathUtils,\n\tRay,\n\tGroup,\n} from 'three';\nimport { DRAG, ZOOM, EnvironmentControls, NONE } from './EnvironmentControls.js';\nimport { closestRayEllipsoidSurfacePointEstimate, makeRotateAroundPoint, mouseToCoords, setRaycasterFromCamera } from './utils.js';\nimport { Ellipsoid } from '../math/Ellipsoid.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\n\nconst _invMatrix = /* @__PURE__ */ new Matrix4();\nconst _rotMatrix = /* @__PURE__ */ new Matrix4();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _forward = /* @__PURE__ */ new Vector3();\nconst _targetRight = /* @__PURE__ */ new Vector3();\nconst _globalUp = /* @__PURE__ */ new Vector3();\nconst _quaternion = /* @__PURE__ */ new Quaternion();\nconst _zoomPointUp = /* @__PURE__ */ new Vector3();\nconst _toCenter = /* @__PURE__ */ new Vector3();\nconst _ray = /* @__PURE__ */ new Ray();\nconst _ellipsoid = /* @__PURE__ */ new Ellipsoid();\nconst _pointer = /* @__PURE__ */ new Vector2();\nconst _latLon = {};\n\n// hand picked minimum elevation to tune far plane near surface\nconst MIN_ELEVATION = 2550;\nexport class GlobeControls extends EnvironmentControls {\n\n\tget tilesGroup() {\n\n\t\tconsole.warn( 'GlobeControls: \"tilesGroup\" has been deprecated. Use \"ellipsoidGroup\", instead.' );\n\t\treturn this.ellipsoidFrame;\n\n\t}\n\n\tget ellipsoidFrame() {\n\n\t\treturn this.ellipsoidGroup.matrixWorld;\n\n\t}\n\n\tget ellipsoidFrameInverse() {\n\n\t\tconst { ellipsoidGroup, ellipsoidFrame, _ellipsoidFrameInverse } = this;\n\t\treturn ellipsoidGroup.matrixWorldInverse ?\n\t\t\tellipsoidGroup.matrixWorldInverse :\n\t\t\t_ellipsoidFrameInverse.copy( ellipsoidFrame ).invert();\n\n\t}\n\n\tconstructor( scene = null, camera = null, domElement = null, tilesRenderer = null ) {\n\n\t\t// store which mode the drag stats are in\n\t\tsuper( scene, camera, domElement );\n\n\t\tthis.isGlobeControls = true;\n\n\t\tthis._dragMode = 0;\n\t\tthis._rotationMode = 0;\n\t\tthis.maxZoom = 0.01;\n\t\tthis.nearMargin = 0.25;\n\t\tthis.farMargin = 0;\n\t\tthis.useFallbackPlane = false;\n\t\tthis.autoAdjustCameraRotation = false;\n\n\t\tthis.globeInertia = new Quaternion();\n\t\tthis.globeInertiaFactor = 0;\n\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\t\tthis.ellipsoidGroup = new Group();\n\t\tthis._ellipsoidFrameInverse = new Matrix4();\n\n\t\tif ( tilesRenderer !== null ) {\n\n\t\t\tthis.setTilesRenderer( tilesRenderer );\n\n\t\t}\n\n\t}\n\n\tsetTilesRenderer( tilesRenderer ) {\n\n\t\tsuper.setTilesRenderer( tilesRenderer );\n\t\tif ( tilesRenderer !== null ) {\n\n\t\t\tthis.setEllipsoid( tilesRenderer.ellipsoid, tilesRenderer.group );\n\n\t\t}\n\n\t}\n\n\tsetEllipsoid( ellipsoid, ellipsoidGroup ) {\n\n\t\tthis.ellipsoid = ellipsoid || WGS84_ELLIPSOID.clone();\n\t\tthis.ellipsoidGroup = ellipsoidGroup || new Group();\n\n\t}\n\n\tgetPivotPoint( target ) {\n\n\t\tconst { camera, ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\n\t\t// get camera values\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t// set a ray in the local ellipsoid frame\n\t\t_ray.origin.copy( camera.position );\n\t\t_ray.direction.copy( _forward );\n\t\t_ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t// get the estimated closest point\n\t\tclosestRayEllipsoidSurfacePointEstimate( _ray, ellipsoid, _vec );\n\t\t_vec.applyMatrix4( ellipsoidFrame );\n\n\t\t// use the closest point if no pivot was provided or it's closer\n\t\tif (\n\t\t\tsuper.getPivotPoint( target ) === null ||\n\t\t\t_pos.subVectors( target, _ray.origin ).dot( _ray.direction ) > _pos.subVectors( _vec, _ray.origin ).dot( _ray.direction )\n\t\t) {\n\n\t\t\ttarget.copy( _vec );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t// get the vector to the center of the provided globe\n\tgetVectorToCenter( target ) {\n\n\t\tconst { ellipsoidFrame, camera } = this;\n\t\treturn target\n\t\t\t.setFromMatrixPosition( ellipsoidFrame )\n\t\t\t.sub( camera.position );\n\n\t}\n\n\t// get the distance to the center of the globe\n\tgetDistanceToCenter() {\n\n\t\treturn this\n\t\t\t.getVectorToCenter( _vec )\n\t\t\t.length();\n\n\t}\n\n\tgetUpDirection( point, target ) {\n\n\t\t// get the \"up\" direction based on the wgs84 ellipsoid\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\t\t_vec.copy( point ).applyMatrix4( ellipsoidFrameInverse );\n\n\t\tellipsoid.getPositionToNormal( _vec, target );\n\t\ttarget.transformDirection( ellipsoidFrame );\n\n\t}\n\n\tgetCameraUpDirection( target ) {\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid, camera } = this;\n\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\tthis._getVirtualOrthoCameraPosition( _vec );\n\n\t\t\t_vec.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\tellipsoid.getPositionToNormal( _vec, target );\n\t\t\ttarget.transformDirection( ellipsoidFrame );\n\n\t\t} else {\n\n\t\t\tthis.getUpDirection( camera.position, target );\n\n\t\t}\n\n\t}\n\n\tupdate( deltaTime = Math.min( this.clock.getDelta(), 64 / 1000 ) ) {\n\n\t\tif ( ! this.enabled || ! this.camera || deltaTime === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { camera, pivotMesh } = this;\n\n\t\t// if we're outside the transition threshold then we toggle some reorientation behavior\n\t\t// when adjusting the up frame while moving the camera\n\t\tif ( this._isNearControls() ) {\n\n\t\t\tthis.scaleZoomOrientationAtEdges = this.zoomDelta < 0;\n\n\t\t} else {\n\n\t\t\tif ( this.state !== NONE && this._dragMode !== 1 && this._rotationMode !== 1 ) {\n\n\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t}\n\t\t\tthis.scaleZoomOrientationAtEdges = false;\n\n\t\t}\n\n\t\tconst adjustCameraRotation = this.needsUpdate || this._inertiaNeedsUpdate();\n\n\t\t// fire basic controls update\n\t\tsuper.update( deltaTime );\n\n\t\t// update the camera planes and the ortho camera position\n\t\tthis.adjustCamera( camera );\n\n\t\t// align the camera up vector if the camera as updated\n\t\tif ( adjustCameraRotation && this._isNearControls() ) {\n\n\t\t\tthis.getCameraUpDirection( _globalUp );\n\t\t\tthis._alignCameraUp( _globalUp, 1 );\n\n\t\t\tthis.getCameraUpDirection( _globalUp );\n\t\t\tthis._clampRotation( _globalUp );\n\n\t\t}\n\n\t}\n\n\n\t// Updates the passed camera near and far clip planes to encapsulate the ellipsoid from the\n\t// current position in addition to adjusting the height.\n\tadjustCamera( camera ) {\n\n\t\tsuper.adjustCamera( camera );\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid, nearMargin, farMargin } = this;\n\t\tconst maxRadius = Math.max( ...ellipsoid.radius );\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t// adjust the clip planes\n\t\t\tconst distanceToCenter = _vec\n\t\t\t\t.setFromMatrixPosition( ellipsoidFrame )\n\t\t\t\t.sub( camera.position ).length();\n\n\t\t\t// update the projection matrix\n\t\t\t// interpolate from the 25% radius margin around the globe down to the surface\n\t\t\t// so we can avoid z fighting when near value is too far at a high altitude\n\t\t\tconst margin = nearMargin * maxRadius;\n\t\t\tconst alpha = MathUtils.clamp( ( distanceToCenter - maxRadius ) / margin, 0, 1 );\n\t\t\tconst minNear = MathUtils.lerp( 1, 1000, alpha );\n\t\t\tcamera.near = Math.max( minNear, distanceToCenter - maxRadius - margin );\n\n\t\t\t// update the far plane to the horizon distance\n\t\t\t_pos.copy( camera.position ).applyMatrix4( ellipsoidFrameInverse );\n\t\t\tellipsoid.getPositionToCartographic( _pos, _latLon );\n\n\t\t\t// use a minimum elevation for computing the horizon distance to avoid the far clip\n\t\t\t// plane approaching zero or clipping mountains over the horizon in the distance as\n\t\t\t// the camera goes to or below sea level.\n\t\t\tconst elevation = Math.max( ellipsoid.getPositionElevation( _pos ), MIN_ELEVATION );\n\t\t\tconst horizonDistance = ellipsoid.calculateHorizonDistance( _latLon.lat, elevation );\n\n\t\t\tcamera.far = horizonDistance + 0.1 + maxRadius * farMargin;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t} else {\n\n\t\t\tthis._getVirtualOrthoCameraPosition( camera.position, camera );\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.setFromMatrixPosition( ellipsoidFrame ).applyMatrix4( _invMatrix );\n\n\t\t\tconst distanceToCenter = - _vec.z;\n\t\t\tcamera.near = distanceToCenter - maxRadius * ( 1 + nearMargin );\n\t\t\tcamera.far = distanceToCenter + 0.1 + maxRadius * farMargin;\n\n\t\t\t// adjust the position of the ortho camera such that the near value is 0\n\t\t\tcamera.position.addScaledVector( _forward, camera.near );\n\t\t\tcamera.far -= camera.near;\n\t\t\tcamera.near = 0;\n\n\t\t\tcamera.updateProjectionMatrix();\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\t// resets the \"stuck\" drag modes\n\tsetState( ...args ) {\n\n\t\tsuper.setState( ...args );\n\t\tthis._dragMode = 0;\n\t\tthis._rotationMode = 0;\n\n\t}\n\n\t_updateInertia( deltaTime ) {\n\n\t\tsuper._updateInertia( deltaTime );\n\n\t\tconst {\n\t\t\tglobeInertia,\n\t\t\tenableDamping,\n\t\t\tdampingFactor,\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tminDistance,\n\t\t\tinertiaTargetDistance,\n\t\t\tellipsoidFrame,\n\t\t} = this;\n\n\t\tif ( ! this.enableDamping || this.inertiaStableFrames > 1 ) {\n\n\t\t\tthis.globeInertiaFactor = 0;\n\t\t\tthis.globeInertia.identity();\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst factor = Math.pow( 2, - deltaTime / dampingFactor );\n\t\tconst stableDistance = Math.max( camera.near, cameraRadius, minDistance, inertiaTargetDistance );\n\t\tconst resolution = 2 * 1e3;\n\t\tconst pixelWidth = 2 / resolution;\n\t\tconst pixelThreshold = 0.25 * pixelWidth;\n\n\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\n\t\tif ( this.globeInertiaFactor !== 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _pos.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _pos );\n\t\t\t_pos.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// get implied angle\n\t\t\t_vec.sub( _center ).normalize();\n\t\t\t_pos.sub( _center ).normalize();\n\n\t\t\tthis.globeInertiaFactor *= factor;\n\t\t\tconst threshold = _vec.angleTo( _pos ) / deltaTime;\n\t\t\tconst globeAngle = 2 * Math.acos( globeInertia.w ) * this.globeInertiaFactor;\n\t\t\tif ( globeAngle < threshold || ! enableDamping ) {\n\n\t\t\t\tthis.globeInertiaFactor = 0;\n\t\t\t\tglobeInertia.identity();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.globeInertiaFactor !== 0 ) {\n\n\t\t\t// ensure our w component is non-one if the xyz values are\n\t\t\t// non zero to ensure we can animate\n\t\t\tif (\n\t\t\t\tglobeInertia.w === 1 && (\n\t\t\t\t\tglobeInertia.x !== 0 ||\n\t\t\t\t\tglobeInertia.y !== 0 ||\n\t\t\t\t\tglobeInertia.z !== 0\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tglobeInertia.w = Math.min( globeInertia.w, 1 - 1e-9 );\n\n\t\t\t}\n\n\t\t\t// construct the rotation matrix\n\t\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\t\t\t_quaternion.identity().slerp( globeInertia, this.globeInertiaFactor * deltaTime );\n\t\t\tmakeRotateAroundPoint( _center, _quaternion, _rotMatrix );\n\n\t\t\t// apply the rotation\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t}\n\n\t}\n\n\t_inertiaNeedsUpdate() {\n\n\t\treturn super._inertiaNeedsUpdate() || this.globeInertiaFactor !== 0;\n\n\t}\n\n\t_updatePosition( deltaTime ) {\n\n\t\tif ( this.state === DRAG ) {\n\n\t\t\t// save the drag mode state so we can update the pivot mesh visuals in \"update\"\n\t\t\tif ( this._dragMode === 0 ) {\n\n\t\t\t\tthis._dragMode = this._isNearControls() ? 1 : - 1;\n\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\traycaster,\n\t\t\t\tcamera,\n\t\t\t\tpivotPoint,\n\t\t\t\tpointerTracker,\n\t\t\t\tdomElement,\n\t\t\t\tellipsoidFrame,\n\t\t\t\tellipsoidFrameInverse,\n\t\t\t} = this;\n\n\t\t\t// reuse cache variables\n\t\t\tconst pivotDir = _pos;\n\t\t\tconst newPivotDir = _targetRight;\n\n\t\t\t// get the pointer and ray\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _pointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// transform to ellipsoid frame\n\t\t\traycaster.ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\t// construct an ellipsoid that matches a sphere with the radius of the globe so\n\t\t\t// the drag position matches where the initial click was\n\t\t\tconst pivotRadius = _vec.copy( pivotPoint ).applyMatrix4( ellipsoidFrameInverse ).length();\n\t\t\t_ellipsoid.radius.setScalar( pivotRadius );\n\n\t\t\t// if we drag off the sphere then end the operation and follow through on the inertia\n\t\t\tif ( ! _ellipsoid.intersectRay( raycaster.ray, _vec ) ) {\n\n\t\t\t\tthis.resetState();\n\t\t\t\tthis._updateInertia( deltaTime );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_vec.applyMatrix4( ellipsoidFrame );\n\n\t\t\t// get the point directions\n\t\t\t_center.setFromMatrixPosition( ellipsoidFrame );\n\t\t\tpivotDir.subVectors( pivotPoint, _center ).normalize();\n\t\t\tnewPivotDir.subVectors( _vec, _center ).normalize();\n\n\t\t\t// construct the rotation\n\t\t\t_quaternion.setFromUnitVectors( newPivotDir, pivotDir );\n\t\t\tmakeRotateAroundPoint( _center, _quaternion, _rotMatrix );\n\n\t\t\t// apply the rotation\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t} else {\n\n\t\t\t\tthis.globeInertia.copy( _quaternion );\n\t\t\t\tthis.globeInertiaFactor = 1 / deltaTime;\n\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// disable rotation once we're outside the control transition\n\t_updateRotation( ...args ) {\n\n\t\tif ( this._rotationMode === 1 || this._isNearControls() ) {\n\n\t\t\tthis._rotationMode = 1;\n\t\t\tsuper._updateRotation( ...args );\n\n\t\t} else {\n\n\t\t\tthis.pivotMesh.visible = false;\n\t\t\tthis._rotationMode = - 1;\n\n\t\t}\n\n\n\t}\n\n\t_updateZoom() {\n\n\t\tconst { zoomDelta, ellipsoid, zoomSpeed, zoomPoint, camera, maxZoom, state } = this;\n\n\t\tif ( state !== ZOOM && zoomDelta === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// reset momentum\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\tthis.globeInertia.identity();\n\t\tthis.globeInertiaFactor = 0;\n\n\t\t// used to scale the tilt transitions based on zoom intensity\n\t\tconst deltaAlpha = MathUtils.clamp( MathUtils.mapLinear( Math.abs( zoomDelta ), 0, 20, 0, 1 ), 0, 1 );\n\t\tif ( this._isNearControls() || zoomDelta > 0 ) {\n\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// When zooming try to tilt the camera towards the center of the planet to avoid the globe\n\t\t\t// spinning as you zoom out from the horizon\n\t\t\tif ( zoomDelta < 0 && ( this.zoomPointSet || this._updateZoomPoint() ) ) {\n\n\t\t\t\t// get the forward vector and vector toward the center of the ellipsoid\n\t\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).normalize();\n\t\t\t\t_toCenter.copy( this.up ).multiplyScalar( - 1 );\n\n\t\t\t\t// Calculate alpha values to use to scale the amount of tilt that occurs as the camera moves.\n\t\t\t\t// Scales based on mouse position near the horizon and current tilt.\n\t\t\t\tthis.getUpDirection( zoomPoint, _zoomPointUp );\n\t\t\t\tconst upAlpha = MathUtils.clamp( MathUtils.mapLinear( - _zoomPointUp.dot( _toCenter ), 1, 0.95, 0, 1 ), 0, 1 );\n\t\t\t\tconst forwardAlpha = 1 - _forward.dot( _toCenter );\n\t\t\t\tconst cameraAlpha = camera.isOrthographicCamera ? 0.05 : 1;\n\t\t\t\tconst adjustedDeltaAlpha = MathUtils.clamp( deltaAlpha * 3, 0, 1 );\n\n\t\t\t\t// apply scale\n\t\t\t\tconst alpha = Math.min( upAlpha * forwardAlpha * cameraAlpha * adjustedDeltaAlpha, 0.1 );\n\t\t\t\t_toCenter.lerpVectors( _forward, _toCenter, alpha ).normalize();\n\n\t\t\t\t// perform rotation\n\t\t\t\t_quaternion.setFromUnitVectors( _forward, _toCenter );\n\t\t\t\tmakeRotateAroundPoint( zoomPoint, _quaternion, _rotMatrix );\n\t\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _toCenter );\n\n\t\t\t\t// update zoom direction\n\t\t\t\tthis.zoomDirection.subVectors( zoomPoint, camera.position ).normalize();\n\n\t\t\t}\n\n\t\t\tsuper._updateZoom();\n\n\t\t} else if ( camera.isPerspectiveCamera ) {\n\n\t\t\t// orient the camera to focus on the earth during the zoom\n\t\t\tconst transitionDistance = this._getPerspectiveTransitionDistance();\n\t\t\tconst maxDistance = this._getMaxPerspectiveDistance();\n\t\t\tconst distanceAlpha = MathUtils.mapLinear( this.getDistanceToCenter(), transitionDistance, maxDistance, 0, 1 );\n\t\t\tthis._tiltTowardsCenter( MathUtils.lerp( 0, 0.4, distanceAlpha * deltaAlpha ) );\n\t\t\tthis._alignCameraUpToNorth( MathUtils.lerp( 0, 0.2, distanceAlpha * deltaAlpha ) );\n\n\t\t\t// calculate zoom in a similar way to environment controls so\n\t\t\t// the zoom speeds are comparable\n\t\t\tconst dist = this.getDistanceToCenter() - ellipsoid.radius.x;\n\t\t\tconst scale = zoomDelta * dist * zoomSpeed * 0.0025;\n\t\t\tconst clampedScale = Math.max( scale, Math.min( this.getDistanceToCenter() - maxDistance, 0 ) );\n\n\t\t\t// zoom out directly from the globe center\n\t\t\tthis.getVectorToCenter( _vec ).normalize();\n\t\t\tthis.camera.position.addScaledVector( _vec, clampedScale );\n\t\t\tthis.camera.updateMatrixWorld();\n\n\t\t\tthis.zoomDelta = 0;\n\n\t\t} else {\n\n\t\t\tconst transitionZoom = this._getOrthographicTransitionZoom();\n\t\t\tconst minZoom = this._getMinOrthographicZoom();\n\t\t\tconst distanceAlpha = MathUtils.mapLinear( camera.zoom, transitionZoom, minZoom, 0, 1 );\n\t\t\tthis._tiltTowardsCenter( MathUtils.lerp( 0, 0.4, distanceAlpha * deltaAlpha ) );\n\t\t\tthis._alignCameraUpToNorth( MathUtils.lerp( 0, 0.2, distanceAlpha * deltaAlpha ) );\n\n\t\t\tconst scale = this.zoomDelta;\n\t\t\tconst normalizedDelta = Math.pow( 0.95, Math.abs( scale * 0.05 ) );\n\t\t\tconst scaleFactor = scale > 0 ? 1 / Math.abs( normalizedDelta ) : normalizedDelta;\n\n\t\t\tconst maxScaleFactor = minZoom / camera.zoom;\n\t\t\tconst clampedScaleFactor = Math.max( scaleFactor * zoomSpeed, Math.min( maxScaleFactor, 1 ) );\n\n\t\t\tcamera.zoom = Math.min( maxZoom, camera.zoom * clampedScaleFactor );\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\tthis.zoomDelta = 0;\n\t\t\tthis.zoomDirectionSet = false;\n\n\t\t}\n\n\t}\n\n\t// tilt the camera to align with north\n\t_alignCameraUpToNorth( alpha ) {\n\n\t\tconst { ellipsoidFrame } = this;\n\t\t_globalUp.set( 0, 0, 1 ).transformDirection( ellipsoidFrame );\n\t\tthis._alignCameraUp( _globalUp, alpha );\n\n\t}\n\n\t// tilt the camera to look at the center of the globe\n\t_tiltTowardsCenter( alpha ) {\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tellipsoidFrame,\n\t\t} = this;\n\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).normalize();\n\t\t_vec.setFromMatrixPosition( ellipsoidFrame ).sub( camera.position ).normalize();\n\t\t_vec.lerp( _forward, 1 - alpha ).normalize();\n\n\t\t_quaternion.setFromUnitVectors( _forward, _vec );\n\t\tcamera.quaternion.premultiply( _quaternion );\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t// returns the perspective camera transition distance can move to based on globe size and fov\n\t_getPerspectiveTransitionDistance() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isPerspectiveCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// When the smallest fov spans 65% of the ellipsoid then we use the near controls\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst fovHoriz = 2 * Math.atan( Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 ) * camera.aspect );\n\t\tconst distVert = ellipsoidRadius / Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 );\n\t\tconst distHoriz = ellipsoidRadius / Math.tan( fovHoriz * 0.5 );\n\t\tconst dist = Math.max( distVert, distHoriz );\n\n\t\treturn dist;\n\n\t}\n\n\t// returns the max distance the perspective camera can move to based on globe size and fov\n\t_getMaxPerspectiveDistance() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isPerspectiveCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// allow for zooming out such that the ellipsoid is half the size of the largest fov\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst fovHoriz = 2 * Math.atan( Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 ) * camera.aspect );\n\t\tconst distVert = ellipsoidRadius / Math.tan( MathUtils.DEG2RAD * camera.fov * 0.5 );\n\t\tconst distHoriz = ellipsoidRadius / Math.tan( fovHoriz * 0.5 );\n\t\tconst dist = 2 * Math.max( distVert, distHoriz );\n\n\t\treturn dist;\n\n\t}\n\n\t// returns the transition threshold for orthographic zoom based on the globe size and camera settings\n\t_getOrthographicTransitionZoom() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.max( orthoHeight, orthoWidth );\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst ellipsoidDiameter = 2 * ellipsoidRadius;\n\t\treturn 2 * orthoSize / ellipsoidDiameter;\n\n\t}\n\n\t// returns the minimum allowed orthographic zoom based on the globe size and camera settings\n\t_getMinOrthographicZoom() {\n\n\t\tconst { camera, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.min( orthoHeight, orthoWidth );\n\t\tconst ellipsoidRadius = Math.max( ...ellipsoid.radius );\n\t\tconst ellipsoidDiameter = 2 * ellipsoidRadius;\n\t\treturn 0.7 * orthoSize / ellipsoidDiameter;\n\n\t}\n\n\t// returns the \"virtual position\" of the orthographic based on where it is and\n\t// where it's looking primarily so we can reasonably position the camera object\n\t// in space and derive a reasonable \"up\" value.\n\t_getVirtualOrthoCameraPosition( target, camera = this.camera ) {\n\n\t\tconst { ellipsoidFrame, ellipsoidFrameInverse, ellipsoid } = this;\n\t\tif ( ! camera.isOrthographicCamera ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\t// get ray in globe coordinate frame\n\t\t_ray.origin.copy( camera.position );\n\t\t_ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t_ray.applyMatrix4( ellipsoidFrameInverse );\n\n\t\t// get the closest point to the ray on the globe in the global coordinate frame\n\t\tclosestRayEllipsoidSurfacePointEstimate( _ray, ellipsoid, _pos );\n\t\t_pos.applyMatrix4( ellipsoidFrame );\n\n\t\t// get ortho camera info\n\t\tconst orthoHeight = ( camera.top - camera.bottom );\n\t\tconst orthoWidth = ( camera.right - camera.left );\n\t\tconst orthoSize = Math.max( orthoHeight, orthoWidth ) / camera.zoom;\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t// ensure we move the camera exactly along the forward vector to avoid shifting\n\t\t// the camera in other directions due to floating point error\n\t\tconst dist = _pos.sub( camera.position ).dot( _forward );\n\t\ttarget.copy( camera.position ).addScaledVector( _forward, dist - orthoSize * 4 );\n\n\t}\n\n\t_isNearControls() {\n\n\t\tconst { camera } = this;\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\treturn this.getDistanceToCenter() < this._getPerspectiveTransitionDistance();\n\n\t\t} else {\n\n\t\t\treturn camera.zoom > this._getOrthographicTransitionZoom();\n\n\t\t}\n\n\t}\n\n\t_raycast( raycaster ) {\n\n\t\tconst result = super._raycast( raycaster );\n\t\tif ( result === null ) {\n\n\t\t\t// if there was no hit then fallback to intersecting the ellipsoid.\n\t\t\tconst { ellipsoid, ellipsoidFrame, ellipsoidFrameInverse } = this;\n\t\t\t_ray.copy( raycaster.ray ).applyMatrix4( ellipsoidFrameInverse );\n\n\t\t\tconst point = ellipsoid.intersectRay( _ray, _vec );\n\t\t\tif ( point !== null ) {\n\n\t\t\t\treturn {\n\t\t\t\t\tpoint: point.clone().applyMatrix4( ellipsoidFrame ),\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n}\n"],"names":["_invMatrix","Matrix4","_rotMatrix","_pos","Vector3","_vec","_center","_forward","_targetRight","_globalUp","_quaternion","Quaternion","_zoomPointUp","_toCenter","_ray","Ray","_ellipsoid","Ellipsoid","_pointer","Vector2","_latLon","MIN_ELEVATION","GlobeControls","EnvironmentControls","ellipsoidGroup","ellipsoidFrame","_ellipsoidFrameInverse","scene","camera","domElement","tilesRenderer","WGS84_ELLIPSOID","Group","ellipsoid","target","ellipsoidFrameInverse","closestRayEllipsoidSurfacePointEstimate","point","deltaTime","pivotMesh","NONE","adjustCameraRotation","nearMargin","farMargin","maxRadius","distanceToCenter","margin","alpha","MathUtils","minNear","elevation","horizonDistance","args","globeInertia","enableDamping","dampingFactor","cameraRadius","minDistance","inertiaTargetDistance","factor","stableDistance","pixelThreshold","setRaycasterFromCamera","threshold","makeRotateAroundPoint","DRAG","raycaster","pivotPoint","pointerTracker","pivotDir","newPivotDir","mouseToCoords","pivotRadius","zoomDelta","zoomSpeed","zoomPoint","maxZoom","state","ZOOM","deltaAlpha","upAlpha","forwardAlpha","cameraAlpha","adjustedDeltaAlpha","transitionDistance","maxDistance","distanceAlpha","dist","scale","clampedScale","transitionZoom","minZoom","normalizedDelta","scaleFactor","maxScaleFactor","clampedScaleFactor","ellipsoidRadius","fovHoriz","distVert","distHoriz","orthoHeight","orthoWidth","orthoSize","ellipsoidDiameter","result"],"mappings":"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"}