{"version":3,"file":"CesiumIonAuthPlugin-DL6JcDIR.js","sources":["../../../src/core/plugins/auth/GoogleCloudAuth.js","../../../src/three/plugins/GoogleAttributionsManager.js","../../../src/three/plugins/GoogleCloudAuthPlugin.js","../../../src/core/plugins/loaders/QuantizedMeshLoaderBase.js","../../../src/three/plugins/loaders/QuantizedMeshLoader.js","../../../src/three/plugins/utilities/QuantizedMeshClipper.js","../../../src/three/plugins/QuantizedMeshPlugin.js","../../../src/three/plugins/CesiumIonAuthPlugin.js"],"sourcesContent":["import { traverseSet } from '../../renderer/tiles/traverseFunctions.js';\n\nconst TILES_MAP_URL = 'https://tile.googleapis.com/v1/createSession';\n\n// Class for making fetches to Google Cloud, refreshing the token if needed.\n// Supports both the 2d map tiles API in addition to 3d tiles.\nexport class GoogleCloudAuth {\n\n\tget isMapTilesSession() {\n\n\t\treturn this.authURL === TILES_MAP_URL;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst { apiToken, sessionOptions = null, autoRefreshToken = false } = options;\n\t\tthis.apiToken = apiToken;\n\t\tthis.autoRefreshToken = autoRefreshToken;\n\t\tthis.authURL = TILES_MAP_URL;\n\t\tthis.sessionToken = null;\n\t\tthis.sessionOptions = sessionOptions;\n\t\tthis._tokenRefreshPromise = null;\n\n\t}\n\n\tasync fetch( url, options ) {\n\n\t\t// if we're using a map tiles session then we have to refresh the token separately\n\t\tif ( this.sessionToken === null && this.isMapTilesSession ) {\n\n\t\t\tthis.refreshToken( options );\n\n\t\t}\n\n\t\tawait this._tokenRefreshPromise;\n\n\t\t// construct the url\n\t\tconst fetchUrl = new URL( url );\n\t\tfetchUrl.searchParams.set( 'key', this.apiToken );\n\t\tif ( this.sessionToken ) {\n\n\t\t\tfetchUrl.searchParams.set( 'session', this.sessionToken );\n\n\t\t}\n\n\t\t// try to refresh the session token if we failed to load it\n\t\tlet res = await fetch( fetchUrl, options );\n\t\tif ( res.status >= 400 && res.status <= 499 && this.autoRefreshToken ) {\n\n\t\t\t// refresh the session token\n\t\t\tawait this.refreshToken( options );\n\t\t\tif ( this.sessionToken ) {\n\n\t\t\t\tfetchUrl.searchParams.set( 'session', this.sessionToken );\n\n\t\t\t}\n\n\t\t\tres = await fetch( fetchUrl, options );\n\n\t\t}\n\n\t\tif ( this.sessionToken === null && ! this.isMapTilesSession ) {\n\n\t\t\t// if we're using a 3d tiles session then we get the session key in the first request\n\t\t\treturn res\n\t\t\t\t.json()\n\t\t\t\t.then( json => {\n\n\t\t\t\t\tthis.sessionToken = getSessionToken( json );\n\t\t\t\t\treturn json;\n\n\t\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn res;\n\n\t\t}\n\n\t}\n\n\trefreshToken( options ) {\n\n\t\tif ( this._tokenRefreshPromise === null ) {\n\n\t\t\t// construct the url to fetch the endpoint\n\t\t\tconst url = new URL( this.authURL );\n\t\t\turl.searchParams.set( 'key', this.apiToken );\n\n\t\t\t// initialize options for map tiles\n\t\t\tconst fetchOptions = { ...options };\n\t\t\tif ( this.isMapTilesSession ) {\n\n\t\t\t\tfetchOptions.method = 'POST';\n\t\t\t\tfetchOptions.body = JSON.stringify( this.sessionOptions );\n\t\t\t\tfetchOptions.headers = fetchOptions.headers || {};\n\t\t\t\tfetchOptions.headers = {\n\t\t\t\t\t...fetchOptions.headers,\n\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis._tokenRefreshPromise = fetch( url, fetchOptions )\n\t\t\t\t.then( res => {\n\n\t\t\t\t\tif ( ! res.ok ) {\n\n\t\t\t\t\t\tthrow new Error( `GoogleCloudAuth: Failed to load data with error code ${ res.status }` );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn res.json();\n\n\t\t\t\t} )\n\t\t\t\t.then( json => {\n\n\t\t\t\t\tthis.sessionToken = getSessionToken( json );\n\t\t\t\t\tthis._tokenRefreshPromise = null;\n\n\t\t\t\t\treturn json;\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\treturn this._tokenRefreshPromise;\n\n\t}\n\n}\n\n// Takes a json response from the auth url and extracts the session token\nfunction getSessionToken( json ) {\n\n\tif ( 'session' in json ) {\n\n\t\t// if using the 2d maps api\n\t\treturn json.session;\n\n\t} else {\n\n\t\t// is using the 3d tiles api\n\t\tlet sessionToken = null;\n\t\tconst root = json.root;\n\t\ttraverseSet( root, tile => {\n\n\t\t\tif ( tile.content && tile.content.uri ) {\n\n\t\t\t\tconst [ , params ] = tile.content.uri.split( '?' );\n\t\t\t\tsessionToken = new URLSearchParams( params ).get( 'session' );\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t} );\n\n\t\treturn sessionToken;\n\n\t}\n\n}\n\n","export class GoogleAttributionsManager {\n\n\tconstructor() {\n\n\t\tthis.creditsCount = {};\n\n\t}\n\n\t_adjustAttributions( line, add ) {\n\n\t\tconst creditsCount = this.creditsCount;\n\t\tconst tokens = line.split( /;/g );\n\t\tfor ( let i = 0, l = tokens.length; i < l; i ++ ) {\n\n\t\t\tconst t = tokens[ i ];\n\t\t\tif ( ! ( t in creditsCount ) ) {\n\n\t\t\t\tcreditsCount[ t ] = 0;\n\n\t\t\t}\n\n\t\t\tcreditsCount[ t ] += add ? 1 : - 1;\n\n\t\t\tif ( creditsCount[ t ] <= 0 ) {\n\n\t\t\t\tdelete creditsCount[ t ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taddAttributions( line ) {\n\n\t\tthis._adjustAttributions( line, true );\n\n\t}\n\n\tremoveAttributions( line ) {\n\n\t\tthis._adjustAttributions( line, false );\n\n\t}\n\n\ttoString() {\n\n\t\t// attribution guidelines: https://developers.google.com/maps/documentation/tile/create-renderer#display-attributions\n\n\t\tconst sortedByCount = Object.entries( this.creditsCount ).sort( ( a, b ) => {\n\n\t\t\tconst countA = a[ 1 ];\n\t\t\tconst countB = b[ 1 ];\n\t\t\treturn countB - countA; // Descending order\n\n\t\t} );\n\n\t\treturn sortedByCount.map( pair => pair[ 0 ] ).join( '; ' );\n\n\t}\n\n}\n","import { GoogleCloudAuth } from '../../core/plugins/auth/GoogleCloudAuth.js';\nimport { GoogleAttributionsManager } from './GoogleAttributionsManager.js';\n\nconst TILES_3D_API = 'https://tile.googleapis.com/v1/3dtiles/root.json';\n\nexport class GoogleCloudAuthPlugin {\n\n\tconstructor( {\n\t\tapiToken,\n\t\tsessionOptions = null,\n\t\tautoRefreshToken = false,\n\t\tlogoUrl = null,\n\t\tuseRecommendedSettings = true,\n\t} ) {\n\n\t\tthis.name = 'GOOGLE_CLOUD_AUTH_PLUGIN';\n\n\t\tthis.apiToken = apiToken;\n\t\tthis.useRecommendedSettings = useRecommendedSettings;\n\t\tthis.logoUrl = logoUrl;\n\n\t\tthis.auth = new GoogleCloudAuth( { apiToken, autoRefreshToken, sessionOptions } );\n\t\tthis.tiles = null;\n\n\t\tthis._visibilityChangeCallback = null;\n\t\tthis._attributionsManager = new GoogleAttributionsManager();\n\t\tthis._logoAttribution = {\n\t\t\tvalue: '',\n\t\t\ttype: 'image',\n\t\t\tcollapsible: false,\n\t\t};\n\t\tthis._attribution = {\n\t\t\tvalue: '',\n\t\t\ttype: 'string',\n\t\t\tcollapsible: true,\n\t\t};\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tconst { useRecommendedSettings, auth } = this;\n\n\t\t// reset the tiles in case this plugin was removed and re-added\n\t\ttiles.resetFailedTiles();\n\n\t\tif ( tiles.rootURL == null ) {\n\n\t\t\ttiles.rootURL = TILES_3D_API;\n\n\t\t}\n\n\t\tif ( ! auth.sessionOptions ) {\n\n\t\t\tauth.authURL = tiles.rootURL;\n\n\t\t}\n\n\t\tif ( useRecommendedSettings && ! auth.isMapTilesSession ) {\n\n\t\t\t// This plugin changes below values to be more efficient for the photorealistic tiles\n\t\t\ttiles.errorTarget = 20;\n\n\t\t}\n\n\t\tthis.tiles = tiles;\n\n\t\tthis._visibilityChangeCallback = ( { tile, visible } ) => {\n\n\t\t\tconst copyright = tile.cached.metadata?.asset?.copyright || '';\n\t\t\tif ( visible ) {\n\n\t\t\t\tthis._attributionsManager.addAttributions( copyright );\n\n\t\t\t} else {\n\n\t\t\t\tthis._attributionsManager.removeAttributions( copyright );\n\n\t\t\t}\n\n\t\t};\n\n\t\ttiles.addEventListener( 'tile-visibility-change', this._visibilityChangeCallback );\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.tiles.visibleTiles.size > 0 ) {\n\n\t\t\tif ( this.logoUrl ) {\n\n\t\t\t\tthis._logoAttribution.value = this.logoUrl;\n\t\t\t\ttarget.push( this._logoAttribution );\n\n\t\t\t}\n\n\t\t\tthis._attribution.value = this._attributionsManager.toString();\n\t\t\ttarget.push( this._attribution );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.tiles.removeEventListener( 'tile-visibility-change', this._visibilityChangeCallback );\n\n\t}\n\n\tasync fetchData( uri, options ) {\n\n\t\treturn this.auth.fetch( uri, options );\n\n\t}\n\n}\n","import { LoaderBase } from '../../renderer/loaders/LoaderBase.js';\n\nexport function zigZagDecode( value ) {\n\n\treturn ( value >> 1 ) ^ ( - ( value & 1 ) );\n\n}\n\nexport class QuantizedMeshLoaderBase extends LoaderBase {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.fetchOptions.header = {\n\t\t\tAccept: 'application/vnd.quantized-mesh,application/octet-stream;q=0.9',\n\t\t};\n\n\t}\n\n\tloadAsync( ...args ) {\n\n\t\tconst { fetchOptions } = this;\n\t\tfetchOptions.header = fetchOptions.header || {};\n\t\tfetchOptions.header[ 'Accept' ] = 'application/vnd.quantized-mesh,application/octet-stream;q=0.9';\n\t\tfetchOptions.header[ 'Accept' ] += ';extensions=octvertexnormals-watermask-metadata';\n\n\t\treturn super.loadAsync( ...args );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tlet pointer = 0;\n\t\tconst view = new DataView( buffer );\n\t\tconst readFloat64 = () => {\n\n\t\t\tconst result = view.getFloat64( pointer, true );\n\t\t\tpointer += 8;\n\t\t\treturn result;\n\n\t\t};\n\n\t\tconst readFloat32 = () => {\n\n\t\t\tconst result = view.getFloat32( pointer, true );\n\t\t\tpointer += 4;\n\t\t\treturn result;\n\n\t\t};\n\n\t\tconst readInt = () => {\n\n\t\t\tconst result = view.getUint32( pointer, true );\n\t\t\tpointer += 4;\n\t\t\treturn result;\n\n\t\t};\n\n\t\tconst readByte = () => {\n\n\t\t\tconst result = view.getUint8( pointer );\n\t\t\tpointer += 1;\n\t\t\treturn result;\n\n\t\t};\n\n\t\tconst readBuffer = ( count, type ) => {\n\n\t\t\tconst result = new type( buffer, pointer, count );\n\t\t\tpointer += count * type.BYTES_PER_ELEMENT;\n\t\t\treturn result;\n\n\t\t};\n\n\t\t// extract header\n\t\tconst header = {\n\t\t\tcenter: [ readFloat64(), readFloat64(), readFloat64() ],\n\t\t\tminHeight: readFloat32(),\n\t\t\tmaxHeight: readFloat32(),\n\t\t\tsphereCenter: [ readFloat64(), readFloat64(), readFloat64() ],\n\t\t\tsphereRadius: readFloat64(),\n\t\t\thorizonOcclusionPoint: [ readFloat64(), readFloat64(), readFloat64() ],\n\t\t};\n\n\t\t// extract vertex data\n\t\tconst vertexCount = readInt();\n\t\tconst uBuffer = readBuffer( vertexCount, Uint16Array );\n\t\tconst vBuffer = readBuffer( vertexCount, Uint16Array );\n\t\tconst hBuffer = readBuffer( vertexCount, Uint16Array );\n\n\t\tconst uResult = new Float32Array( vertexCount );\n\t\tconst vResult = new Float32Array( vertexCount );\n\t\tconst hResult = new Float32Array( vertexCount );\n\n\t\t// decode vertex data\n\t\tlet u = 0;\n\t\tlet v = 0;\n\t\tlet h = 0;\n\t\tconst MAX_VALUE = 32767;\n\t\tfor ( let i = 0; i < vertexCount; ++ i ) {\n\n\t\t\tu += zigZagDecode( uBuffer[ i ] );\n\t\t\tv += zigZagDecode( vBuffer[ i ] );\n\t\t\th += zigZagDecode( hBuffer[ i ] );\n\n\t\t\tuResult[ i ] = u / MAX_VALUE;\n\t\t\tvResult[ i ] = v / MAX_VALUE;\n\t\t\thResult[ i ] = h / MAX_VALUE;\n\n\t\t}\n\n\t\t// align pointer for index data\n\t\tconst is32 = vertexCount > 65536;\n\t\tconst bufferType = is32 ? Uint32Array : Uint16Array;\n\t\tif ( is32 ) {\n\n\t\t\tpointer = Math.ceil( pointer / 4 ) * 4;\n\n\t\t} else {\n\n\t\t\tpointer = Math.ceil( pointer / 2 ) * 2;\n\n\t\t}\n\n\t\t// extract index data\n\t\tconst triangleCount = readInt();\n\t\tconst indices = readBuffer( triangleCount * 3, bufferType );\n\n\t\t// decode the index data\n\t\tlet highest = 0;\n\t\tfor ( var i = 0; i < indices.length; ++ i ) {\n\n\t\t\tconst code = indices[ i ];\n\t\t\tindices[ i ] = highest - code;\n\t\t\tif ( code === 0 ) {\n\n\t\t\t\t++ highest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// sort functions for the edges since they are not pre-sorted\n\t\tconst vSort = ( a, b ) => vResult[ b ] - vResult[ a ];\n\t\tconst vSortReverse = ( a, b ) => - vSort( a, b );\n\n\t\tconst uSort = ( a, b ) => uResult[ a ] - uResult[ b ];\n\t\tconst uSortReverse = ( a, b ) => - uSort( a, b );\n\n\t\t// get edge indices\n\t\tconst westVertexCount = readInt();\n\t\tconst westIndices = readBuffer( westVertexCount, bufferType );\n\t\twestIndices.sort( vSort );\n\n\t\tconst southVertexCount = readInt();\n\t\tconst southIndices = readBuffer( southVertexCount, bufferType );\n\t\tsouthIndices.sort( uSort );\n\n\t\tconst eastVertexCount = readInt();\n\t\tconst eastIndices = readBuffer( eastVertexCount, bufferType );\n\t\teastIndices.sort( vSortReverse );\n\n\t\tconst northVertexCount = readInt();\n\t\tconst northIndices = readBuffer( northVertexCount, bufferType );\n\t\tnorthIndices.sort( uSortReverse );\n\n\t\tconst edgeIndices = {\n\t\t\twestIndices,\n\t\t\tsouthIndices,\n\t\t\teastIndices,\n\t\t\tnorthIndices,\n\t\t};\n\n\t\t// parse extensions\n\t\tconst extensions = {};\n\t\twhile ( pointer < view.byteLength ) {\n\n\t\t\tconst extensionId = readByte();\n\t\t\tconst extensionLength = readInt();\n\n\t\t\tif ( extensionId === 1 ) {\n\n\t\t\t\t// oct encoded normals\n\t\t\t\tconst xy = readBuffer( vertexCount * 2, Uint8Array );\n\t\t\t\tconst normals = new Float32Array( vertexCount * 3 );\n\n\t\t\t\t// https://github.com/CesiumGS/cesium/blob/baaabaa49058067c855ad050be73a9cdfe9b6ac7/packages/engine/Source/Core/AttributeCompression.js#L119-L140\n\t\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\t\tlet x = ( xy[ 2 * i + 0 ] / 255 ) * 2 - 1;\n\t\t\t\t\tlet y = ( xy[ 2 * i + 1 ] / 255 ) * 2 - 1;\n\t\t\t\t\tconst z = 1.0 - ( Math.abs( x ) + Math.abs( y ) );\n\n\t\t\t\t\tif ( z < 0.0 ) {\n\n\t\t\t\t\t\tconst oldVX = x;\n\t\t\t\t\t\tx = ( 1.0 - Math.abs( y ) ) * signNotZero( oldVX );\n\t\t\t\t\t\ty = ( 1.0 - Math.abs( oldVX ) ) * signNotZero( y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst len = Math.sqrt( x * x + y * y + z * z );\n\t\t\t\t\tnormals[ 3 * i + 0 ] = x / len;\n\t\t\t\t\tnormals[ 3 * i + 1 ] = y / len;\n\t\t\t\t\tnormals[ 3 * i + 2 ] = z / len;\n\n\t\t\t\t}\n\n\t\t\t\textensions[ 'octvertexnormals' ] = {\n\t\t\t\t\textensionId,\n\t\t\t\t\tnormals,\n\t\t\t\t};\n\n\t\t\t} else if ( extensionId === 2 ) {\n\n\t\t\t\t// water mask\n\t\t\t\tconst size = extensionLength === 1 ? 1 : 256;\n\t\t\t\tconst mask = readBuffer( size * size, Uint8Array );\n\t\t\t\textensions[ 'watermask' ] = {\n\t\t\t\t\textensionId,\n\t\t\t\t\tmask,\n\t\t\t\t\tsize,\n\t\t\t\t};\n\n\t\t\t} else if ( extensionId === 4 ) {\n\n\t\t\t\t// metadata\n\t\t\t\tconst jsonLength = readInt();\n\t\t\t\tconst jsonBuffer = readBuffer( jsonLength, Uint8Array );\n\t\t\t\tconst json = new TextDecoder().decode( jsonBuffer );\n\t\t\t\textensions[ 'metadata' ] = {\n\t\t\t\t\textensionId,\n\t\t\t\t\tjson: JSON.parse( json ),\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\theader,\n\t\t\tindices,\n\t\t\tvertexData: {\n\t\t\t\tu: uResult,\n\t\t\t\tv: vResult,\n\t\t\t\theight: hResult,\n\t\t\t},\n\t\t\tedgeIndices,\n\t\t\textensions,\n\t\t};\n\n\t}\n\n}\n\nfunction signNotZero( v ) {\n\n\treturn v < 0.0 ? - 1.0 : 1.0;\n\n}\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tDataTexture,\n\tDefaultLoadingManager,\n\tLinearFilter,\n\tLinearMipMapLinearFilter,\n\tMathUtils,\n\tMesh,\n\tMeshStandardMaterial,\n\tRGFormat,\n\tTriangle,\n\tUnsignedByteType,\n\tVector3,\n} from 'three';\nimport { QuantizedMeshLoaderBase } from '../../../core/plugins/loaders/QuantizedMeshLoaderBase.js';\nimport { Ellipsoid } from '../../../three/renderer/math/Ellipsoid.js';\n\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _tri = /* @__PURE__ */ new Triangle();\nconst _uvh = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\nexport class QuantizedMeshLoader extends QuantizedMeshLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.ellipsoid = new Ellipsoid();\n\t\tthis.skirtLength = 1000;\n\t\tthis.smoothSkirtNormals = true;\n\t\tthis.solid = false;\n\n\t\t// set the range of the tile\n\t\tthis.minLat = - Math.PI / 2;\n\t\tthis.maxLat = Math.PI / 2;\n\t\tthis.minLon = - Math.PI;\n\t\tthis.maxLon = Math.PI;\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst {\n\t\t\tellipsoid,\n\t\t\tsolid,\n\t\t\tskirtLength,\n\t\t\tsmoothSkirtNormals,\n\n\t\t\tminLat,\n\t\t\tmaxLat,\n\t\t\tminLon,\n\t\t\tmaxLon,\n\t\t} = this;\n\n\t\tconst {\n\t\t\theader,\n\t\t\tindices,\n\t\t\tvertexData,\n\t\t\tedgeIndices,\n\t\t\textensions,\n\t\t} = super.parse( buffer );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new MeshStandardMaterial();\n\t\tconst mesh = new Mesh( geometry, material );\n\t\tmesh.position.set( ...header.center );\n\n\t\tconst includeNormals = 'octvertexnormals' in extensions;\n\t\tconst vertexCount = vertexData.u.length;\n\t\tconst positions = [];\n\t\tconst uvs = [];\n\t\tconst indexArr = [];\n\t\tconst normals = [];\n\t\tlet groupOffset = 0;\n\t\tlet materialIndex = 0;\n\n\t\t// construct terrain\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\treadUVHeight( i, _uvh );\n\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos );\n\n\t\t\tuvs.push( _uvh.x, _uvh.y );\n\t\t\tpositions.push( ..._pos );\n\n\t\t}\n\n\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tindexArr.push( indices[ i ] );\n\n\t\t}\n\n\t\tif ( includeNormals ) {\n\n\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\tfor ( let i = 0, l = extNormals.length; i < l; i ++ ) {\n\n\t\t\t\tnormals.push( extNormals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add material group\n\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\tgroupOffset += indices.length;\n\t\tmaterialIndex ++;\n\n\t\t// create a lower cap\n\t\tif ( solid ) {\n\n\t\t\tconst indexOffset = positions.length / 3;\n\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\treadUVHeight( i, _uvh );\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos, - skirtLength );\n\n\t\t\t\tuvs.push( _uvh.x, _uvh.y );\n\t\t\t\tpositions.push( ..._pos );\n\n\t\t\t}\n\n\t\t\tfor ( let i = indices.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tindexArr.push( indices[ i ] + indexOffset );\n\n\t\t\t}\n\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\t\tfor ( let i = 0, l = extNormals.length; i < l; i ++ ) {\n\n\t\t\t\t\tnormals.push( - extNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// add material group\n\t\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\t\tgroupOffset += indices.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\t// construct skirts\n\t\tif ( skirtLength > 0 ) {\n\n\t\t\tconst {\n\t\t\t\twestIndices,\n\t\t\t\teastIndices,\n\t\t\t\tsouthIndices,\n\t\t\t\tnorthIndices,\n\t\t\t} = edgeIndices;\n\n\t\t\t// construct the indices\n\t\t\tlet offset;\n\n\t\t\t// west\n\t\t\tconst westStrip = constructEdgeStrip( westIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...westStrip.uv );\n\t\t\tpositions.push( ...westStrip.positions );\n\t\t\tfor ( let i = 0, l = westStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( westStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// east\n\t\t\tconst eastStrip = constructEdgeStrip( eastIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...eastStrip.uv );\n\t\t\tpositions.push( ...eastStrip.positions );\n\t\t\tfor ( let i = 0, l = eastStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( eastStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// south\n\t\t\tconst southStrip = constructEdgeStrip( southIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...southStrip.uv );\n\t\t\tpositions.push( ...southStrip.positions );\n\t\t\tfor ( let i = 0, l = southStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( southStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// north\n\t\t\tconst northStrip = constructEdgeStrip( northIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...northStrip.uv );\n\t\t\tpositions.push( ...northStrip.positions );\n\t\t\tfor ( let i = 0, l = northStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( northStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// add the normals\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tnormals.push( ...westStrip.normals );\n\t\t\t\tnormals.push( ...eastStrip.normals );\n\t\t\t\tnormals.push( ...southStrip.normals );\n\t\t\t\tnormals.push( ...northStrip.normals );\n\n\t\t\t}\n\n\t\t\t// add material group\n\t\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\t\tgroupOffset += indices.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\t// shift the positions by the center of the tile\n\t\tfor ( let i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\tpositions[ i + 0 ] -= header.center[ 0 ];\n\t\t\tpositions[ i + 1 ] -= header.center[ 1 ];\n\t\t\tpositions[ i + 2 ] -= header.center[ 2 ];\n\n\t\t}\n\n\t\t// generate geometry and mesh\n\t\tconst indexBuffer = positions.length / 3 > 65535 ? new Uint32Array( indexArr ) : new Uint16Array( indexArr );\n\t\tgeometry.setIndex( new BufferAttribute( indexBuffer, 1, false ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( positions ), 3, false ) );\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( uvs ), 2, false ) );\n\t\tif ( includeNormals ) {\n\n\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3, false ) );\n\n\t\t}\n\n\t\t// generate the water texture\n\t\tif ( 'watermask' in extensions ) {\n\n\t\t\t// invert the mask data\n\t\t\t// TODO: this inversion step can be a bit slow\n\t\t\tconst { mask, size } = extensions[ 'watermask' ];\n\t\t\tconst maskBuffer = new Uint8Array( 2 * size * size );\n\t\t\tfor ( let i = 0, l = mask.length; i < l; i ++ ) {\n\n\t\t\t\tconst v = mask[ i ] === 255 ? 0 : 255;\n\t\t\t\tmaskBuffer[ 2 * i + 0 ] = v;\n\t\t\t\tmaskBuffer[ 2 * i + 1 ] = v;\n\n\t\t\t}\n\n\t\t\t// TODO: Luminance format is not supported - eventually node materials will\n\t\t\t// make it possible to map the texture to the appropriate buffer input.\n\t\t\tconst map = new DataTexture( maskBuffer, size, size, RGFormat, UnsignedByteType );\n\t\t\tmap.flipY = true;\n\t\t\tmap.minFilter = LinearMipMapLinearFilter;\n\t\t\tmap.magFilter = LinearFilter;\n\t\t\tmap.needsUpdate = true;\n\n\t\t\tmaterial.roughnessMap = map;\n\n\t\t}\n\n\t\t// set metadata\n\t\tmesh.userData.minHeight = header.minHeight;\n\t\tmesh.userData.maxHeight = header.maxHeight;\n\n\t\tif ( 'metadata' in extensions ) {\n\n\t\t\tmesh.userData.metadata = extensions[ 'metadata' ].json;\n\n\t\t}\n\n\t\treturn mesh;\n\n\t\tfunction readUVHeight( index, target ) {\n\n\t\t\ttarget.x = vertexData.u[ index ];\n\t\t\ttarget.y = vertexData.v[ index ];\n\t\t\ttarget.z = vertexData.height[ index ];\n\t\t\treturn target;\n\n\t\t}\n\n\t\tfunction readPosition( u, v, h, target, heightOffset = 0 ) {\n\n\t\t\tconst height = MathUtils.lerp( header.minHeight, header.maxHeight, h );\n\t\t\tconst lon = MathUtils.lerp( minLon, maxLon, u );\n\t\t\tconst lat = MathUtils.lerp( minLat, maxLat, v );\n\n\t\t\tellipsoid.getCartographicToPosition( lat, lon, height + heightOffset, target );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t\tfunction constructEdgeStrip( indices ) {\n\n\t\t\tconst topUvs = [];\n\t\t\tconst topPos = [];\n\t\t\tconst botUvs = [];\n\t\t\tconst botPos = [];\n\t\t\tconst sideIndices = [];\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\treadUVHeight( indices[ i ], _uvh );\n\t\t\t\ttopUvs.push( _uvh.x, _uvh.y );\n\t\t\t\tbotUvs.push( _uvh.x, _uvh.y );\n\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos );\n\t\t\t\ttopPos.push( ..._pos );\n\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos, - skirtLength );\n\t\t\t\tbotPos.push( ..._pos );\n\n\t\t\t}\n\n\t\t\tconst triCount = ( indices.length - 1 );\n\t\t\tfor ( let i = 0; i < triCount; i ++ ) {\n\n\t\t\t\tconst t0 = i;\n\t\t\t\tconst t1 = i + 1;\n\t\t\t\tconst b0 = i + indices.length;\n\t\t\t\tconst b1 = i + indices.length + 1;\n\n\t\t\t\tsideIndices.push( t0, b0, t1 );\n\t\t\t\tsideIndices.push( t1, b0, b1 );\n\n\t\t\t}\n\n\t\t\tlet normals = null;\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tconst total = ( topPos.length + botPos.length ) / 3;\n\n\t\t\t\tif ( smoothSkirtNormals ) {\n\n\t\t\t\t\tnormals = new Array( total * 3 );\n\n\t\t\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\t\t\tconst botOffset = normals.length / 2;\n\t\t\t\t\tfor ( let i = 0, l = total / 2; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst index = indices[ i ];\n\t\t\t\t\t\tconst i3 = 3 * i;\n\t\t\t\t\t\tconst nx = extNormals[ 3 * index + 0 ];\n\t\t\t\t\t\tconst ny = extNormals[ 3 * index + 1 ];\n\t\t\t\t\t\tconst nz = extNormals[ 3 * index + 2 ];\n\n\t\t\t\t\t\tnormals[ i3 + 0 ] = nx;\n\t\t\t\t\t\tnormals[ i3 + 1 ] = ny;\n\t\t\t\t\t\tnormals[ i3 + 2 ] = nz;\n\n\t\t\t\t\t\tnormals[ botOffset + i3 + 0 ] = nx;\n\t\t\t\t\t\tnormals[ botOffset + i3 + 1 ] = ny;\n\t\t\t\t\t\tnormals[ botOffset + i3 + 2 ] = nz;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormals = [];\n\t\t\t\t\t_tri.a.fromArray( topPos, 0 );\n\t\t\t\t\t_tri.b.fromArray( botPos, 0 );\n\t\t\t\t\t_tri.c.fromArray( topPos, 3 );\n\t\t\t\t\t_tri.getNormal( _norm );\n\n\t\t\t\t\tfor ( let i = 0; i < total; i ++ ) {\n\n\t\t\t\t\t\tnormals.push( ..._norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tuv: [ ...topUvs, ...botUvs ],\n\t\t\t\tpositions: [ ...topPos, ...botPos ],\n\t\t\t\tindices: sideIndices,\n\t\t\t\tnormals,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n","import { MathUtils, Vector2, Vector3 } from 'three';\nimport { GeometryClipper, hashVertex } from './GeometryClipper.js';\nimport { Ellipsoid } from '../../../three/renderer/math/Ellipsoid.js';\n\nconst _cart = {};\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _pos0 = /* @__PURE__ */ new Vector3();\nconst _pos1 = /* @__PURE__ */ new Vector3();\nconst _pos2 = /* @__PURE__ */ new Vector3();\nconst _pos3 = /* @__PURE__ */ new Vector3();\nconst _temp = /* @__PURE__ */ new Vector3();\nconst _temp2 = /* @__PURE__ */ new Vector3();\n\nconst _uv0 = /* @__PURE__ */ new Vector2();\nconst _uv1 = /* @__PURE__ */ new Vector2();\nconst _uv2 = /* @__PURE__ */ new Vector2();\n\nexport class QuantizedMeshClipper extends GeometryClipper {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.ellipsoid = new Ellipsoid();\n\t\tthis.skirtLength = 1000;\n\t\tthis.smoothSkirtNormals = true;\n\t\tthis.solid = false;\n\n\t\tthis.minLat = - Math.PI / 2;\n\t\tthis.maxLat = Math.PI / 2;\n\t\tthis.minLon = - Math.PI;\n\t\tthis.maxLon = Math.PI;\n\n\t\tthis.attributeList = [ 'position', 'normal', 'uv' ];\n\n\t}\n\n\tclipToQuadrant( sourceMesh, left, bottom ) {\n\n\t\tconst { solid, skirtLength, ellipsoid, smoothSkirtNormals } = this;\n\n\t\tthis.clearSplitOperations();\n\t\tthis.addSplitOperation( getUvSplitOperation( 'x' ), ! left );\n\t\tthis.addSplitOperation( getUvSplitOperation( 'y' ), ! bottom );\n\n\t\tlet botResult, skirtResult;\n\t\tconst capGroup = sourceMesh.geometry.groups[ 0 ];\n\t\tconst capResult = this.getClippedData( sourceMesh, capGroup );\n\t\tthis.adjustVertices( capResult, sourceMesh.position, 0 );\n\n\t\tif ( solid ) {\n\n\t\t\tbotResult = {\n\t\t\t\tindex: capResult.index.slice().reverse(),\n\t\t\t\tattributes: {},\n\t\t\t};\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tbotResult.attributes[ key ] = capResult.attributes[ key ].slice();\n\n\t\t\t}\n\n\t\t\tconst normal = botResult.attributes.normal;\n\t\t\tif ( normal ) {\n\n\t\t\t\tfor ( let i = 0; i < normal.length; i += 3 ) {\n\n\t\t\t\t\tnormal[ i + 0 ] *= - 1;\n\t\t\t\t\tnormal[ i + 1 ] *= - 1;\n\t\t\t\t\tnormal[ i + 2 ] *= - 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.adjustVertices( botResult, sourceMesh.position, - skirtLength );\n\n\t\t}\n\n\t\tif ( skirtLength > 0 ) {\n\n\t\t\tskirtResult = {\n\t\t\t\tindex: [],\n\t\t\t\tattributes: {\n\t\t\t\t\tposition: [],\n\t\t\t\t\tnormal: [],\n\t\t\t\t\tuv: [],\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// push data onto the\n\t\t\tlet nextIndex = 0;\n\t\t\tconst vertToNewIndexMap = {};\n\t\t\tconst pushVertex = ( pos, uv, norm ) => {\n\n\t\t\t\tconst hash = hashVertex( ...pos, ...norm, ...uv );\n\t\t\t\tif ( ! ( hash in vertToNewIndexMap ) ) {\n\n\t\t\t\t\tvertToNewIndexMap[ hash ] = nextIndex;\n\t\t\t\t\tnextIndex ++;\n\n\t\t\t\t\tskirtResult.attributes.position.push( ...pos );\n\t\t\t\t\tskirtResult.attributes.normal.push( ...norm );\n\t\t\t\t\tskirtResult.attributes.uv.push( ...uv );\n\n\t\t\t\t}\n\n\t\t\t\tskirtResult.index.push( vertToNewIndexMap[ hash ] );\n\n\t\t\t};\n\n\t\t\t// TODO: this seems to have some problematic cases at the root tiles near the poles\n\t\t\tconst capIndex = capResult.index;\n\t\t\tconst capUv = capResult.attributes.uv;\n\t\t\tconst capPosition = capResult.attributes.position;\n\t\t\tconst capNormal = capResult.attributes.normal;\n\t\t\tconst capTriangles = capResult.index.length / 3;\n\t\t\tfor ( let i = 0; i < capTriangles; i ++ ) {\n\n\t\t\t\tconst triOffset = 3 * i;\n\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\t\tconst ne = ( e + 1 ) % 3;\n\t\t\t\t\tconst i0 = capIndex[ triOffset + e ];\n\t\t\t\t\tconst i1 = capIndex[ triOffset + ne ];\n\n\t\t\t\t\t_uv0.fromArray( capUv, i0 * 2 );\n\t\t\t\t\t_uv1.fromArray( capUv, i1 * 2 );\n\n\t\t\t\t\t// find the vertices that lie on the edge\n\t\t\t\t\tif (\n\t\t\t\t\t\t_uv0.x === _uv1.x && ( _uv0.x === 0 || _uv0.x === 0.5 || _uv0.x === 1.0 ) ||\n\t\t\t\t\t\t_uv0.y === _uv1.y && ( _uv0.y === 0 || _uv0.y === 0.5 || _uv0.y === 1.0 )\n\t\t\t\t\t) {\n\n\t\t\t\t\t\t_pos0.fromArray( capPosition, i0 * 3 );\n\t\t\t\t\t\t_pos1.fromArray( capPosition, i1 * 3 );\n\n\t\t\t\t\t\tconst u0 = _pos0;\n\t\t\t\t\t\tconst u1 = _pos1;\n\n\t\t\t\t\t\tconst b0 = _pos2.copy( _pos0 );\n\t\t\t\t\t\tconst b1 = _pos3.copy( _pos1 );\n\n\t\t\t\t\t\t_temp.copy( b0 ).add( sourceMesh.position );\n\t\t\t\t\t\tellipsoid.getPositionToNormal( _temp, _temp );\n\t\t\t\t\t\tb0.addScaledVector( _temp, - skirtLength );\n\n\t\t\t\t\t\t_temp.copy( b1 ).add( sourceMesh.position );\n\t\t\t\t\t\tellipsoid.getPositionToNormal( _temp, _temp );\n\t\t\t\t\t\tb1.addScaledVector( _temp, - skirtLength );\n\n\t\t\t\t\t\tif ( smoothSkirtNormals && capNormal ) {\n\n\t\t\t\t\t\t\t_temp.fromArray( capNormal, i0 * 3 );\n\t\t\t\t\t\t\t_temp2.fromArray( capNormal, i1 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_temp.subVectors( u0, u1 );\n\t\t\t\t\t\t\t_temp2.subVectors( u0, b0 ).cross( _temp ).normalize();\n\t\t\t\t\t\t\t_temp.copy( _temp2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpushVertex( u1, _uv1, _temp2 );\n\t\t\t\t\t\tpushVertex( u0, _uv0, _temp );\n\t\t\t\t\t\tpushVertex( b0, _uv0, _temp );\n\n\t\t\t\t\t\tpushVertex( u1, _uv1, _temp2 );\n\t\t\t\t\t\tpushVertex( b0, _uv0, _temp );\n\t\t\t\t\t\tpushVertex( b1, _uv1, _temp2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst capLength = capResult.index.length;\n\t\tconst result = capResult;\n\t\tif ( botResult ) {\n\n\t\t\tconst { index, attributes } = botResult;\n\t\t\tconst offset = result.attributes.position.length / 3;\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tresult.index.push( index[ i ] + offset );\n\n\t\t\t}\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tresult.attributes[ key ].push( ...attributes[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( skirtResult ) {\n\n\t\t\tconst { index, attributes } = skirtResult;\n\t\t\tconst offset = result.attributes.position.length / 3;\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tresult.index.push( index[ i ] + offset );\n\n\t\t\t}\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tresult.attributes[ key ].push( ...attributes[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// offset the uvs\n\t\tconst xUvOffset = left ? 0 : - 0.5;\n\t\tconst yUvOffset = bottom ? 0 : - 0.5;\n\t\tconst uv = result.attributes.uv;\n\t\tfor ( let i = 0, l = uv.length; i < l; i += 2 ) {\n\n\t\t\tuv[ i ] = ( uv[ i ] + xUvOffset ) * 2.0;\n\t\t\tuv[ i + 1 ] = ( uv[ i + 1 ] + yUvOffset ) * 2.0;\n\n\t\t}\n\n\t\t// construct the result\n\t\tconst resultMesh = this.constructMesh( result.attributes, result.index, sourceMesh );\n\t\tresultMesh.userData.minHeight = sourceMesh.userData.minHeight;\n\t\tresultMesh.userData.maxHeight = sourceMesh.userData.maxHeight;\n\n\t\tlet materialIndex = 0;\n\t\tlet start = 0;\n\t\tresultMesh.geometry.addGroup( start, capLength, materialIndex );\n\t\tstart += capLength;\n\t\tmaterialIndex ++;\n\n\t\tif ( botResult ) {\n\n\t\t\tresultMesh.geometry.addGroup( start, botResult.index.length, materialIndex );\n\t\t\tstart += botResult.index.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\tif ( skirtResult ) {\n\n\t\t\tresultMesh.geometry.addGroup( start, skirtResult.index.length, materialIndex );\n\t\t\tstart += skirtResult.index.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\treturn resultMesh;\n\n\t}\n\n\tadjustVertices( info, position, offset ) {\n\n\t\tconst { ellipsoid, minLat, maxLat, minLon, maxLon } = this;\n\t\tconst { attributes, vertexIsClipped } = info;\n\t\tconst posArr = attributes.position;\n\t\tconst uvArr = attributes.uv;\n\n\t\tconst vertexCount = posArr.length / 3;\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tconst uv = _uv0.fromArray( uvArr, i * 2 );\n\t\t\tif ( vertexIsClipped && vertexIsClipped[ i ] ) {\n\n\t\t\t\tif ( Math.abs( uv.x - 0.5 ) < 1e-10 ) {\n\n\t\t\t\t\tuv.x = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\tif ( Math.abs( uv.y - 0.5 ) < 1e-10 ) {\n\n\t\t\t\t\tuv.y = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\t_uv0.toArray( uvArr, i * 2 );\n\n\t\t\t}\n\n\t\t\tconst lat = MathUtils.lerp( minLat, maxLat, uv.y );\n\t\t\tconst lon = MathUtils.lerp( minLon, maxLon, uv.x );\n\t\t\tconst point = _vec.fromArray( posArr, i * 3 ).add( position );\n\t\t\tellipsoid.getPositionToCartographic( point, _cart );\n\t\t\tellipsoid.getCartographicToPosition( lat, lon, _cart.height + offset, point );\n\t\t\tpoint.sub( position );\n\t\t\tpoint.toArray( posArr, i * 3 );\n\n\t\t}\n\n\t}\n\n}\n\nfunction getUvSplitOperation( axis ) {\n\n\treturn ( geometry, i0, i1, i2, barycoord ) => {\n\n\t\tconst uv = geometry.attributes.uv;\n\t\t_uv0.fromBufferAttribute( uv, i0 );\n\t\t_uv1.fromBufferAttribute( uv, i1 );\n\t\t_uv2.fromBufferAttribute( uv, i2 );\n\n\t\treturn _uv0[ axis ] * barycoord.x + _uv1[ axis ] * barycoord.y + _uv2[ axis ] * barycoord.z - 0.5;\n\n\t};\n\n}\n","import { Vector3 } from 'three';\nimport { QuantizedMeshLoader } from './loaders/QuantizedMeshLoader.js';\nimport { TilingScheme } from './images/utils/TilingScheme.js';\nimport { ProjectionScheme } from './images/utils/ProjectionScheme.js';\nimport { QuantizedMeshClipper } from './utilities/QuantizedMeshClipper.js';\n\nconst TILE_X = Symbol( 'TILE_X' );\nconst TILE_Y = Symbol( 'TILE_Y' );\nconst TILE_LEVEL = Symbol( 'TILE_LEVEL' );\nconst TILE_AVAILABLE = Symbol( 'TILE_AVAILABLE' );\n\n// We don't know the height ranges for the tile set on load so assume a large range and\n// adjust it once the tiles have actually loaded based on the min and max height\nconst INITIAL_HEIGHT_RANGE = 1e4;\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// Checks if the given tile is available\nfunction isTileAvailable( available, level, x, y ) {\n\n\tif ( available && level < available.length ) {\n\n\t\t// TODO: consider a binary search\n\t\tconst availableSet = available[ level ];\n\t\tfor ( let i = 0, l = availableSet.length; i < l; i ++ ) {\n\n\t\t\tconst { startX, startY, endX, endY } = availableSet[ i ];\n\t\t\tif ( x >= startX && x <= endX && y >= startY && y <= endY ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n// Calculates the max level that can be loaded.\nfunction getMaxLevel( layer ) {\n\n\tconst { available = null, maxzoom = null } = layer;\n\treturn maxzoom === null ? available.length - 1 : maxzoom;\n\n}\n\n// Calculates whether metadata availability is present - returns -1 if not.\nfunction getMetadataAvailability( layer ) {\n\n\tconst { metadataAvailability = - 1 } = layer;\n\treturn metadataAvailability;\n\n}\n\n// Calculates whether the given tile should have metadata availability\nfunction getTileHasMetadata( tile, layer ) {\n\n\tconst level = tile[ TILE_LEVEL ];\n\tconst metadataAvailability = getMetadataAvailability( layer );\n\tconst maxLevel = getMaxLevel( layer );\n\n\treturn level < maxLevel && metadataAvailability !== - 1 && ( level % metadataAvailability ) === 0;\n\n}\n\n// Constructs the url for the given tile content\nfunction getContentUrl( x, y, level, version, layer ) {\n\n\treturn layer.tiles[ 0 ]\n\t\t.replace( /{\\s*z\\s*}/g, level )\n\t\t.replace( /{\\s*x\\s*}/g, x )\n\t\t.replace( /{\\s*y\\s*}/g, y )\n\t\t.replace( /{\\s*version\\s*}/g, version );\n\n}\n\nexport class QuantizedMeshPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tuseRecommendedSettings = true,\n\t\t\tskirtLength = null,\n\t\t\tsmoothSkirtNormals = true,\n\t\t\tsolid = false,\n\t\t} = options;\n\n\t\t// plugin needs to run before other plugins that fetch data since content\n\t\t// is handled and loaded in a custom way\n\t\tthis.name = 'QUANTIZED_MESH_PLUGIN';\n\t\tthis.priority = - 1000;\n\n\t\tthis.tiles = null;\n\t\tthis.layer = null;\n\t\tthis.useRecommendedSettings = useRecommendedSettings;\n\t\tthis.skirtLength = skirtLength;\n\t\tthis.smoothSkirtNormals = smoothSkirtNormals;\n\t\tthis.solid = solid;\n\t\tthis.attribution = null;\n\n\t\tthis.tiling = new TilingScheme();\n\t\tthis.projection = new ProjectionScheme();\n\n\t}\n\n\t// Plugin function\n\tinit( tiles ) {\n\n\t\t// TODO: should we avoid setting this globally?\n\t\ttiles.fetchOptions.headers = tiles.fetchOptions.headers || {};\n\t\ttiles.fetchOptions.headers.Accept = 'application/vnd.quantized-mesh,application/octet-stream;q=0.9';\n\n\t\tif ( this.useRecommendedSettings ) {\n\n\t\t\ttiles.errorTarget = 2;\n\n\t\t}\n\n\t\tthis.tiles = tiles;\n\n\t}\n\n\tloadRootTileSet() {\n\n\t\tconst { tiles } = this;\n\n\t\t// initialize href to resolve the root in case it's specified as a relative url\n\t\tlet url = new URL( 'layer.json', new URL( tiles.rootURL, location.href ) );\n\t\ttiles.invokeAllPlugins( plugin => url = plugin.preprocessURL ? plugin.preprocessURL( url, null ) : url );\n\n\t\treturn tiles\n\t\t\t.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( url, this.tiles.fetchOptions ) )\n\t\t\t.then( res => res.json() )\n\t\t\t.then( json => {\n\n\t\t\t\tthis.layer = json;\n\t\t\t\tconst {\n\t\t\t\t\tprojection: layerProjection = 'EPSG:4326',\n\t\t\t\t\textensions = [],\n\t\t\t\t\tattribution = '',\n\t\t\t\t\tavailable = null,\n\t\t\t\t} = json;\n\n\t\t\t\tconst {\n\t\t\t\t\ttiling,\n\t\t\t\t\ttiles,\n\t\t\t\t\tprojection,\n\t\t\t\t} = this;\n\n\t\t\t\t// attribution\n\t\t\t\tif ( attribution ) {\n\n\t\t\t\t\tthis.attribution = {\n\t\t\t\t\t\tvalue: attribution,\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tcollapsible: true,\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\t// extensions\n\t\t\t\tif ( extensions.length > 0 ) {\n\n\t\t\t\t\ttiles.fetchOptions.headers[ 'Accept' ] += `;extensions=${ extensions.join( '-' ) }`;\n\n\t\t\t\t}\n\n\t\t\t\t// initialize tiling, projection\n\t\t\t\tprojection.setScheme( layerProjection );\n\n\t\t\t\tconst { tileCountX, tileCountY } = projection;\n\t\t\t\ttiling.setProjection( projection );\n\t\t\t\ttiling.generateLevels( getMaxLevel( json ) + 1, tileCountX, tileCountY );\n\n\t\t\t\t// initialize children\n\t\t\t\tconst children = [];\n\t\t\t\tfor ( let x = 0; x < tileCountX; x ++ ) {\n\n\t\t\t\t\tconst child = this.createChild( 0, x, 0, available );\n\t\t\t\t\tif ( child ) {\n\n\t\t\t\t\t\tchildren.push( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// produce the tile set root\n\t\t\t\tconst tileset = {\n\t\t\t\t\tasset: {\n\t\t\t\t\t\tversion: '1.1'\n\t\t\t\t\t},\n\t\t\t\t\tgeometricError: Infinity,\n\t\t\t\t\troot: {\n\t\t\t\t\t\trefine: 'REPLACE',\n\t\t\t\t\t\tgeometricError: Infinity,\n\t\t\t\t\t\tboundingVolume: {\n\t\t\t\t\t\t\tregion: [ ...this.tiling.getContentBounds(), - INITIAL_HEIGHT_RANGE, INITIAL_HEIGHT_RANGE ],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tchildren: children,\n\n\t\t\t\t\t\t[ TILE_AVAILABLE ]: available,\n\t\t\t\t\t\t[ TILE_LEVEL ]: - 1,\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tlet baseUrl = tiles.rootURL;\n\t\t\t\ttiles.invokeAllPlugins( plugin => baseUrl = plugin.preprocessURL ? plugin.preprocessURL( baseUrl, null ) : baseUrl );\n\t\t\t\ttiles.preprocessTileSet( tileset, baseUrl );\n\n\t\t\t\treturn tileset;\n\n\t\t\t} );\n\n\t}\n\n\tparseToMesh( buffer, tile, extension, uri ) {\n\n\t\tconst {\n\t\t\tskirtLength,\n\t\t\tsolid,\n\t\t\tsmoothSkirtNormals,\n\t\t\ttiles,\n\t\t} = this;\n\n\t\t// set up loader\n\t\tconst ellipsoid = tiles.ellipsoid;\n\n\t\t// split the parent tile if needed\n\t\tlet result;\n\t\tif ( extension === 'quantized_tile_split' ) {\n\n\t\t\t// split the parent tile\n\t\t\tconst searchParams = new URL( uri ).searchParams;\n\t\t\tconst left = searchParams.get( 'left' ) === 'true';\n\t\t\tconst bottom = searchParams.get( 'bottom' ) === 'true';\n\n\t\t\t// parse the tile data\n\t\t\tconst clipper = new QuantizedMeshClipper();\n\t\t\tclipper.ellipsoid.copy( ellipsoid );\n\t\t\tclipper.solid = solid;\n\t\t\tclipper.smoothSkirtNormals = smoothSkirtNormals;\n\t\t\tclipper.skirtLength = skirtLength === null ? tile.geometricError : skirtLength;\n\n\t\t\tconst [ west, south, east, north ] = tile.parent.boundingVolume.region;\n\t\t\tclipper.minLat = south;\n\t\t\tclipper.maxLat = north;\n\t\t\tclipper.minLon = west;\n\t\t\tclipper.maxLon = east;\n\n\t\t\tresult = clipper.clipToQuadrant( tile.parent.cached.scene, left, bottom );\n\n\t\t} else if ( extension === 'terrain' ) {\n\n\t\t\tconst loader = new QuantizedMeshLoader( tiles.manager );\n\t\t\tloader.ellipsoid.copy( ellipsoid );\n\t\t\tloader.solid = solid;\n\t\t\tloader.smoothSkirtNormals = smoothSkirtNormals;\n\t\t\tloader.skirtLength = skirtLength === null ? tile.geometricError : skirtLength;\n\n\t\t\tconst [ west, south, east, north ] = tile.boundingVolume.region;\n\t\t\tloader.minLat = south;\n\t\t\tloader.maxLat = north;\n\t\t\tloader.minLon = west;\n\t\t\tloader.maxLon = east;\n\n\t\t\tresult = loader.parse( buffer );\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// adjust the bounding region to be more accurate based on the contents of the terrain file\n\t\t// NOTE: The debug region bounds are only created after the tile is first shown so the debug\n\t\t// region bounding volume will have the correct dimensions.\n\t\tconst { minHeight, maxHeight, metadata } = result.userData;\n\t\ttile.boundingVolume.region[ 4 ] = minHeight;\n\t\ttile.boundingVolume.region[ 5 ] = maxHeight;\n\t\ttile.cached.boundingVolume.setRegionData( ellipsoid, ...tile.boundingVolume.region );\n\n\t\t// use the geometric error value if it's present\n\t\tif ( metadata ) {\n\n\t\t\tif ( 'geometricerror' in metadata ) {\n\n\t\t\t\ttile.geometricError = metadata.geometricerror;\n\n\t\t\t}\n\n\t\t\t// if the tile hasn't been expanded yet and isn't in the queue to do so then\n\t\t\t// mark it for expansion again\n\t\t\tconst hasMetadata = getTileHasMetadata( tile, this.layer );\n\t\t\tif ( hasMetadata && 'available' in metadata && tile.children.length === 0 ) {\n\n\t\t\t\t// add an offset to account for the current and previous layers\n\t\t\t\ttile[ TILE_AVAILABLE ] = [\n\t\t\t\t\t...new Array( tile[ TILE_LEVEL ] + 1 ).fill( null ),\n\t\t\t\t\t...metadata.available,\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// NOTE: we expand children only once the parent mesh data is loaded to ensure the mesh\n\t\t// data is ready for clipping. It's possible that this child data gets to the parse stage\n\t\t// first, otherwise, while the parent is still downloading.\n\t\t// Ideally we would be able to guarantee parents are loaded first but this is an odd case.\n\t\tthis.expandChildren( tile );\n\n\t\treturn result;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.attribution ) {\n\n\t\t\ttarget.push( this.attribution );\n\n\t\t}\n\n\t}\n\n\t// Local functions\n\tcreateChild( level, x, y, available ) {\n\n\t\tconst { tiles, layer, tiling, projection } = this;\n\t\tconst ellipsoid = tiles.ellipsoid;\n\n\t\t// metadata availability will return \"null\" if there are no more children but we\n\t\t// have to always load the root tile data.\n\t\tconst isAvailable = available === null && level === 0 || isTileAvailable( available, level, x, y );\n\t\tconst url = getContentUrl( x, y, level, 1, layer );\n\t\tconst region = [ ...tiling.getTileBounds( x, y, level ), - INITIAL_HEIGHT_RANGE, INITIAL_HEIGHT_RANGE ];\n\t\tconst [ /* west */, south, /* east */, north, /* minHeight */, maxHeight ] = region;\n\t\tconst midLat = ( south > 0 ) !== ( north > 0 ) ? 0 : Math.min( Math.abs( south ), Math.abs( north ) );\n\n\t\t// get the projected perimeter\n\t\tellipsoid.getCartographicToPosition( midLat, 0, maxHeight, _vec );\n\t\t_vec.z = 0;\n\n\t\t// https://github.com/CesiumGS/cesium/blob/53889cbed2a91d38e0fae4b6f2dcf6783632fc92/packages/engine/Source/Scene/QuadtreeTileProvider.js#L24-L31\n\t\t// Implicit quantized mesh tile error halves with every layer\n\t\tconst tileCountX = projection.tileCountX;\n\t\tconst maxRadius = Math.max( ...ellipsoid.radius );\n\t\tconst rootGeometricError = maxRadius * 2 * Math.PI * 0.25 / ( 65 * tileCountX );\n\t\tconst geometricError = rootGeometricError / ( 2 ** level );\n\n\t\t// Create the child\n\t\tconst tile = {\n\t\t\t[ TILE_AVAILABLE ]: null,\n\t\t\t[ TILE_LEVEL ]: level,\n\t\t\t[ TILE_X ]: x,\n\t\t\t[ TILE_Y ]: y,\n\t\t\trefine: 'REPLACE',\n\t\t\tgeometricError: geometricError,\n\t\t\tboundingVolume: { region },\n\t\t\tcontent: isAvailable ? { uri: url } : null,\n\t\t\tchildren: []\n\t\t};\n\n\t\t// if we're relying on tile metadata availability then skip storing the tile metadata\n\t\tif ( ! getTileHasMetadata( tile, layer ) ) {\n\n\t\t\ttile[ TILE_AVAILABLE ] = available;\n\n\t\t}\n\n\t\treturn tile;\n\n\t}\n\n\texpandChildren( tile ) {\n\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tconst x = tile[ TILE_X ];\n\t\tconst y = tile[ TILE_Y ];\n\t\tconst available = tile[ TILE_AVAILABLE ];\n\n\t\tlet hasChildren = false;\n\t\tfor ( let cx = 0; cx < 2; cx ++ ) {\n\n\t\t\tfor ( let cy = 0; cy < 2; cy ++ ) {\n\n\t\t\t\tconst child = this.createChild( level + 1, 2 * x + cx, 2 * y + cy, available );\n\t\t\t\tif ( child.content !== null ) {\n\n\t\t\t\t\ttile.children.push( child );\n\t\t\t\t\thasChildren = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttile.children.push( child );\n\t\t\t\t\tchild.content = { uri: `tile.quantized_tile_split?bottom=${ cy === 0 }&left=${ cx === 0 }` };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! hasChildren ) {\n\n\t\t\ttile.children.length = 0;\n\n\t\t}\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\t// if this is our custom url indicating a tile split then return fake response\n\t\tif ( /quantized_tile_split/.test( uri ) ) {\n\n\t\t\treturn new ArrayBuffer();\n\n\t\t}\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\t// dispose of the available array since we will get it again if this tile is loaded\n\t\tif ( getTileHasMetadata( tile, this.layer ) ) {\n\n\t\t\ttile[ TILE_AVAILABLE ] = null;\n\n\t\t}\n\n\t\t// Note: we remove all children always because child tiles can rely on splitting parent tiles\n\t\t// and we can find ourselves in a situation where a child tile is ready first but the parent tile\n\t\t// hasn't loaded, causing a stall / race condition in the parsing queue. To avoid this dependency\n\t\t// we just remove all children and generate them again one the parent is loaded.\n\t\t// Only get rid of the children if this plugin was responsible for them.\n\t\tif ( TILE_AVAILABLE in tile ) {\n\n\t\t\ttile.children.forEach( child => {\n\n\t\t\t\t// TODO: there should be a reliable way for removing children like this.\n\t\t\t\tthis.tiles.processNodeQueue.remove( child );\n\n\t\t\t} );\n\t\t\ttile.children.length = 0;\n\t\t\ttile.__childrenProcessed = 0;\n\n\t\t}\n\n\t}\n\n}\n","import { CesiumIonAuth } from '../../core/plugins/auth/CesiumIonAuth.js';\nimport { GoogleCloudAuthPlugin } from './GoogleCloudAuthPlugin.js';\nimport { TMSTilesPlugin } from './images/EPSGTilesPlugin.js';\nimport { QuantizedMeshPlugin } from './QuantizedMeshPlugin.js';\n\nexport class CesiumIonAuthPlugin {\n\n\tget apiToken() {\n\n\t\treturn this.auth.apiToken;\n\n\t}\n\n\tset apiToken( v ) {\n\n\t\tthis.auth.apiToken = v;\n\n\t}\n\n\tget autoRefreshToken() {\n\n\t\treturn this.auth.autoRefreshToken;\n\n\t}\n\n\tset autoRefreshToken( v ) {\n\n\t\tthis.auth.autoRefreshToken = v;\n\n\t}\n\n\tconstructor( { apiToken, assetId = null, autoRefreshToken = false, useRecommendedSettings = true } ) {\n\n\t\tthis.name = 'CESIUM_ION_AUTH_PLUGIN';\n\t\tthis.auth = new CesiumIonAuth( { apiToken, autoRefreshToken } );\n\n\t\tthis.assetId = assetId;\n\t\tthis.autoRefreshToken = autoRefreshToken;\n\t\tthis.useRecommendedSettings = useRecommendedSettings;\n\t\tthis.tiles = null;\n\n\t\tthis._tileSetVersion = - 1;\n\t\tthis._attributions = [];\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tif ( this.assetId !== null ) {\n\n\t\t\ttiles.rootURL = `https://api.cesium.com/v1/assets/${ this.assetId }/endpoint`;\n\n\t\t}\n\n\t\tthis.tiles = tiles;\n\t\tthis.auth.authURL = tiles.rootURL;\n\n\t\t// reset the tiles in case this plugin was removed and re-added\n\t\ttiles.resetFailedTiles();\n\n\t}\n\n\tloadRootTileSet() {\n\n\t\t// ensure we have an up-to-date token and root url, then trigger the internal\n\t\t// root tile set load function\n\t\treturn this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( json => {\n\n\t\t\t\tthis._initializeFromAsset( json );\n\t\t\t\treturn this.tiles.invokeOnePlugin( plugin => plugin !== this && plugin.loadRootTileSet && plugin.loadRootTileSet() );\n\n\t\t\t} )\n\t\t\t.catch( error => {\n\n\t\t\t\tthis.tiles.dispatchEvent( {\n\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\ttile: null,\n\t\t\t\t\terror,\n\t\t\t\t\turl: this.auth.authURL,\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t}\n\n\tpreprocessURL( uri ) {\n\n\t\turi = new URL( uri );\n\t\tif ( /^http/.test( uri.protocol ) && this._tileSetVersion != - 1 ) {\n\n\t\t\turi.searchParams.set( 'v', this._tileSetVersion );\n\n\t\t}\n\t\treturn uri.toString();\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\tconst tiles = this.tiles;\n\t\tif ( tiles.getPluginByName( 'GOOGLE_CLOUD_AUTH_PLUGIN' ) !== null ) {\n\n\t\t\treturn null;\n\n\t\t} else {\n\n\t\t\treturn this.auth.fetch( uri, options );\n\n\t\t}\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.tiles.visibleTiles.size > 0 ) {\n\n\t\t\ttarget.push( ...this._attributions );\n\n\t\t}\n\n\t}\n\n\t_initializeFromAsset( json ) {\n\n\t\tconst tiles = this.tiles;\n\t\tif ( 'externalType' in json ) {\n\n\t\t\tconst url = new URL( json.options.url );\n\t\t\ttiles.rootURL = json.options.url;\n\n\t\t\t// if the tile set is \"external\" then assume it's a google API tile set\n\t\t\ttiles.registerPlugin( new GoogleCloudAuthPlugin( {\n\t\t\t\tapiToken: url.searchParams.get( 'key' ),\n\t\t\t\tautoRefreshToken: this.autoRefreshToken,\n\t\t\t\tuseRecommendedSettings: this.useRecommendedSettings,\n\t\t\t} ) );\n\n\t\t} else {\n\n\t\t\t// GLTF\n\t\t\t// CZML\n\t\t\t// KML\n\t\t\t// GEOJSON\n\t\t\tif ( json.type === 'TERRAIN' && tiles.getPluginByName( 'QUANTIZED_MESH_PLUGIN' ) === null ) {\n\n\t\t\t\ttiles.registerPlugin( new QuantizedMeshPlugin( {\n\t\t\t\t\tuseRecommendedSettings: this.useRecommendedSettings,\n\t\t\t\t} ) );\n\n\t\t\t} else if ( json.type === 'IMAGERY' && tiles.getPluginByName( 'TMS_TILES_PLUGIN' ) === null ) {\n\n\t\t\t\ttiles.registerPlugin( new TMSTilesPlugin( {\n\t\t\t\t\tuseRecommendedSettings: this.useRecommendedSettings,\n\t\t\t\t\tshape: 'ellipsoid',\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\ttiles.rootURL = json.url;\n\n\t\t\t// save the version key if present\n\t\t\tconst url = new URL( json.url );\n\t\t\tif ( url.searchParams.has( 'v' ) && this._tileSetVersion === - 1 ) {\n\n\t\t\t\tthis._tileSetVersion = url.searchParams.get( 'v' );\n\n\t\t\t}\n\n\t\t\tif ( json.attributions ) {\n\n\t\t\t\tthis._attributions = json.attributions.map( att => ( {\n\t\t\t\t\tvalue: att.html,\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\tcollapsible: att.collapsible,\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n"],"names":["TILES_MAP_URL","GoogleCloudAuth","options","apiToken","sessionOptions","autoRefreshToken","url","fetchUrl","res","json","getSessionToken","fetchOptions","sessionToken","root","traverseSet","tile","params","GoogleAttributionsManager","line","add","creditsCount","tokens","i","l","t","a","b","countA","pair","TILES_3D_API","GoogleCloudAuthPlugin","logoUrl","useRecommendedSettings","tiles","auth","visible","copyright","_b","_a","target","uri","zigZagDecode","value","QuantizedMeshLoaderBase","LoaderBase","args","buffer","pointer","view","readFloat64","result","readFloat32","readInt","readByte","readBuffer","count","type","header","vertexCount","uBuffer","vBuffer","hBuffer","uResult","vResult","hResult","u","v","h","MAX_VALUE","is32","bufferType","triangleCount","indices","highest","code","vSort","vSortReverse","uSort","uSortReverse","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","edgeIndices","extensions","extensionId","extensionLength","xy","normals","x","y","z","oldVX","signNotZero","len","size","mask","jsonLength","jsonBuffer","_norm","Vector3","_tri","Triangle","_uvh","_pos","QuantizedMeshLoader","manager","DefaultLoadingManager","Ellipsoid","ellipsoid","solid","skirtLength","smoothSkirtNormals","minLat","maxLat","minLon","maxLon","vertexData","geometry","BufferGeometry","material","MeshStandardMaterial","mesh","Mesh","includeNormals","positions","uvs","indexArr","groupOffset","materialIndex","readUVHeight","readPosition","extNormals","indexOffset","offset","westStrip","constructEdgeStrip","eastStrip","southStrip","northStrip","indexBuffer","BufferAttribute","maskBuffer","map","DataTexture","RGFormat","UnsignedByteType","LinearMipMapLinearFilter","LinearFilter","index","heightOffset","height","MathUtils","lon","lat","topUvs","topPos","botUvs","botPos","sideIndices","triCount","t0","t1","b0","b1","total","botOffset","i3","nx","ny","nz","_cart","_vec","_pos0","_pos1","_pos2","_pos3","_temp","_temp2","_uv0","Vector2","_uv1","_uv2","QuantizedMeshClipper","GeometryClipper","sourceMesh","left","bottom","getUvSplitOperation","botResult","skirtResult","capGroup","capResult","key","normal","nextIndex","vertToNewIndexMap","pushVertex","pos","uv","norm","hash","hashVertex","capIndex","capUv","capPosition","capNormal","capTriangles","triOffset","e","ne","i0","i1","u0","u1","capLength","attributes","xUvOffset","yUvOffset","resultMesh","start","info","position","vertexIsClipped","posArr","uvArr","point","axis","i2","barycoord","TILE_X","TILE_Y","TILE_LEVEL","TILE_AVAILABLE","INITIAL_HEIGHT_RANGE","isTileAvailable","available","level","availableSet","startX","startY","endX","endY","getMaxLevel","layer","maxzoom","getMetadataAvailability","metadataAvailability","getTileHasMetadata","maxLevel","getContentUrl","version","QuantizedMeshPlugin","TilingScheme","ProjectionScheme","plugin","layerProjection","attribution","tiling","projection","tileCountX","tileCountY","children","child","tileset","baseUrl","extension","searchParams","clipper","west","south","east","north","loader","minHeight","maxHeight","metadata","isAvailable","region","midLat","geometricError","hasChildren","cx","cy","CesiumIonAuthPlugin","assetId","CesiumIonAuth","error","TMSTilesPlugin","att"],"mappings":"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"}