{"version":3,"file":"googleMapsExample-BBE91gw6.js","sources":["../../../src/three/plugins/batched/ModelViewBatchedMesh.js","../../../src/three/plugins/batched/ExpandingBatchedMesh.js","../../../src/three/plugins/batched/utilities.js","../../../src/three/plugins/batched/BatchedTilesPlugin.js","../../googleMapsExample.js"],"sourcesContent":["import { BatchedMesh, Matrix4, Vector3, Source } from 'three';\n\nconst matrix = new Matrix4();\nconst vec1 = new Vector3();\nconst vec2 = new Vector3();\nexport class ModelViewBatchedMesh extends BatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.resetDistance = 1e4;\n\t\tthis._matricesTextureHandle = null;\n\t\tthis._lastCameraPos = new Matrix4();\n\t\tthis._forceUpdate = true;\n\n\t\tthis._matrices = [];\n\n\t}\n\n\tsetMatrixAt( instanceId, matrix ) {\n\n\t\tsuper.setMatrixAt( instanceId, matrix );\n\t\tthis._forceUpdate = true;\n\n\t\t// save the matrices in their original float64 format to avoid\n\t\t// precision errors when multiplying later\n\t\tconst matrices = this._matrices;\n\t\twhile ( matrices.length <= instanceId ) {\n\n\t\t\tmatrices.push( new Matrix4() );\n\n\t\t}\n\n\t\tmatrices[ instanceId ].copy( matrix );\n\n\t}\n\n\tsetInstanceCount( ...args ) {\n\n\t\tsuper.setInstanceCount( ...args );\n\n\t\tconst matrices = this._matrices;\n\t\twhile ( matrices.length > this.instanceCount ) {\n\n\t\t\tmatrices.pop();\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer, scene, camera, geometry, material, group ) {\n\n\t\t// ensure matrices are complete and up to date\n\t\tsuper.onBeforeRender( renderer, scene, camera, geometry, material, group );\n\n\t\t// retrieve camera before and after camera positions\n\t\tvec1.setFromMatrixPosition( camera.matrixWorld );\n\t\tvec2.setFromMatrixPosition( this._lastCameraPos );\n\n\t\t// initialize the model-view matrix texture if needed\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tlet modelViewMatricesTexture = this._modelViewMatricesTexture;\n\t\tif (\n\t\t\t! modelViewMatricesTexture ||\n\t\t\tmodelViewMatricesTexture.image.width !== matricesTexture.image.width ||\n\t\t\tmodelViewMatricesTexture.image.height !== matricesTexture.image.height\n\t\t) {\n\n\t\t\tif ( modelViewMatricesTexture ) {\n\n\t\t\t\tmodelViewMatricesTexture.dispose();\n\n\t\t\t}\n\n\t\t\tmodelViewMatricesTexture = matricesTexture.clone();\n\t\t\tmodelViewMatricesTexture.source = new Source( {\n\t\t\t\t...modelViewMatricesTexture.image,\n\t\t\t\tdata: modelViewMatricesTexture.image.data.slice(),\n\t\t\t} );\n\n\t\t\tthis._modelViewMatricesTexture = modelViewMatricesTexture;\n\n\t\t}\n\n\t\t// check if we need to update the model view matrices\n\t\tif ( this._forceUpdate || vec1.distanceTo( vec2 ) > this.resetDistance ) {\n\n\t\t\t// transform each objects matrix into local camera frame to avoid precision issues\n\t\t\tconst matrices = this._matrices;\n\t\t\tconst modelViewArray = modelViewMatricesTexture.image.data;\n\t\t\tfor ( let i = 0; i < this.maxInstanceCount; i ++ ) {\n\n\t\t\t\tconst instanceMatrix = matrices[ i ];\n\t\t\t\tif ( instanceMatrix ) {\n\n\t\t\t\t\tmatrix.copy( instanceMatrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t}\n\n\t\t\t\tmatrix\n\t\t\t\t\t.premultiply( this.matrixWorld )\n\t\t\t\t\t.premultiply( camera.matrixWorldInverse )\n\t\t\t\t\t.toArray( modelViewArray, i * 16 );\n\n\t\t\t}\n\n\t\t\tmodelViewMatricesTexture.needsUpdate = true;\n\t\t\tthis._lastCameraPos.copy( camera.matrixWorld );\n\t\t\tthis._forceUpdate = false;\n\n\t\t}\n\n\t\t// save handles, and transform the matrix world into the camera frame used to position the mesh instances\n\t\t// to offset the position shift.\n\t\tthis._matricesTextureHandle = this._matricesTexture;\n\t\tthis._matricesTexture = this._modelViewMatricesTexture;\n\t\tthis.matrixWorld.copy( this._lastCameraPos );\n\n\t}\n\n\tonAfterRender() {\n\n\t\tthis.updateMatrixWorld();\n\t\tthis._matricesTexture = this._matricesTextureHandle;\n\t\tthis._matricesTextureHandle = null;\n\n\t}\n\n\tonAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {\n\n\t\tthis.onAfterRender( renderer, null, shadowCamera, geometry, depthMaterial );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tif ( this._modelViewMatricesTexture ) {\n\n\t\t\tthis._modelViewMatricesTexture.dispose();\n\n\t\t}\n\n\t}\n\n}\n","import { Mesh, Box3, Sphere } from 'three';\nimport { ModelViewBatchedMesh } from './ModelViewBatchedMesh.js';\n\nconst _raycastMesh = new Mesh();\nconst _batchIntersects = [];\n\n// Implementation of BatchedMesh that automatically expands\nexport class ExpandingBatchedMesh extends ModelViewBatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.expandPercent = 0.25;\n\t\tthis.maxInstanceExpansionSize = Infinity;\n\n\t\t// set of available geometry ids that are no longer being used\n\t\tthis._freeGeometryIds = [];\n\n\t}\n\n\t// Finds a free id that can fit the geometry with the requested ranges. Returns -1 if it could not be found.\n\tfindFreeId( geometry, reservedVertexRange, reservedIndexRange ) {\n\n\t\tconst needsIndex = Boolean( this.geometry.index );\n\t\tconst neededIndexCount = Math.max( needsIndex ? geometry.index.count : - 1, reservedIndexRange );\n\t\tconst neededVertexCount = Math.max( geometry.attributes.position.count, reservedVertexRange );\n\n\t\tlet bestIndex = - 1;\n\t\tlet bestScore = Infinity;\n\t\tconst freeGeometryIds = this._freeGeometryIds;\n\t\tfreeGeometryIds.forEach( ( id, i ) => {\n\n\t\t\t// if indices are not needed then they default to - 1\n\t\t\tconst geometryInfo = this.getGeometryRangeAt( id );\n\t\t\tconst { reservedIndexCount, reservedVertexCount } = geometryInfo;\n\t\t\tif ( reservedIndexCount >= neededIndexCount && reservedVertexCount >= neededVertexCount ) {\n\n\t\t\t\t// generate score that is a combination of how much unused space a geometry would have if used and pick the\n\t\t\t\t// one with the least amount of unused space.\n\t\t\t\tconst score = ( neededIndexCount - reservedIndexCount ) + ( neededVertexCount - reservedVertexCount );\n\t\t\t\tif ( score < bestScore ) {\n\n\t\t\t\t\tbestIndex = i;\n\t\t\t\t\tbestScore = score;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( bestIndex !== - 1 ) {\n\n\t\t\t// remove the id from the array\n\t\t\tconst id = freeGeometryIds[ bestIndex ];\n\t\t\tfreeGeometryIds.splice( bestIndex, 1 );\n\n\t\t\treturn id;\n\n\t\t} else {\n\n\t\t\treturn - 1;\n\n\t\t}\n\n\t}\n\n\t// Overrides addGeometry to find an option geometry slot, expand, or optimized if needed\n\taddGeometry( geometry, reservedVertexRange, reservedIndexRange ) {\n\n\t\t// expand the reserved range to what geometry needs since add geometry will throw an error otherwise\n\t\tconst needsIndex = Boolean( this.geometry.index );\n\t\treservedIndexRange = Math.max( needsIndex ? geometry.index.count : - 1, reservedIndexRange );\n\t\treservedVertexRange = Math.max( geometry.attributes.position.count, reservedVertexRange );\n\n\t\tconst { expandPercent, _freeGeometryIds } = this;\n\t\tlet resultId = this.findFreeId( geometry, reservedVertexRange, reservedIndexRange );\n\t\tif ( resultId !== - 1 ) {\n\n\t\t\t// insert the geometry in the found empty space\n\t\t\tthis.setGeometryAt( resultId, geometry );\n\n\t\t} else {\n\n\t\t\tconst needsMoreSpace = () => {\n\n\t\t\t\tconst vertexNeedsSpace = this.unusedVertexCount < reservedVertexRange;\n\t\t\t\tconst indexNeedsSpace = this.unusedIndexCount < reservedIndexRange;\n\t\t\t\treturn vertexNeedsSpace || indexNeedsSpace;\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\treservedVertexRange = Math.max( reservedVertexRange, position.count );\n\t\t\treservedIndexRange = Math.max( reservedIndexRange, index ? index.count : 0 );\n\n\t\t\tif ( needsMoreSpace() ) {\n\n\t\t\t\t// shift all the unused geometries to try to make space\n\t\t\t\t_freeGeometryIds.forEach( id => this.deleteGeometry( id ) );\n\t\t\t\t_freeGeometryIds.length = 0;\n\n\t\t\t\tthis.optimize();\n\n\t\t\t\tif ( needsMoreSpace() ) {\n\n\t\t\t\t\t// lastly try to expand the batched mesh size so the new geometry fits\n\n\t\t\t\t\tconst batchedIndex = this.geometry.index;\n\t\t\t\t\tconst batchedPosition = this.geometry.attributes.position;\n\n\t\t\t\t\t// compute the new geometry size to expand to accounting for the case where the geometry is not initialized\n\t\t\t\t\tlet newIndexCount, newVertexCount;\n\t\t\t\t\tif ( batchedIndex ) {\n\n\t\t\t\t\t\tconst addIndexCount = Math.ceil( expandPercent * batchedIndex.count );\n\t\t\t\t\t\tnewIndexCount = Math.max( addIndexCount, reservedIndexRange, index.count ) + batchedIndex.count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndexCount = Math.max( this.unusedIndexCount, reservedIndexRange );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( batchedPosition ) {\n\n\t\t\t\t\t\tconst addVertexCount = Math.ceil( expandPercent * batchedPosition.count );\n\t\t\t\t\t\tnewVertexCount = Math.max( addVertexCount, reservedVertexRange, position.count ) + batchedPosition.count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewVertexCount = Math.max( this.unusedVertexCount, reservedVertexRange );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.setGeometrySize( newVertexCount, newIndexCount );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresultId = super.addGeometry( geometry, reservedVertexRange, reservedIndexRange );\n\n\t\t}\n\n\t\treturn resultId;\n\n\t}\n\n\t// add an instance and automatically expand the number of instances if necessary\n\taddInstance( geometryId ) {\n\n\t\tif ( this.maxInstanceCount === this.instanceCount ) {\n\n\t\t\tconst newCount = Math.ceil( this.maxInstanceCount * ( 1 + this.expandPercent ) );\n\t\t\tthis.setInstanceCount( Math.min( newCount, this.maxInstanceExpansionSize ) );\n\n\t\t}\n\n\t\treturn super.addInstance( geometryId );\n\n\t}\n\n\t// delete an instance, keeping note that the geometry id is now unused\n\tdeleteInstance( instanceId ) {\n\n\t\tconst geometryId = this.getGeometryIdAt( instanceId );\n\t\tif ( geometryId !== - 1 ) {\n\n\t\t\tthis._freeGeometryIds.push( geometryId );\n\n\t\t}\n\n\t\treturn super.deleteInstance( instanceId );\n\n\t}\n\n\t// add a function for raycasting per tile\n\traycastInstance( instanceId, raycaster, intersects ) {\n\n\t\tconst batchGeometry = this.geometry;\n\t\tconst geometryId = this.getGeometryIdAt( instanceId );\n\n\t\t// initialize the mesh\n\t\t_raycastMesh.material = this.material;\n\t\t_raycastMesh.geometry.index = batchGeometry.index;\n\t\t_raycastMesh.geometry.attributes = batchGeometry.attributes;\n\n\t\t// initialize the geometry\n\t\tconst drawRange = this.getGeometryRangeAt( geometryId );\n\t\t_raycastMesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\t\tif ( _raycastMesh.geometry.boundingBox === null ) {\n\n\t\t\t_raycastMesh.geometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( _raycastMesh.geometry.boundingSphere === null ) {\n\n\t\t\t_raycastMesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\t// get the intersects\n\t\tthis.getMatrixAt( instanceId, _raycastMesh.matrixWorld ).premultiply( this.matrixWorld );\n\t\tthis.getBoundingBoxAt( geometryId, _raycastMesh.geometry.boundingBox );\n\t\tthis.getBoundingSphereAt( geometryId, _raycastMesh.geometry.boundingSphere );\n\t\t_raycastMesh.raycast( raycaster, _batchIntersects );\n\n\t\t// add batch id to the intersects\n\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\tintersect.object = this;\n\t\t\tintersect.batchId = instanceId;\n\t\t\tintersects.push( intersect );\n\n\t\t}\n\n\t\t_batchIntersects.length = 0;\n\n\t}\n\n}\n","// Returns whether the passed color is white or not\nexport function isColorWhite( color ) {\n\n\treturn color.r === 1 && color.g === 1 && color.b === 1;\n\n}\n\n// Adjusts the given material to take an ArrayTexture for a map\nexport function convertMapToArrayTexture( material ) {\n\n\tmaterial.needsUpdate = true;\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tshader.vertexShader = shader.vertexShader\n\t\t\t.replace(\n\t\t\t\t'#include <common>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#include <common>\n\t\t\t\tvarying float texture_index;\n\t\t\t\t`,\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\t'#include <uv_vertex>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#include <uv_vertex>\n\t\t\t\ttexture_index = getIndirectIndex( gl_DrawID );\n\t\t\t\t`,\n\t\t\t);\n\n\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t.replace(\n\t\t\t\t'#include <map_pars_fragment>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#ifdef USE_MAP\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tuniform sampler2DArray map;\n\t\t\t\tvarying float texture_index;\n\t\t\t\t#endif\n\t\t\t\t`,\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\t'#include <map_fragment>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#ifdef USE_MAP\n\t\t\t\t\tdiffuseColor *= texture( map, vec3( vMapUv, texture_index ) );\n\t\t\t\t#endif\n\t\t\t\t`\n\t\t\t);\n\n\t};\n\n}\n","import { WebGLArrayRenderTarget, MeshBasicMaterial, DataTexture, REVISION } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { ExpandingBatchedMesh } from './ExpandingBatchedMesh.js';\nimport { convertMapToArrayTexture, isColorWhite } from './utilities.js';\n\nconst _textureRenderQuad = new FullScreenQuad( new MeshBasicMaterial() );\nconst _whiteTex = new DataTexture( new Uint8Array( [ 255, 255, 255, 255 ] ), 1, 1 );\n_whiteTex.needsUpdate = true;\n\nexport class BatchedTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( parseInt( REVISION ) < 170 ) {\n\n\t\t\tthrow new Error( 'BatchedTilesPlugin: Three.js revision 170 or higher required.' );\n\n\t\t}\n\n\t\toptions = {\n\t\t\tinstanceCount: 500,\n\t\t\tvertexCount: 750,\n\t\t\tindexCount: 2000,\n\t\t\texpandPercent: 0.25,\n\t\t\tmaxInstanceCount: Infinity,\n\t\t\tdiscardOriginalContent: true,\n\t\t\ttextureSize: null,\n\n\t\t\tmaterial: null,\n\t\t\trenderer: null,\n\t\t\t...options\n\t\t};\n\n\t\tthis.name = 'BATCHED_TILES_PLUGIN';\n\t\tthis.priority = - 1;\n\n\t\t// limit the amount of instances to the size of a 3d texture to avoid over flowing the\n\t\tconst gl = options.renderer.getContext();\n\n\t\t// save options\n\t\tthis.instanceCount = options.instanceCount;\n\t\tthis.vertexCount = options.vertexCount;\n\t\tthis.indexCount = options.indexCount;\n\t\tthis.material = options.material ? options.material.clone() : null;\n\t\tthis.expandPercent = options.expandPercent;\n\t\tthis.maxInstanceCount = Math.min( options.maxInstanceCount, gl.getParameter( gl.MAX_3D_TEXTURE_SIZE ) );\n\t\tthis.renderer = options.renderer;\n\t\tthis.discardOriginalContent = options.discardOriginalContent;\n\t\tthis.textureSize = options.textureSize;\n\n\t\t// local variables\n\t\tthis.batchedMesh = null;\n\t\tthis.arrayTarget = null;\n\t\tthis.tiles = null;\n\t\tthis._onLoadModel = null;\n\t\tthis._onDisposeModel = null;\n\t\tthis._onVisibilityChange = null;\n\t\tthis._tileToInstanceId = new Map();\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis._onDisposeModel = ( { scene, tile } ) => {\n\n\t\t\tthis.removeSceneFromBatchedMesh( scene, tile );\n\n\t\t};\n\n\t\t// register events\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModel );\n\t\tthis.tiles = tiles;\n\n\t}\n\n\t// init the batched mesh if it's not ready\n\tinitBatchedMesh( target ) {\n\n\t\tif ( this.batchedMesh !== null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// init the batched mesh\n\t\tconst { instanceCount, vertexCount, indexCount, tiles, renderer, textureSize } = this;\n\t\tconst material = this.material ? this.material : new target.material.constructor();\n\t\tconst batchedMesh = new ExpandingBatchedMesh( instanceCount, instanceCount * vertexCount, instanceCount * indexCount, material );\n\t\tbatchedMesh.name = 'BatchTilesPlugin';\n\t\tbatchedMesh.frustumCulled = false;\n\t\ttiles.group.add( batchedMesh );\n\t\tbatchedMesh.updateMatrixWorld();\n\n\t\t// init the array texture render target\n\t\tconst map = target.material.map;\n\t\tconst textureOptions = {\n\t\t\tcolorSpace: map.colorSpace,\n\t\t\twrapS: map.wrapS,\n\t\t\twrapT: map.wrapT,\n\t\t\twrapR: map.wrapS,\n\t\t\t// TODO: Generating mipmaps for the volume every time a new texture is added is extremely slow\n\t\t\t// generateMipmaps: map.generateMipmaps,\n\t\t\t// minFilter: map.minFilter,\n\t\t\tmagFilter: map.magFilter,\n\t\t};\n\n\t\tconst arrayTarget = new WebGLArrayRenderTarget( textureSize || map.image.width, textureSize || map.image.height, instanceCount );\n\t\tObject.assign( arrayTarget.texture, textureOptions );\n\t\trenderer.initRenderTarget( arrayTarget );\n\n\t\t// init the material\n\t\tmaterial.map = arrayTarget.texture;\n\t\tconvertMapToArrayTexture( material );\n\n\t\tthis.arrayTarget = arrayTarget;\n\t\tthis.batchedMesh = batchedMesh;\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.cached.scene;\n\t\tif ( visible ) {\n\n\t\t\t// Add tile set to the batched mesh if it hasn't been added already\n\t\t\tthis.addSceneToBatchedMesh( scene, tile );\n\n\t\t}\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\t\tthis.batchedMesh.setVisibleAt( instanceId, visible );\n\n\t\t\t} );\n\n\t\t\t// TODO: this should be handled by the base tiles renderer\n\t\t\tconst tiles = this.tiles;\n\t\t\tif ( visible ) {\n\n\t\t\t\ttiles.visibleTiles.add( tile );\n\n\t\t\t} else {\n\n\t\t\t\ttiles.visibleTiles.delete( tile );\n\n\t\t\t}\n\n\t\t\t// dispatch the event that is blocked otherwise\n\t\t\ttiles.dispatchEvent( {\n\t\t\t\ttype: 'tile-visibility-change',\n\t\t\t\tscene,\n\t\t\t\ttile,\n\t\t\t\tvisible,\n\t\t\t} );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tunloadTileFromGPU( scene, tile ) {\n\n\t\tif ( ! this.discardOriginalContent && this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tthis.removeSceneFromBatchedMesh( scene, tile );\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// render the given into the given layer\n\tassignTextureToLayer( texture, layer ) {\n\n\t\tthis.expandArrayTargetIfNeeded();\n\n\t\tconst { renderer } = this;\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t// render the layer\n\t\trenderer.setRenderTarget( this.arrayTarget, layer );\n\t\t_textureRenderQuad.material.map = texture;\n\t\t_textureRenderQuad.render( renderer );\n\n\t\t// TODO: perform a copy if the texture is already the appropriate size\n\n\t\t// reset state\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\t_textureRenderQuad.material.map = null;\n\t\ttexture.dispose();\n\n\t}\n\n\t// check if the array texture target needs to be expanded\n\texpandArrayTargetIfNeeded() {\n\n\t\tconst { batchedMesh, arrayTarget, renderer } = this;\n\t\tconst targetDepth = Math.min( batchedMesh.maxInstanceCount, this.maxInstanceCount );\n\t\tif ( targetDepth > arrayTarget.depth ) {\n\n\t\t\t// create a new array texture target\n\t\t\tconst textureOptions = {\n\t\t\t\tcolorSpace: arrayTarget.texture.colorSpace,\n\t\t\t\twrapS: arrayTarget.texture.wrapS,\n\t\t\t\twrapT: arrayTarget.texture.wrapT,\n\t\t\t\tgenerateMipmaps: arrayTarget.texture.generateMipmaps,\n\t\t\t\tminFilter: arrayTarget.texture.minFilter,\n\t\t\t\tmagFilter: arrayTarget.texture.magFilter,\n\t\t\t};\n\n\t\t\tconst newArrayTarget = new WebGLArrayRenderTarget( arrayTarget.width, arrayTarget.height, targetDepth );\n\t\t\tObject.assign( newArrayTarget.texture, textureOptions );\n\n\t\t\t// copy the contents\n\t\t\trenderer.initRenderTarget( newArrayTarget );\n\t\t\trenderer.copyTextureToTexture( arrayTarget.texture, newArrayTarget.texture );\n\n\t\t\t// replace the old array target\n\t\t\tarrayTarget.dispose();\n\t\t\tbatchedMesh.material.map = newArrayTarget.texture;\n\t\t\tthis.arrayTarget = newArrayTarget;\n\n\t\t}\n\n\t}\n\n\tremoveSceneFromBatchedMesh( scene, tile ) {\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\t\tthis._tileToInstanceId.delete( tile );\n\t\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\t\tthis.batchedMesh.deleteInstance( instanceId );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\taddSceneToBatchedMesh( scene, tile ) {\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// find the meshes in the scene\n\t\tconst meshes = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// don't add the geometry if it doesn't have the right attributes\n\t\tlet hasCorrectAttributes = true;\n\t\tmeshes.forEach( mesh => {\n\n\t\t\tif ( this.batchedMesh && hasCorrectAttributes ) {\n\n\t\t\t\tconst attrs = mesh.geometry.attributes;\n\t\t\t\tconst batchedAttrs = this.batchedMesh.geometry.attributes;\n\t\t\t\tfor ( const key in batchedAttrs ) {\n\n\t\t\t\t\tif ( ! ( key in attrs ) ) {\n\n\t\t\t\t\t\thasCorrectAttributes = false;\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst canAddMeshes = ! this.batchedMesh || this.batchedMesh.instanceCount + meshes.length <= this.maxInstanceCount;\n\t\tif ( hasCorrectAttributes && canAddMeshes ) {\n\n\t\t\tscene.updateMatrixWorld();\n\n\t\t\tconst instanceIds = [];\n\t\t\tmeshes.forEach( mesh => {\n\n\t\t\t\tthis.initBatchedMesh( mesh );\n\n\t\t\t\tconst { geometry, material } = mesh;\n\t\t\t\tconst { batchedMesh, expandPercent } = this;\n\n\t\t\t\t// assign expandPercent in case it has changed\n\t\t\t\tbatchedMesh.expandPercent = expandPercent;\n\n\t\t\t\tconst geometryId = batchedMesh.addGeometry( geometry, this.vertexCount, this.indexCount );\n\t\t\t\tconst instanceId = batchedMesh.addInstance( geometryId );\n\t\t\t\tinstanceIds.push( instanceId );\n\t\t\t\tbatchedMesh.setMatrixAt( instanceId, mesh.matrixWorld );\n\t\t\t\tbatchedMesh.setVisibleAt( instanceId, false );\n\t\t\t\tif ( ! isColorWhite( material.color ) ) {\n\n\t\t\t\t\tmaterial.color.setHSL( Math.random(), 0.5, 0.5 );\n\t\t\t\t\tbatchedMesh.setColorAt( instanceId, material.color );\n\n\t\t\t\t}\n\n\t\t\t\t// render the material\n\t\t\t\tconst texture = material.map;\n\t\t\t\tif ( texture ) {\n\n\t\t\t\t\tthis.assignTextureToLayer( texture, instanceId );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.assignTextureToLayer( _whiteTex, instanceId );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tthis._tileToInstanceId.set( tile, instanceIds );\n\n\t\t\t// discard all data if the option is set\n\t\t\t// TODO: this would be best done in a more general way\n\t\t\tif ( this.discardOriginalContent ) {\n\n\t\t\t\ttile.cached.textures.forEach( tex => {\n\n\t\t\t\t\tif ( tex.image instanceof ImageBitmap ) {\n\n\t\t\t\t\t\ttex.image.close();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\ttile.cached.scene = null;\n\t\t\t\ttile.cached.materials = [];\n\t\t\t\ttile.cached.geometries = [];\n\t\t\t\ttile.cached.textures = [];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Override raycasting per tile to defer to the batched mesh\n\traycastTile( tile, scene, raycaster, intersects ) {\n\n\t\tif ( ! this._tileToInstanceId.has( tile ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\tthis.batchedMesh.raycastInstance( instanceId, raycaster, intersects );\n\n\t\t} );\n\n\t\treturn true;\n\n\t}\n\n\tdispose() {\n\n\t\tconst { arrayTarget, tiles, batchedMesh } = this;\n\t\tif ( arrayTarget ) {\n\n\t\t\tarrayTarget.dispose();\n\n\t\t}\n\n\t\tif ( batchedMesh ) {\n\n\t\t\tbatchedMesh.material.dispose();\n\t\t\tbatchedMesh.geometry.dispose();\n\t\t\tbatchedMesh.dispose();\n\t\t\tbatchedMesh.removeFromParent();\n\n\t\t}\n\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModel );\n\n\t}\n\n\tgetTileBatchIds( tile ) {\n\n\t\treturn this._tileToInstanceId.get( tile );\n\n\t}\n\n}\n","import {\n\tWGS84_ELLIPSOID,\n\tCAMERA_FRAME,\n\tGeoUtils,\n\tGlobeControls,\n\tCameraTransitionManager,\n\tTilesRenderer,\n} from '3d-tiles-renderer';\nimport {\n\tTilesFadePlugin,\n\tUpdateOnChangePlugin,\n\tTileCompressionPlugin,\n\tUnloadTilesPlugin,\n\tGLTFExtensionsPlugin,\n\tBatchedTilesPlugin,\n\tCesiumIonAuthPlugin,\n} from '3d-tiles-renderer/plugins';\nimport {\n\tScene,\n\tWebGLRenderer,\n\tPerspectiveCamera,\n\tMathUtils,\n\tOrthographicCamera,\n} from 'three';\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport Stats from 'three/examples/jsm/libs/stats.module.js';\nimport { TopoLinesPlugin } from './src/plugins/topolines/TopoLinesPlugin.js';\n\nlet controls, scene, renderer, tiles, transition;\nlet statsContainer, stats;\n\nconst params = {\n\n\torthographic: false,\n\n\tenableCacheDisplay: false,\n\tenableRendererStats: false,\n\tuseBatchedMesh: Boolean( new URLSearchParams( window.location.hash.replace( /^#/, '' ) ).get( 'batched' ) ),\n\tdisplayTopoLines: false,\n\terrorTarget: 20,\n\n\treload: reinstantiateTiles,\n\n};\n\ninit();\nanimate();\n\nfunction reinstantiateTiles() {\n\n\tif ( tiles ) {\n\n\t\tscene.remove( tiles.group );\n\t\ttiles.dispose();\n\t\ttiles = null;\n\n\t}\n\n\ttiles = new TilesRenderer();\n\ttiles.registerPlugin( new CesiumIonAuthPlugin( { apiToken: import.meta.env.VITE_ION_KEY, assetId: '2275207', autoRefreshToken: true } ) );\n\ttiles.registerPlugin( new TileCompressionPlugin() );\n\ttiles.registerPlugin( new UpdateOnChangePlugin() );\n\ttiles.registerPlugin( new UnloadTilesPlugin() );\n\ttiles.registerPlugin( new TilesFadePlugin() );\n\ttiles.registerPlugin( new TopoLinesPlugin( { projection: 'ellipsoid' } ) );\n\ttiles.registerPlugin( new GLTFExtensionsPlugin( {\n\t\t// Note the DRACO compression files need to be supplied via an explicit source.\n\t\t// We use unpkg here but in practice should be provided by the application.\n\t\tdracoLoader: new DRACOLoader().setDecoderPath( 'https://unpkg.com/three@0.153.0/examples/jsm/libs/draco/gltf/' )\n\t} ) );\n\n\n\tif ( params.useBatchedMesh ) {\n\n\t\ttiles.registerPlugin( new BatchedTilesPlugin( {\n\t\t\trenderer,\n\t\t\tdiscardOriginalContent: false,\n\t\t\tinstanceCount: 250,\n\t\t} ) );\n\n\t}\n\n\ttiles.group.rotation.x = - Math.PI / 2;\n\tscene.add( tiles.group );\n\n\ttiles.setResolutionFromRenderer( transition.camera, renderer );\n\ttiles.setCamera( transition.camera );\n\n\tcontrols.setEllipsoid( tiles.ellipsoid, tiles.group );\n\n}\n\nfunction init() {\n\n\t// renderer\n\trenderer = new WebGLRenderer( { antialias: true } );\n\trenderer.setClearColor( 0x151c1f );\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene\n\tscene = new Scene();\n\n\t// camera and transition set up\n\ttransition = new CameraTransitionManager(\n\t\tnew PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 160000000 ),\n\t\tnew OrthographicCamera( - 1, 1, 1, - 1, 1, 160000000 ),\n\t);\n\ttransition.perspectiveCamera.position.set( 4800000, 2570000, 14720000 );\n\ttransition.perspectiveCamera.lookAt( 0, 0, 0 );\n\ttransition.autoSync = false;\n\n\ttransition.addEventListener( 'camera-change', ( { camera, prevCamera } ) => {\n\n\t\ttiles.deleteCamera( prevCamera );\n\t\ttiles.setCamera( camera );\n\t\tcontrols.setCamera( camera );\n\n\t} );\n\n\t// disable adjusting the orthographic camera position for zoom since globe controls will do this\n\ttransition.orthographicPositionalZoom = false;\n\n\t// controls\n\tcontrols = new GlobeControls( scene, transition.camera, renderer.domElement, null );\n\tcontrols.enableDamping = true;\n\n\t// initialize tiles\n\treinstantiateTiles();\n\n\tonWindowResize();\n\twindow.addEventListener( 'resize', onWindowResize, false );\n\twindow.addEventListener( 'hashchange', initFromHash );\n\n\t// GUI\n\tconst gui = new GUI();\n\tgui.width = 300;\n\n\tgui.add( params, 'orthographic' ).onChange( v => {\n\n\t\tcontrols.getPivotPoint( transition.fixedPoint );\n\n\t\t// don't update the cameras if they are already being animated\n\t\tif ( ! transition.animating ) {\n\n\t\t\t// sync the camera positions and then adjust the camera views\n\t\t\ttransition.syncCameras();\n\t\t\tcontrols.adjustCamera( transition.perspectiveCamera );\n\t\t\tcontrols.adjustCamera( transition.orthographicCamera );\n\n\t\t}\n\n\t\ttransition.toggle();\n\n\t} );\n\n\tconst mapsOptions = gui.addFolder( 'Google Photorealistic Tiles' );\n\tmapsOptions.add( params, 'useBatchedMesh' ).listen();\n\tmapsOptions.add( params, 'reload' );\n\n\tconst exampleOptions = gui.addFolder( 'Example Options' );\n\texampleOptions.add( params, 'displayTopoLines' ).listen();\n\texampleOptions.add( params, 'enableCacheDisplay' );\n\texampleOptions.add( params, 'enableRendererStats' );\n\texampleOptions.add( params, 'errorTarget', 5, 100, 1 ).onChange( () => {\n\n\t\ttiles.getPluginByName( 'UPDATE_ON_CHANGE_PLUGIN' ).needsUpdate = true;\n\n\t} );\n\n\tstatsContainer = document.createElement( 'div' );\n\tdocument.getElementById( 'info' ).appendChild( statsContainer );\n\n\t// Stats\n\tstats = new Stats();\n\tstats.showPanel( 0 );\n\tdocument.body.appendChild( stats.dom );\n\n\t// run hash functions\n\tinitFromHash();\n\tsetInterval( updateHash, 100 );\n\n}\n\nfunction onWindowResize() {\n\n\tconst { perspectiveCamera, orthographicCamera } = transition;\n\tconst aspect = window.innerWidth / window.innerHeight;\n\n\tperspectiveCamera.aspect = aspect;\n\tperspectiveCamera.updateProjectionMatrix();\n\n\torthographicCamera.left = - orthographicCamera.top * aspect;\n\torthographicCamera.right = - orthographicCamera.left;\n\torthographicCamera.updateProjectionMatrix();\n\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\n}\n\nfunction updateHash() {\n\n\tif ( ! tiles ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( transition.mode !== 'perspective' && ! transition.animating ) {\n\n\t\tcontrols.getPivotPoint( transition.fixedPoint );\n\t\ttransition.syncCameras();\n\n\t}\n\n\tconst camera = transition.perspectiveCamera;\n\tconst cartographicResult = {};\n\tconst tilesMatInv = tiles.group.matrixWorld.clone().invert();\n\tconst localCameraMat = camera.matrixWorld.clone().premultiply( tilesMatInv );\n\n\t// get the data\n\tWGS84_ELLIPSOID.getCartographicFromObjectFrame( localCameraMat, cartographicResult, CAMERA_FRAME );\n\n\t// convert to DEG\n\tcartographicResult.azimuth *= MathUtils.RAD2DEG;\n\tcartographicResult.elevation *= MathUtils.RAD2DEG;\n\tcartographicResult.roll *= MathUtils.RAD2DEG;\n\tcartographicResult.lat *= MathUtils.RAD2DEG;\n\tcartographicResult.lon *= MathUtils.RAD2DEG;\n\n\t// update hash\n\tconst urlParams = new URLSearchParams();\n\turlParams.set( 'lat', cartographicResult.lat.toFixed( 4 ) );\n\turlParams.set( 'lon', cartographicResult.lon.toFixed( 4 ) );\n\turlParams.set( 'height', cartographicResult.height.toFixed( 2 ) );\n\turlParams.set( 'az', cartographicResult.azimuth.toFixed( 2 ) );\n\turlParams.set( 'el', cartographicResult.elevation.toFixed( 2 ) );\n\turlParams.set( 'roll', cartographicResult.roll.toFixed( 2 ) );\n\n\tif ( params.useBatchedMesh ) {\n\n\t\turlParams.set( 'batched', 1 );\n\n\t}\n\twindow.history.replaceState( undefined, undefined, `#${ urlParams }` );\n\n}\n\nfunction initFromHash() {\n\n\tconst hash = window.location.hash.replace( /^#/, '' );\n\tconst urlParams = new URLSearchParams( hash );\n\tif ( urlParams.has( 'batched' ) ) {\n\n\t\tparams.useBatchedMesh = Boolean( urlParams.get( 'batched' ) );\n\n\t}\n\n\tif ( ! urlParams.has( 'lat' ) && ! urlParams.has( 'lon' ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// update the tiles matrix world so we can use it\n\ttiles.group.updateMatrixWorld();\n\n\t// get the position fields\n\tconst camera = transition.perspectiveCamera;\n\tconst lat = parseFloat( urlParams.get( 'lat' ) );\n\tconst lon = parseFloat( urlParams.get( 'lon' ) );\n\tconst height = parseFloat( urlParams.get( 'height' ) ) || 1000;\n\n\tif ( urlParams.has( 'az' ) && urlParams.has( 'el' ) ) {\n\n\t\t// get the az el fields for rotation if present\n\t\tconst az = parseFloat( urlParams.get( 'az' ) );\n\t\tconst el = parseFloat( urlParams.get( 'el' ) );\n\t\tconst roll = parseFloat( urlParams.get( 'roll' ) ) || 0;\n\n\t\t// extract the east-north-up frame into matrix world\n\t\tWGS84_ELLIPSOID.getObjectFrame(\n\t\t\tlat * MathUtils.DEG2RAD, lon * MathUtils.DEG2RAD, height,\n\t\t\taz * MathUtils.DEG2RAD, el * MathUtils.DEG2RAD, roll * MathUtils.DEG2RAD,\n\t\t\tcamera.matrixWorld, CAMERA_FRAME,\n\t\t);\n\n\t\t// apply the necessary tiles transform\n\t\tcamera.matrixWorld.premultiply( tiles.group.matrixWorld );\n\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\n\t} else {\n\n\t\t// default to looking down if no az el are present\n\t\tWGS84_ELLIPSOID.getCartographicToPosition( lat * MathUtils.DEG2RAD, lon * MathUtils.DEG2RAD, height, camera.position );\n\t\tcamera.position.applyMatrix4( tiles.group.matrixWorld );\n\t\tcamera.lookAt( 0, 0, 0 );\n\n\t}\n\n\tif ( transition.mode !== 'perspective' ) {\n\n\t\tconst currentMode = transition.mode;\n\t\ttransition.mode = 'perspective';\n\t\ttransition.syncCameras();\n\t\ttransition.mode = currentMode;\n\n\t}\n\n}\n\nfunction animate() {\n\n\trequestAnimationFrame( animate );\n\n\tif ( ! tiles ) return;\n\n\tcontrols.enabled = ! transition.animating;\n\tcontrols.update();\n\ttransition.update();\n\n\t// update options\n\tconst camera = transition.camera;\n\ttiles.setResolutionFromRenderer( camera, renderer );\n\ttiles.setCamera( camera );\n\n\tconst plugin = tiles.getPluginByName( 'TOPO_LINES_PLUGIN' );\n\tplugin.topoOpacity = params.displayTopoLines ? 0.5 : 0;\n\tplugin.cartoOpacity = params.displayTopoLines ? 0.5 : 0;\n\n\t// update tiles\n\tcamera.updateMatrixWorld();\n\ttiles.errorTarget = params.errorTarget;\n\ttiles.update();\n\n\trenderer.render( scene, camera );\n\tstats.update();\n\n\tupdateHtml();\n\n}\n\nfunction updateHtml() {\n\n\t// render html text updates\n\tlet str = '';\n\n\tif ( params.enableCacheDisplay ) {\n\n\t\tconst lruCache = tiles.lruCache;\n\t\tconst cacheFullness = lruCache.cachedBytes / lruCache.maxBytesSize;\n\t\tstr += `Downloading: ${ tiles.stats.downloading } Parsing: ${ tiles.stats.parsing } Visible: ${ tiles.visibleTiles.size }<br/>`;\n\t\tstr += `Cache: ${ ( 100 * cacheFullness ).toFixed( 2 ) }% ~${ ( lruCache.cachedBytes / 1000 / 1000 ).toFixed( 2 ) }mb<br/>`;\n\n\t}\n\n\tif ( params.enableRendererStats ) {\n\n\t\tconst memory = renderer.info.memory;\n\t\tconst render = renderer.info.render;\n\t\tconst programCount = renderer.info.programs.length;\n\t\tstr += `Geometries: ${ memory.geometries } Textures: ${ memory.textures } Programs: ${ programCount } Draw Calls: ${ render.calls }`;\n\n\t\tconst batchPlugin = tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' );\n\t\tconst fadePlugin = tiles.getPluginByName( 'FADE_TILES_PLUGIN' );\n\t\tif ( batchPlugin ) {\n\n\t\t\tlet tot = 0;\n\t\t\tbatchPlugin.batchedMesh?._instanceInfo.forEach( info => {\n\n\t\t\t\tif ( info.visible && info.active ) tot ++;\n\n\t\t\t} );\n\n\t\t\tfadePlugin.batchedMesh?._instanceInfo.forEach( info => {\n\n\t\t\t\tif ( info.visible && info.active ) tot ++;\n\n\t\t\t} );\n\n\t\t\tstr += ', Batched: ' + tot;\n\n\t\t}\n\n\t}\n\n\tif ( statsContainer.innerHTML !== str ) {\n\n\t\tstatsContainer.innerHTML = str;\n\n\t}\n\n\tconst mat = tiles.group.matrixWorld.clone().invert();\n\tconst vec = transition.camera.position.clone().applyMatrix4( mat );\n\n\tconst res = {};\n\tWGS84_ELLIPSOID.getPositionToCartographic( vec, res );\n\n\tconst attributions = tiles.getAttributions()[ 0 ]?.value || '';\n\tdocument.getElementById( 'credits' ).innerText = GeoUtils.toLatLonString( res.lat, res.lon ) + '\\n' + attributions;\n\n}\n"],"names":["matrix","Matrix4","vec1","Vector3","vec2","ModelViewBatchedMesh","BatchedMesh","args","instanceId","matrices","renderer","scene","camera","geometry","material","group","matricesTexture","modelViewMatricesTexture","Source","modelViewArray","i","instanceMatrix","object","shadowCamera","depthMaterial","_raycastMesh","Mesh","_batchIntersects","ExpandingBatchedMesh","reservedVertexRange","reservedIndexRange","needsIndex","neededIndexCount","neededVertexCount","bestIndex","bestScore","freeGeometryIds","id","geometryInfo","reservedIndexCount","reservedVertexCount","score","expandPercent","_freeGeometryIds","resultId","needsMoreSpace","vertexNeedsSpace","indexNeedsSpace","index","position","batchedIndex","batchedPosition","newIndexCount","newVertexCount","addIndexCount","addVertexCount","geometryId","newCount","raycaster","intersects","batchGeometry","drawRange","Box3","Sphere","j","l","intersect","isColorWhite","color","convertMapToArrayTexture","shader","_textureRenderQuad","FullScreenQuad","MeshBasicMaterial","_whiteTex","DataTexture","BatchedTilesPlugin","options","REVISION","gl","tiles","tile","target","instanceCount","vertexCount","indexCount","textureSize","batchedMesh","map","textureOptions","arrayTarget","WebGLArrayRenderTarget","visible","texture","layer","currentRenderTarget","targetDepth","newArrayTarget","instanceIds","meshes","c","hasCorrectAttributes","mesh","attrs","batchedAttrs","key","canAddMeshes","tex","controls","transition","statsContainer","stats","params","reinstantiateTiles","init","animate","TilesRenderer","CesiumIonAuthPlugin","TileCompressionPlugin","UpdateOnChangePlugin","UnloadTilesPlugin","TilesFadePlugin","TopoLinesPlugin","GLTFExtensionsPlugin","DRACOLoader","WebGLRenderer","Scene","CameraTransitionManager","PerspectiveCamera","OrthographicCamera","prevCamera","GlobeControls","onWindowResize","initFromHash","gui","GUI","v","mapsOptions","exampleOptions","Stats","updateHash","perspectiveCamera","orthographicCamera","aspect","cartographicResult","tilesMatInv","localCameraMat","WGS84_ELLIPSOID","CAMERA_FRAME","MathUtils","urlParams","hash","lat","lon","height","az","el","roll","currentMode","plugin","updateHtml","str","lruCache","cacheFullness","memory","render","programCount","batchPlugin","fadePlugin","tot","_a","info","_b","mat","vec","res","attributions","_c","GeoUtils.toLatLonString"],"mappings":"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"}