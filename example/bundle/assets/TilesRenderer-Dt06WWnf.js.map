{"version":3,"file":"TilesRenderer-Dt06WWnf.js","sources":["../../../src/core/renderer/utilities/urlExtension.js","../../../src/core/renderer/utilities/LRUCache.js","../../../src/core/renderer/utilities/PriorityQueue.js","../../../src/core/renderer/tiles/traverseFunctions.js","../../../src/core/renderer/utilities/throttle.js","../../../src/core/renderer/tiles/TilesRendererBase.js","../../../src/three/renderer/tiles/TilesGroup.js","../../../src/three/renderer/tiles/raycastTraverse.js","../../../src/three/renderer/math/OBB.js","../../../src/three/renderer/math/TileBoundingVolume.js","../../../src/three/renderer/math/ExtendedFrustum.js","../../../src/three/renderer/tiles/utilities.js","../../../src/three/renderer/tiles/TilesRenderer.js"],"sourcesContent":["/**\n * Returns the file extension of the path component of a URL\n * @param {string} url\n * @returns {string} null if no extension found\n */\nexport function getUrlExtension( url ) {\n\n\tif ( ! url ) {\n\n\t\treturn null;\n\n\t}\n\n\tconst filename = url\n\t\t.replace( /[a-z]+:\\/\\/[^/]+/i, '' ) \t// remove origin\n\t\t.replace( /\\?.*$/i, '' ) \t\t\t\t// remove query\n\t\t.replace( /.*\\//g, '' ); \t\t\t\t// remove path\n\n\tconst lastPeriod = filename.lastIndexOf( '.' );\n\tif ( lastPeriod === - 1 ) {\n\n\t\treturn null;\n\n\t}\n\n\treturn filename.substring( lastPeriod + 1 ) || null;\n\n}\n","const GIGABYTE_BYTES = 2 ** 30;\n\nclass LRUCache {\n\n\tget unloadPriorityCallback() {\n\n\t\treturn this._unloadPriorityCallback;\n\n\t}\n\n\tset unloadPriorityCallback( cb ) {\n\n\t\tif ( cb.length === 1 ) {\n\n\t\t\tconsole.warn( 'LRUCache: \"unloadPriorityCallback\" function has been changed to take two arguments.' );\n\t\t\tthis._unloadPriorityCallback = ( a, b ) => {\n\n\t\t\t\tconst valA = cb( a );\n\t\t\t\tconst valB = cb( b );\n\n\t\t\t\tif ( valA < valB ) return - 1;\n\t\t\t\tif ( valA > valB ) return 1;\n\t\t\t\treturn 0;\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tthis._unloadPriorityCallback = cb;\n\n\t\t}\n\n\t}\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.minSize = 6000;\n\t\tthis.maxSize = 8000;\n\t\tthis.minBytesSize = 0.3 * GIGABYTE_BYTES;\n\t\tthis.maxBytesSize = 0.4 * GIGABYTE_BYTES;\n\t\tthis.unloadPercent = 0.05;\n\t\tthis.autoMarkUnused = true;\n\n\t\t// \"itemSet\" doubles as both the list of the full set of items currently\n\t\t// stored in the cache (keys) as well as a map to the time the item was last\n\t\t// used so it can be sorted appropriately.\n\t\tthis.itemSet = new Map();\n\t\tthis.itemList = [];\n\t\tthis.usedSet = new Set();\n\t\tthis.callbacks = new Map();\n\t\tthis.unloadingHandle = - 1;\n\t\tthis.cachedBytes = 0;\n\t\tthis.bytesMap = new Map();\n\t\tthis.loadedSet = new Set();\n\n\t\tthis._unloadPriorityCallback = null;\n\n\t\tconst itemSet = this.itemSet;\n\t\tthis.defaultPriorityCallback = item => itemSet.get( item );\n\n\t}\n\n\t// Returns whether or not the cache has reached the maximum size\n\tisFull() {\n\n\t\treturn this.itemSet.size >= this.maxSize || this.cachedBytes >= this.maxBytesSize;\n\n\t}\n\n\tgetMemoryUsage( item ) {\n\n\t\treturn this.bytesMap.get( item ) || 0;\n\n\t}\n\n\tsetMemoryUsage( item, bytes ) {\n\n\t\tconst { bytesMap, itemSet } = this;\n\t\tif ( ! itemSet.has( item ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\t\tbytesMap.set( item, bytes );\n\t\tthis.cachedBytes += bytes;\n\n\t}\n\n\tadd( item, removeCb ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( this.isFull() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemList = this.itemList;\n\t\tconst callbacks = this.callbacks;\n\t\titemList.push( item );\n\t\tusedSet.add( item );\n\t\titemSet.set( item, Date.now() );\n\t\tcallbacks.set( item, removeCb );\n\n\t\treturn true;\n\n\t}\n\n\thas( item ) {\n\n\t\treturn this.itemSet.has( item );\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst usedSet = this.usedSet;\n\t\tconst itemSet = this.itemSet;\n\t\tconst itemList = this.itemList;\n\t\tconst bytesMap = this.bytesMap;\n\t\tconst callbacks = this.callbacks;\n\t\tconst loadedSet = this.loadedSet;\n\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\t\t\tbytesMap.delete( item );\n\n\t\t\tcallbacks.get( item )( item );\n\n\t\t\tconst index = itemList.indexOf( item );\n\t\t\titemList.splice( index, 1 );\n\t\t\tusedSet.delete( item );\n\t\t\titemSet.delete( item );\n\t\t\tcallbacks.delete( item );\n\t\t\tloadedSet.delete( item );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Marks whether tiles in the cache have been completely loaded or not. Tiles that have not been completely\n\t// loaded are subject to being disposed early if the cache is full above its max size limits, even if they\n\t// are marked as used.\n\tsetLoaded( item, value ) {\n\n\t\tconst { itemSet, loadedSet } = this;\n\t\tif ( itemSet.has( item ) ) {\n\n\t\t\tif ( value === true ) {\n\n\t\t\t\tloadedSet.add( item );\n\n\t\t\t} else {\n\n\t\t\t\tloadedSet.delete( item );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tmarkUsed( item ) {\n\n\t\tconst itemSet = this.itemSet;\n\t\tconst usedSet = this.usedSet;\n\t\tif ( itemSet.has( item ) && ! usedSet.has( item ) ) {\n\n\t\t\titemSet.set( item, Date.now() );\n\t\t\tusedSet.add( item );\n\n\t\t}\n\n\t}\n\n\tmarkUnused( item ) {\n\n\t\tthis.usedSet.delete( item );\n\n\t}\n\n\tmarkAllUnused() {\n\n\t\tthis.usedSet.clear();\n\n\t}\n\n\t// TODO: this should be renamed because it's not necessarily unloading all unused content\n\t// Maybe call it \"cleanup\" or \"unloadToMinSize\"\n\tunloadUnusedContent() {\n\n\t\tconst {\n\t\t\tunloadPercent,\n\t\t\tminSize,\n\t\t\tmaxSize,\n\t\t\titemList,\n\t\t\titemSet,\n\t\t\tusedSet,\n\t\t\tloadedSet,\n\t\t\tcallbacks,\n\t\t\tbytesMap,\n\t\t\tminBytesSize,\n\t\t\tmaxBytesSize,\n\t\t} = this;\n\n\t\tconst unused = itemList.length - usedSet.size;\n\t\tconst unloaded = itemList.length - loadedSet.size;\n\t\tconst excessNodes = Math.max( Math.min( itemList.length - minSize, unused ), 0 );\n\t\tconst excessBytes = this.cachedBytes - minBytesSize;\n\t\tconst unloadPriorityCallback = this.unloadPriorityCallback || this.defaultPriorityCallback;\n\t\tlet needsRerun = false;\n\n\t\tconst hasNodesToUnload = excessNodes > 0 && unused > 0 || unloaded && itemList.length > maxSize;\n\t\tconst hasBytesToUnload = unused && this.cachedBytes > minBytesSize || unloaded && this.cachedBytes > maxBytesSize;\n\t\tif ( hasBytesToUnload || hasNodesToUnload ) {\n\n\t\t\t// used items should be at the end of the array, \"unloaded\" items in the middle of the array\n\t\t\titemList.sort( ( a, b ) => {\n\n\t\t\t\tconst usedA = usedSet.has( a );\n\t\t\t\tconst usedB = usedSet.has( b );\n\t\t\t\tif ( usedA === usedB ) {\n\n\t\t\t\t\tconst loadedA = loadedSet.has( a );\n\t\t\t\t\tconst loadedB = loadedSet.has( b );\n\t\t\t\t\tif ( loadedA === loadedB ) {\n\n\t\t\t\t\t\t// Use the sort function otherwise\n\t\t\t\t\t\t// higher priority should be further to the left\n\t\t\t\t\t\treturn - unloadPriorityCallback( a, b );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn loadedA ? 1 : - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If one is used and the other is not move the used one towards the end of the array\n\t\t\t\t\treturn usedA ? 1 : - 1;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// address corner cases where the minSize might be zero or smaller than maxSize - minSize,\n\t\t\t// which would result in a very small or no items being unloaded.\n\t\t\tconst maxUnload = Math.max( minSize * unloadPercent, excessNodes * unloadPercent );\n\t\t\tconst nodesToUnload = Math.ceil( Math.min( maxUnload, unused, excessNodes ) );\n\t\t\tconst maxBytesUnload = Math.max( unloadPercent * excessBytes, unloadPercent * minBytesSize );\n\t\t\tconst bytesToUnload = Math.min( maxBytesUnload, excessBytes );\n\n\t\t\tlet removedNodes = 0;\n\t\t\tlet removedBytes = 0;\n\n\t\t\t// evict up to the max node or bytes size, keeping one more item over the max bytes limit\n\t\t\t// so the \"full\" function behaves correctly.\n\t\t\twhile (\n\t\t\t\tthis.cachedBytes - removedBytes > maxBytesSize ||\n\t\t\t\titemList.length - removedNodes > maxSize\n\t\t\t) {\n\n\t\t\t\tconst item = itemList[ removedNodes ];\n\t\t\t\tconst bytes = bytesMap.get( item ) || 0;\n\t\t\t\tif (\n\t\t\t\t\tusedSet.has( item ) && loadedSet.has( item ) ||\n\t\t\t\t\tthis.cachedBytes - removedBytes - bytes < maxBytesSize &&\n\t\t\t\t\titemList.length - removedNodes <= maxSize\n\t\t\t\t) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tremovedBytes += bytes;\n\t\t\t\tremovedNodes ++;\n\n\t\t\t}\n\n\t\t\t// evict up to the min node or bytes size, keeping one more item over the min bytes limit\n\t\t\t// so we're meeting it\n\t\t\twhile (\n\t\t\t\tremovedBytes < bytesToUnload ||\n\t\t\t\tremovedNodes < nodesToUnload\n\t\t\t) {\n\n\t\t\t\tconst item = itemList[ removedNodes ];\n\t\t\t\tconst bytes = bytesMap.get( item ) || 0;\n\t\t\t\tif (\n\t\t\t\t\tusedSet.has( item ) ||\n\t\t\t\t\tthis.cachedBytes - removedBytes - bytes < minBytesSize &&\n\t\t\t\t\tremovedNodes >= nodesToUnload\n\t\t\t\t) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tremovedBytes += bytes;\n\t\t\t\tremovedNodes ++;\n\n\t\t\t}\n\n\t\t\t// remove the nodes\n\t\t\titemList.splice( 0, removedNodes ).forEach( item => {\n\n\t\t\t\tthis.cachedBytes -= bytesMap.get( item ) || 0;\n\n\t\t\t\tcallbacks.get( item )( item );\n\t\t\t\tbytesMap.delete( item );\n\t\t\t\titemSet.delete( item );\n\t\t\t\tcallbacks.delete( item );\n\t\t\t\tloadedSet.delete( item );\n\t\t\t\tusedSet.delete( item );\n\n\t\t\t} );\n\n\t\t\t// if we didn't remove enough nodes or we still have excess bytes and there are nodes to removed\n\t\t\t// then we want to fire another round of unloading\n\t\t\tneedsRerun = removedNodes < excessNodes || removedBytes < excessBytes && removedNodes < unused;\n\t\t\tneedsRerun = needsRerun && removedNodes > 0;\n\n\t\t}\n\n\t\tif ( needsRerun ) {\n\n\t\t\tthis.unloadingHandle = requestAnimationFrame( () => this.scheduleUnload() );\n\n\t\t}\n\n\t}\n\n\tscheduleUnload() {\n\n\t\tcancelAnimationFrame( this.unloadingHandle );\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.scheduled = true;\n\t\t\tqueueMicrotask( () => {\n\n\t\t\t\tthis.scheduled = false;\n\t\t\t\tthis.unloadUnusedContent();\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LRUCache };\n","class PriorityQueue {\n\n\t// returns whether tasks are queued or actively running\n\tget running() {\n\n\t\treturn this.items.length !== 0 || this.currJobs !== 0;\n\n\t}\n\n\tconstructor() {\n\n\t\t// options\n\t\tthis.maxJobs = 6;\n\n\t\tthis.items = [];\n\t\tthis.callbacks = new Map();\n\t\tthis.currJobs = 0;\n\t\tthis.scheduled = false;\n\t\tthis.autoUpdate = true;\n\n\t\tthis.priorityCallback = null;\n\n\t\t// Customizable scheduling callback. Default using requestAnimationFrame()\n\t\tthis.schedulingCallback = func => {\n\n\t\t\trequestAnimationFrame( func );\n\n\t\t};\n\n\t\tthis._runjobs = () => {\n\n\t\t\tthis.scheduled = false;\n\t\t\tthis.tryRunJobs();\n\n\t\t};\n\n\t}\n\n\tsort() {\n\n\t\tconst priorityCallback = this.priorityCallback;\n\t\tconst items = this.items;\n\t\tif ( priorityCallback !== null ) {\n\n\t\t\titems.sort( priorityCallback );\n\n\t\t}\n\n\t}\n\n\thas( item ) {\n\n\t\treturn this.callbacks.has( item );\n\n\t}\n\n\tadd( item, callback ) {\n\n\t\tconst data = {\n\t\t\tcallback,\n\t\t\treject: null,\n\t\t\tresolve: null,\n\t\t\tpromise: null,\n\t\t};\n\n\t\tdata.promise = new Promise( ( resolve, reject ) => {\n\n\t\t\tconst items = this.items;\n\t\t\tconst callbacks = this.callbacks;\n\n\t\t\tdata.resolve = resolve;\n\t\t\tdata.reject = reject;\n\n\t\t\titems.unshift( item );\n\t\t\tcallbacks.set( item, data );\n\n\t\t\tif ( this.autoUpdate ) {\n\n\t\t\t\tthis.scheduleJobRun();\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn data.promise;\n\n\t}\n\n\tremove( item ) {\n\n\t\tconst items = this.items;\n\t\tconst callbacks = this.callbacks;\n\n\t\tconst index = items.indexOf( item );\n\t\tif ( index !== - 1 ) {\n\n\t\t\t// reject the promise to ensure there are no dangling promises - add a\n\t\t\t// catch here to handle the case where the promise was never used anywhere\n\t\t\t// else.\n\t\t\tconst info = callbacks.get( item );\n\t\t\tinfo.promise.catch( () => {} );\n\t\t\tinfo.reject( new Error( 'PriorityQueue: Item removed.' ) );\n\n\t\t\titems.splice( index, 1 );\n\t\t\tcallbacks.delete( item );\n\n\t\t}\n\n\t}\n\n\tremoveByFilter( filter ) {\n\n\t\tconst { items } = this;\n\t\tfor ( let i = 0; i < items.length; i ++ ) {\n\n\t\t\tconst item = items[ i ];\n\t\t\tif ( filter( item ) ) {\n\n\t\t\t\tthis.remove( item );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttryRunJobs() {\n\n\t\tthis.sort();\n\n\t\tconst items = this.items;\n\t\tconst callbacks = this.callbacks;\n\t\tconst maxJobs = this.maxJobs;\n\t\tlet iterated = 0;\n\n\t\tconst completedCallback = () => {\n\n\t\t\tthis.currJobs --;\n\n\t\t\tif ( this.autoUpdate ) {\n\n\t\t\t\tthis.scheduleJobRun();\n\n\t\t\t}\n\n\t\t};\n\n\t\twhile ( maxJobs > this.currJobs && items.length > 0 && iterated < maxJobs ) {\n\n\t\t\tthis.currJobs ++;\n\t\t\titerated ++;\n\t\t\tconst item = items.pop();\n\t\t\tconst { callback, resolve, reject } = callbacks.get( item );\n\t\t\tcallbacks.delete( item );\n\n\t\t\tlet result;\n\t\t\ttry {\n\n\t\t\t\tresult = callback( item );\n\n\t\t\t} catch ( err ) {\n\n\t\t\t\treject( err );\n\t\t\t\tcompletedCallback();\n\n\t\t\t}\n\n\t\t\tif ( result instanceof Promise ) {\n\n\t\t\t\tresult\n\t\t\t\t\t.then( resolve )\n\t\t\t\t\t.catch( reject )\n\t\t\t\t\t.finally( completedCallback );\n\n\t\t\t} else {\n\n\t\t\t\tresolve( result );\n\t\t\t\tcompletedCallback();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tscheduleJobRun() {\n\n\t\tif ( ! this.scheduled ) {\n\n\t\t\tthis.schedulingCallback( this._runjobs );\n\n\t\t\tthis.scheduled = true;\n\n\t\t}\n\n\t}\n\n}\n\nexport { PriorityQueue };\n","import { LOADED, FAILED } from '../constants.js';\n\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n\tdistanceFromCamera: Infinity,\n};\n\n// flag guiding the behavior of the traversal to load the siblings at the root of the\n// tile set or not. The spec seems to indicate \"true\" when using REPLACE define but\n// Cesium's behavior is \"false\".\n// See CesiumGS/3d-tiles#776\nconst LOAD_ROOT_SIBLINGS = true;\n\nfunction isDownloadFinished( value ) {\n\n\treturn value === LOADED || value === FAILED;\n\n}\n\n// Checks whether this tile was last used on the given frame.\nfunction isUsedThisFrame( tile, frameCount ) {\n\n\treturn tile.__lastFrameVisited === frameCount && tile.__used;\n\n}\n\nfunction areChildrenProcessed( tile ) {\n\n\treturn tile.__childrenProcessed === tile.children.length;\n\n}\n\n// Resets the frame frame information for the given tile\nfunction resetFrameState( tile, renderer ) {\n\n\tif ( tile.__lastFrameVisited !== renderer.frameCount ) {\n\n\t\ttile.__lastFrameVisited = renderer.frameCount;\n\t\ttile.__used = false;\n\t\ttile.__inFrustum = false;\n\t\ttile.__isLeaf = false;\n\t\ttile.__visible = false;\n\t\ttile.__active = false;\n\t\ttile.__error = Infinity;\n\t\ttile.__distanceFromCamera = Infinity;\n\t\ttile.__allChildrenLoaded = false;\n\n\t\t// update tile frustum and error state\n\t\trenderer.calculateTileViewError( tile, viewErrorTarget );\n\t\ttile.__inFrustum = viewErrorTarget.inView;\n\t\ttile.__error = viewErrorTarget.error;\n\t\ttile.__distanceFromCamera = viewErrorTarget.distanceFromCamera;\n\n\t}\n\n}\n\n// Recursively mark tiles used down to the next layer, skipping external tile sets\nfunction recursivelyMarkUsed( tile, renderer ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tresetFrameState( tile, renderer );\n\tmarkUsed( tile, renderer );\n\n\t// don't traverse if the children have not been processed, yet but tile set content\n\t// should be considered to be \"replaced\" by the loaded children so await that here.\n\tif ( tile.__hasUnrenderableContent && areChildrenProcessed( tile ) ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trecursivelyMarkUsed( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Recursively traverses to the next tiles with unloaded renderable content to load them\nfunction recursivelyLoadNextRenderableTiles( tile, renderer ) {\n\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\t// exit the recursion if the tile hasn't been used this frame\n\tif ( isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\t// queue this tile to download content\n\t\tif ( tile.__hasContent ) {\n\n\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t}\n\n\t\tif ( areChildrenProcessed( tile ) ) {\n\n\t\t\t// queue any used child tiles\n\t\t\tconst children = tile.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\trecursivelyLoadNextRenderableTiles( children[ i ], renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Mark a tile as being used by current view\nfunction markUsed( tile, renderer ) {\n\n\tif ( tile.__used ) {\n\n\t\treturn;\n\n\t}\n\n\ttile.__used = true;\n\trenderer.markTileUsed( tile );\n\trenderer.stats.used ++;\n\n\tif ( tile.__inFrustum === true ) {\n\n\t\trenderer.stats.inFrustum ++;\n\n\t}\n\n}\n\n// Returns whether the tile can be traversed to the next layer of children by checking the tile metrics\nfunction canTraverse( tile, renderer ) {\n\n\t// If we've met the error requirements then don't load further - if an external tile set is encountered,\n\t// though, then continue to refine.\n\tif ( tile.__error <= renderer.errorTarget && ! tile.__hasUnrenderableContent ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if we've reached the maximum allowed depth.\n\tif ( renderer.maxDepth > 0 && tile.__depth + 1 >= renderer.maxDepth ) {\n\n\t\treturn false;\n\n\t}\n\n\t// Early out if the children haven't been processed, yet\n\tif ( ! areChildrenProcessed( tile ) ) {\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n\n}\n\n// Helper function for traversing a tile set. If `beforeCb` returns `true` then the\n// traversal will end early.\nexport function traverseSet( tile, beforeCb = null, afterCb = null ) {\n\n\tconst stack = [];\n\n\t// A stack-based, depth-first traversal, storing\n\t// triplets (tile, parent, depth) in the stack array.\n\n\tstack.push( tile );\n\tstack.push( null );\n\tstack.push( 0 );\n\n\twhile ( stack.length > 0 ) {\n\n\t\tconst depth = stack.pop();\n\t\tconst parent = stack.pop();\n\t\tconst tile = stack.pop();\n\n\t\tif ( beforeCb && beforeCb( tile, parent, depth ) ) {\n\n\t\t\tif ( afterCb ) {\n\n\t\t\t\tafterCb( tile, parent, depth );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst children = tile.children;\n\n\t\t// Children might be undefined if the tile has not been preprocessed yet\n\t\tif ( children ) {\n\n\t\t\tfor ( let i = children.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tstack.push( children[ i ] );\n\t\t\t\tstack.push( tile );\n\t\t\t\tstack.push( depth + 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( afterCb ) {\n\n\t\t\tafterCb( tile, parent, depth );\n\n\t\t}\n\n\t}\n\n}\n\n// Determine which tiles are used by the renderer given the current camera configuration\nexport function markUsedTiles( tile, renderer ) {\n\n\t// determine frustum set is run first so we can ensure the preprocessing of all the necessary\n\t// child tiles has happened here.\n\trenderer.ensureChildrenArePreprocessed( tile );\n\n\tresetFrameState( tile, renderer );\n\n\tif ( ! tile.__inFrustum ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( ! canTraverse( tile, renderer ) ) {\n\n\t\tmarkUsed( tile, renderer );\n\t\treturn;\n\n\t}\n\n\t// Traverse children and see if any children are in view.\n\tlet anyChildrenUsed = false;\n\tlet anyChildrenInFrustum = false;\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tmarkUsedTiles( c, renderer );\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, renderer.frameCount );\n\t\tanyChildrenInFrustum = anyChildrenInFrustum || c.__inFrustum;\n\n\t}\n\n\t// Disabled for now because this will cause otherwise unused children to be added to the lru cache\n\t// if none of the children are in the frustum then this tile shouldn't be displayed.\n\t// Otherwise this can cause load oscillation as parents are traversed and loaded and then determined\n\t// to not be used because children aren't visible. See #1165.\n\t// if ( tile.refine === 'REPLACE' && ! anyChildrenInFrustum && children.length !== 0 && ! tile.__hasUnrenderableContent ) {\n\n\t// \t// TODO: we're not checking tiles with unrenderable content here since external tile sets might look like they're in the frustum,\n\t// \t// load the children, then the children indicate that it's not visible, causing it to be unloaded. Then it will be loaded again.\n\t// \t// The impact when including external tile set roots in the check is more significant but can't be used unless we keep external tile\n\t// \t// sets around even when they're not needed. See issue #741.\n\n\t// \t// TODO: what if we mark the tile as not in the frustum but we _do_ mark it as used? Then we can stop frustum traversal and at least\n\t// \t// prevent tiles from rendering unless they're needed.\n\t// \tconsole.log('FAILED')\n\t// \ttile.__inFrustum = false;\n\t// \treturn;\n\n\t// }\n\n\t// wait until after the above condition to mark the traversed tile as used or not\n\tmarkUsed( tile, renderer );\n\n\t// If this is a tile that needs children loaded to refine then recursively load child\n\t// tiles until error is met\n\tif ( anyChildrenUsed && tile.refine === 'REPLACE' && ( tile.__depth !== 0 || LOAD_ROOT_SIBLINGS ) ) {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\trecursivelyMarkUsed( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Traverse and mark the tiles that are at the leaf nodes of the \"used\" tree.\nexport function markUsedSetLeaves( tile, renderer ) {\n\n\tconst frameCount = renderer.frameCount;\n\tif ( ! isUsedThisFrame( tile, frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// This tile is a leaf if none of the children had been used.\n\tconst children = tile.children;\n\tlet anyChildrenUsed = false;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst c = children[ i ];\n\t\tanyChildrenUsed = anyChildrenUsed || isUsedThisFrame( c, frameCount );\n\n\t}\n\n\tif ( ! anyChildrenUsed ) {\n\n\t\ttile.__isLeaf = true;\n\n\t} else {\n\n\t\tlet allChildrenLoaded = true;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tmarkUsedSetLeaves( c, renderer );\n\n\t\t\tif ( isUsedThisFrame( c, frameCount ) ) {\n\n\t\t\t\t// consider a child to be loaded if\n\t\t\t\t// - the children's children have been loaded\n\t\t\t\t// - the tile content has loaded\n\t\t\t\t// - the tile is completely empty - ie has no children and no content\n\t\t\t\t// - the child tile set has tried to load but failed\n\t\t\t\tconst childLoaded =\n\t\t\t\t\tc.__allChildrenLoaded ||\n\t\t\t\t\t! c.__hasContent ||\n\t\t\t\t\t( c.__hasRenderableContent && isDownloadFinished( c.__loadingState ) ) ||\n\t\t\t\t\t( c.__hasUnrenderableContent && c.__loadingState === FAILED );\n\t\t\t\tallChildrenLoaded = allChildrenLoaded && childLoaded;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.__allChildrenLoaded = allChildrenLoaded;\n\n\t}\n\n}\n\n// TODO: revisit implementation\n// Skip past tiles we consider unrenderable because they are outside the error threshold.\nexport function markVisibleTiles( tile, renderer ) {\n\n\tconst stats = renderer.stats;\n\tif ( ! isUsedThisFrame( tile, renderer.frameCount ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// Request the tile contents or mark it as visible if we've found a leaf.\n\tif ( tile.__isLeaf ) {\n\n\t\tif ( tile.__loadingState === LOADED ) {\n\n\t\t\tif ( tile.__inFrustum ) {\n\n\t\t\t\ttile.__visible = true;\n\t\t\t\tstats.visible ++;\n\n\t\t\t}\n\t\t\ttile.__active = true;\n\t\t\tstats.active ++;\n\n\t\t} else if ( tile.__hasContent ) {\n\n\t\t\trenderer.queueTileForDownload( tile );\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\tconst children = tile.children;\n\tconst hasContent = tile.__hasContent;\n\tconst loadedContent = isDownloadFinished( tile.__loadingState ) && hasContent;\n\tconst errorRequirement = ( renderer.errorTarget + 1 ) * renderer.errorThreshold;\n\tconst meetsSSE = tile.__error <= errorRequirement;\n\tconst isAdditiveRefine = tile.refine === 'ADD';\n\n\t// TODO: the \"meetsSSE\" field can be removed when the \"errorThreshold\" field has been removed\n\n\t// Don't wait for all children tiles to load if this tile set has empty tiles at the root in order\n\t// to match Cesium's behavior\n\tconst allChildrenLoaded = tile.__allChildrenLoaded || ( tile.__depth === 0 && ! LOAD_ROOT_SIBLINGS );\n\n\t// If we've met the SSE requirements and we can load content then fire a fetch.\n\tif ( hasContent && ( meetsSSE || isAdditiveRefine ) ) {\n\n\t\trenderer.queueTileForDownload( tile );\n\n\t}\n\n\t// By this time only tiles that meet the screen space error requirements will be traversed. Only mark this\n\t// as visible if it's been loaded and not all children have loaded yet or it's an additive tile, meaning it needs\n\t// to display in addition to the children.\n\n\t// Skip the tile entirely if there's no content to load\n\tif ( meetsSSE && loadedContent && ! allChildrenLoaded || loadedContent && isAdditiveRefine ) {\n\n\t\tif ( tile.__inFrustum ) {\n\n\t\t\ttile.__visible = true;\n\t\t\tstats.visible ++;\n\n\t\t}\n\t\ttile.__active = true;\n\t\tstats.active ++;\n\n\t}\n\n\t// If we're additive then don't stop the traversal here because it doesn't matter whether the children load in\n\t// at the same rate.\n\tif ( ! isAdditiveRefine && meetsSSE && ! allChildrenLoaded ) {\n\n\t\t// load the child content if we've found that we've been loaded so we can move down to the next tile\n\t\t// layer when the data has loaded.\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\tif ( isUsedThisFrame( c, renderer.frameCount ) ) {\n\n\t\t\t\trecursivelyLoadNextRenderableTiles( c, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tmarkVisibleTiles( children[ i ], renderer );\n\n\t\t}\n\n\t}\n\n}\n\n// Final traverse to toggle tile visibility.\nexport function toggleTiles( tile, renderer ) {\n\n\tconst isUsed = isUsedThisFrame( tile, renderer.frameCount );\n\tif ( isUsed || tile.__usedLastFrame ) {\n\n\t\tlet setActive = false;\n\t\tlet setVisible = false;\n\t\tif ( isUsed ) {\n\n\t\t\t// enable visibility if active due to shadows\n\t\t\tsetActive = tile.__active;\n\t\t\tif ( renderer.displayActiveTiles ) {\n\n\t\t\t\tsetVisible = tile.__active || tile.__visible;\n\n\t\t\t} else {\n\n\t\t\t\tsetVisible = tile.__visible;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if the tile was used last frame but not this one then there's potential for the tile\n\t\t\t// to not have been visited during the traversal, meaning it hasn't been reset and has\n\t\t\t// stale values. This ensures the values are not stale.\n\t\t\tresetFrameState( tile, renderer );\n\n\t\t}\n\n\t\t// If the active or visible state changed then call the functions.\n\t\tif ( tile.__hasRenderableContent && tile.__loadingState === LOADED ) {\n\n\t\t\tif ( tile.__wasSetActive !== setActive ) {\n\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, setActive ) );\n\n\t\t\t}\n\n\t\t\tif ( tile.__wasSetVisible !== setVisible ) {\n\n\t\t\t\trenderer.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, setVisible ) );\n\n\t\t\t}\n\n\t\t}\n\t\ttile.__wasSetActive = setActive;\n\t\ttile.__wasSetVisible = setVisible;\n\t\ttile.__usedLastFrame = isUsed;\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst c = children[ i ];\n\t\t\ttoggleTiles( c, renderer );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Traverses the ancestry of the tile up to the root tile.\n */\nexport function traverseAncestors( tile, callback = null ) {\n\n\tlet current = tile;\n\n\twhile ( current ) {\n\n\t\tconst depth = current.__depth;\n\t\tconst parent = current.parent;\n\n\t\tif ( callback ) {\n\n\t\t\tcallback( current, parent, depth );\n\n\t\t}\n\n\t\tcurrent = parent;\n\n\t}\n\n\n}\n","// function that rate limits the amount of time a function can be called to once\n// per frame, initially queuing a new call for the next frame.\nexport function throttle( callback ) {\n\n\tlet handle = null;\n\treturn () => {\n\n\t\tif ( handle === null ) {\n\n\t\t\thandle = requestAnimationFrame( () => {\n\n\t\t\t\thandle = null;\n\t\t\t\tcallback();\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n}\n","import { getUrlExtension } from '../utilities/urlExtension.js';\nimport { LRUCache } from '../utilities/LRUCache.js';\nimport { PriorityQueue } from '../utilities/PriorityQueue.js';\nimport { markUsedTiles, toggleTiles, markVisibleTiles, markUsedSetLeaves, traverseSet } from './traverseFunctions.js';\nimport { UNLOADED, LOADING, PARSING, LOADED, FAILED } from '../constants.js';\nimport { throttle } from '../utilities/throttle.js';\n\nconst PLUGIN_REGISTERED = Symbol( 'PLUGIN_REGISTERED' );\n\n// priority queue sort function that takes two tiles to compare. Returning 1 means\n// \"tile a\" is loaded first.\nconst priorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( a.__used !== b.__used ) {\n\n\t\t// load tiles that have been used\n\t\treturn a.__used ? 1 : - 1;\n\n\t} else if ( a.__error !== b.__error ) {\n\n\t\t// load the tile with the higher error\n\t\treturn a.__error > b.__error ? 1 : - 1;\n\n\t} else if ( a.__distanceFromCamera !== b.__distanceFromCamera ) {\n\n\t\t// and finally visible tiles which have equal error (ex: if geometricError === 0)\n\t\t// should prioritize based on distance.\n\t\treturn a.__distanceFromCamera > b.__distanceFromCamera ? - 1 : 1;\n\n\t} else if ( a.__depthFromRenderedParent !== b.__depthFromRenderedParent ) {\n\n\t\treturn a.__depthFromRenderedParent > b.__depthFromRenderedParent ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\n// lru cache unload callback that takes two tiles to compare. Returning 1 means \"tile a\"\n// is unloaded first.\nconst lruPriorityCallback = ( a, b ) => {\n\n\tconst aPriority = a.priority || 0;\n\tconst bPriority = b.priority || 0;\n\n\tif ( aPriority !== bPriority ) {\n\n\t\t// lower priority value sorts first\n\t\treturn aPriority > bPriority ? 1 : - 1;\n\n\t} else if ( a.__lastFrameVisited !== b.__lastFrameVisited ) {\n\n\t\t// dispose of least recent tiles first\n\t\treturn a.__lastFrameVisited > b.__lastFrameVisited ? - 1 : 1;\n\n\t} else if ( a.__depthFromRenderedParent !== b.__depthFromRenderedParent ) {\n\n\t\t// dispose of deeper tiles first so parents are not disposed before children\n\t\treturn a.__depthFromRenderedParent > b.__depthFromRenderedParent ? 1 : - 1;\n\n\t} else if ( a.__loadingState !== b.__loadingState ) {\n\n\t\t// dispose of tiles that are earlier along in the loading process first\n\t\treturn a.__loadingState > b.__loadingState ? - 1 : 1;\n\n\t} else if ( a.__hasUnrenderableContent !== b.__hasUnrenderableContent ) {\n\n\t\t// dispose of external tile sets last\n\t\treturn a.__hasUnrenderableContent ? - 1 : 1;\n\n\t} else if ( a.__error !== b.__error ) {\n\n\t\t// unload the tile with lower error\n\t\treturn a.__error > b.__error ? - 1 : 1;\n\n\t}\n\n\treturn 0;\n\n};\n\nexport class TilesRendererBase {\n\n\tget root() {\n\n\t\tconst tileSet = this.rootTileSet;\n\t\treturn tileSet ? tileSet.root : null;\n\n\t}\n\n\tget loadProgress() {\n\n\t\tconst { stats, isLoading } = this;\n\t\tconst loading = stats.downloading + stats.parsing;\n\t\tconst total = stats.inCacheSinceLoad + ( isLoading ? 1 : 0 );\n\t\treturn total === 0 ? 1.0 : 1.0 - loading / total;\n\n\t}\n\n\tget errorThreshold() {\n\n\t\treturn this._errorThreshold;\n\n\t}\n\n\tset errorThreshold( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"errorThreshold\" option has been deprecated.' );\n\t\tthis._errorThreshold = v;\n\n\t}\n\n\tconstructor( url = null ) {\n\n\t\t// state\n\t\tthis.rootLoadingState = UNLOADED;\n\t\tthis.rootTileSet = null;\n\t\tthis.rootURL = url;\n\t\tthis.fetchOptions = {};\n\t\tthis.plugins = [];\n\t\tthis.queuedTiles = [];\n\t\tthis.cachedSinceLoadComplete = new Set();\n\t\tthis.isLoading = false;\n\n\t\tconst lruCache = new LRUCache();\n\t\tlruCache.unloadPriorityCallback = lruPriorityCallback;\n\n\t\tconst downloadQueue = new PriorityQueue();\n\t\tdownloadQueue.maxJobs = 25;\n\t\tdownloadQueue.priorityCallback = priorityCallback;\n\n\t\tconst parseQueue = new PriorityQueue();\n\t\tparseQueue.maxJobs = 5;\n\t\tparseQueue.priorityCallback = priorityCallback;\n\n\t\tconst processNodeQueue = new PriorityQueue();\n\t\tprocessNodeQueue.maxJobs = 25;\n\n\t\tthis.processedTiles = new WeakSet();\n\t\tthis.visibleTiles = new Set();\n\t\tthis.activeTiles = new Set();\n\t\tthis.usedSet = new Set();\n\t\tthis.lruCache = lruCache;\n\t\tthis.downloadQueue = downloadQueue;\n\t\tthis.parseQueue = parseQueue;\n\t\tthis.processNodeQueue = processNodeQueue;\n\t\tthis.stats = {\n\t\t\tinCacheSinceLoad: 0,\n\t\t\tinCache: 0,\n\t\t\tparsing: 0,\n\t\t\tdownloading: 0,\n\t\t\tfailed: 0,\n\t\t\tinFrustum: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\n\t\t// callbacks\n\t\tthis._dispatchNeedsUpdateEvent = throttle( () => {\n\n\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\n\t\t} );\n\n\t\t// options\n\t\tthis.errorTarget = 16.0;\n\t\tthis._errorThreshold = Infinity;\n\t\tthis.displayActiveTiles = false;\n\t\tthis.maxDepth = Infinity;\n\n\t}\n\n\t// Plugins\n\tregisterPlugin( plugin ) {\n\n\t\tif ( plugin[ PLUGIN_REGISTERED ] === true ) {\n\n\t\t\tthrow new Error( 'TilesRendererBase: A plugin can only be registered to a single tile set' );\n\n\t\t}\n\n\t\t// insert the plugin based on the priority registered on the plugin\n\t\tconst plugins = this.plugins;\n\t\tconst priority = plugin.priority || 0;\n\t\tlet insertionPoint = plugins.length;\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst otherPriority = plugins[ i ].priority || 0;\n\t\t\tif ( otherPriority > priority ) {\n\n\t\t\t\tinsertionPoint = i;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tplugins.splice( insertionPoint, 0, plugin );\n\t\tplugin[ PLUGIN_REGISTERED ] = true;\n\t\tif ( plugin.init ) {\n\n\t\t\tplugin.init( this );\n\n\t\t}\n\n\t}\n\n\tunregisterPlugin( plugin ) {\n\n\t\tconst plugins = this.plugins;\n\t\tif ( typeof plugin === 'string' ) {\n\n\t\t\tplugin = this.getPluginByName( name );\n\n\t\t}\n\n\t\tif ( plugins.includes( plugin ) ) {\n\n\t\t\tconst index = plugins.indexOf( plugin );\n\t\t\tplugins.splice( index, 1 );\n\t\t\tif ( plugin.dispose ) {\n\n\t\t\t\tplugin.dispose();\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetPluginByName( name ) {\n\n\t\treturn this.plugins.find( p => p.name === name ) || null;\n\n\t}\n\n\ttraverse( beforecb, aftercb, ensureFullyProcessed = true ) {\n\n\t\tif ( ! this.root ) return;\n\n\t\ttraverseSet( this.root, ( tile, ...args ) => {\n\n\t\t\tif ( ensureFullyProcessed ) {\n\n\t\t\t\tthis.ensureChildrenArePreprocessed( tile, true );\n\n\t\t\t}\n\n\t\t\treturn beforecb ? beforecb( tile, ...args ) : false;\n\n\t\t}, aftercb );\n\n\t}\n\n\tqueueTileForDownload( tile ) {\n\n\t\tif ( tile.__loadingState !== UNLOADED || this.lruCache.isFull() ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.queuedTiles.push( tile );\n\n\t}\n\n\tmarkTileUsed( tile ) {\n\n\t\t// save the tile in a separate \"used set\" so we can mark it as unused\n\t\t// before the next tile set traversal\n\t\tthis.usedSet.add( tile );\n\t\tthis.lruCache.markUsed( tile );\n\n\t}\n\n\t// Public API\n\tupdate() {\n\n\t\tconst { lruCache, usedSet, stats, root, downloadQueue, parseQueue, processNodeQueue } = this;\n\t\tif ( this.rootLoadingState === UNLOADED ) {\n\n\t\t\tthis.rootLoadingState = LOADING;\n\t\t\tthis.invokeOnePlugin( plugin => plugin.loadRootTileSet && plugin.loadRootTileSet() )\n\t\t\t\t.then( root => {\n\n\t\t\t\t\tlet processedUrl = this.rootURL;\n\t\t\t\t\tif ( processedUrl !== null ) {\n\n\t\t\t\t\t\tthis.invokeAllPlugins( plugin => processedUrl = plugin.preprocessURL ? plugin.preprocessURL( processedUrl, null ) : processedUrl );\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.rootLoadingState = LOADED;\n\t\t\t\t\tthis.rootTileSet = root;\n\t\t\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\t\t\t\t\tthis.dispatchEvent( { type: 'load-content' } );\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-tile-set',\n\t\t\t\t\t\ttileSet: root,\n\t\t\t\t\t\turl: processedUrl,\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.catch( error => {\n\n\t\t\t\t\tthis.rootLoadingState = FAILED;\n\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\tthis.rootTileSet = null;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\t\ttile: null,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\turl: this.rootURL,\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tif ( ! root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tstats.inFrustum = 0;\n\t\tstats.used = 0;\n\t\tstats.active = 0;\n\t\tstats.visible = 0;\n\t\tthis.frameCount ++;\n\n\t\tusedSet.forEach( tile => lruCache.markUnused( tile ) );\n\t\tusedSet.clear();\n\n\t\tmarkUsedTiles( root, this );\n\t\tmarkUsedSetLeaves( root, this );\n\t\tmarkVisibleTiles( root, this );\n\t\ttoggleTiles( root, this );\n\n\t\t// TODO: This will only sort for one tile set. We may want to store this queue on the\n\t\t// LRUCache so multiple tile sets can use it at once\n\t\t// start the downloads of the tiles as needed\n\t\tconst queuedTiles = this.queuedTiles;\n\t\tqueuedTiles.sort( lruCache.unloadPriorityCallback );\n\t\tfor ( let i = 0, l = queuedTiles.length; i < l && ! lruCache.isFull(); i ++ ) {\n\n\t\t\tthis.requestTileContents( queuedTiles[ i ] );\n\n\t\t}\n\n\t\tqueuedTiles.length = 0;\n\n\t\t// start the downloads\n\t\tlruCache.scheduleUnload();\n\n\t\t// if all tasks have finished and we've been marked as actively loading then fire the completion event\n\t\tconst runningTasks = downloadQueue.running || parseQueue.running || processNodeQueue.running;\n\t\tif ( runningTasks === false && this.isLoading === true ) {\n\n\t\t\tthis.cachedSinceLoadComplete.clear();\n\t\t\tstats.inCacheSinceLoad = 0;\n\n\t\t\tthis.dispatchEvent( { type: 'tiles-load-end' } );\n\t\t\tthis.isLoading = false;\n\n\t\t}\n\n\t}\n\n\tresetFailedTiles() {\n\n\t\t// reset the root tile if it's finished but never loaded\n\t\tif ( this.rootLoadingState === FAILED ) {\n\n\t\t\tthis.rootLoadingState = UNLOADED;\n\n\t\t}\n\n\t\tconst stats = this.stats;\n\t\tif ( stats.failed === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.traverse( tile => {\n\n\t\t\tif ( tile.__loadingState === FAILED ) {\n\n\t\t\t\ttile.__loadingState = UNLOADED;\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t\tstats.failed = 0;\n\n\t}\n\n\tdispose() {\n\n\t\t// dispose of all the plugins\n\t\tconst plugins = [ ...this.plugins ];\n\t\tplugins.forEach( plugin => {\n\n\t\t\tthis.unregisterPlugin( plugin );\n\n\t\t} );\n\n\t\tconst lruCache = this.lruCache;\n\n\t\t// Make sure we've collected all children before disposing of the internal tilesets to avoid\n\t\t// dangling children that we inadvertantly skip when deleting the nested tileset.\n\t\tconst toRemove = [];\n\t\tthis.traverse( t => {\n\n\t\t\ttoRemove.push( t );\n\t\t\treturn false;\n\n\t\t}, null, false );\n\t\tfor ( let i = 0, l = toRemove.length; i < l; i ++ ) {\n\n\t\t\tlruCache.remove( toRemove[ i ] );\n\n\t\t}\n\n\t\tthis.stats = {\n\t\t\tparsing: 0,\n\t\t\tdownloading: 0,\n\t\t\tfailed: 0,\n\t\t\tinFrustum: 0,\n\t\t\tused: 0,\n\t\t\tactive: 0,\n\t\t\tvisible: 0,\n\t\t};\n\t\tthis.frameCount = 0;\n\n\t}\n\n\t// Overrideable\n\tcalculateBytesUsed( scene, tile ) {\n\n\t\treturn 0;\n\n\t}\n\n\tdispatchEvent( e ) {\n\n\t\t// event to be overriden for dispatching via an event system\n\n\t}\n\n\tfetchData( url, options ) {\n\n\t\treturn fetch( url, options );\n\n\t}\n\n\tparseTile( buffer, tile, extension ) {\n\n\t\treturn null;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\t// TODO: are these necessary? Are we disposing tiles when they are currently visible?\n\t\tif ( tile.__visible ) {\n\n\t\t\tthis.invokeOnePlugin( plugin => plugin.setTileVisible && plugin.setTileVisible( tile, false ) );\n\t\t\ttile.__visible = false;\n\n\t\t}\n\n\t\tif ( tile.__active ) {\n\n\t\t\tthis.invokeOnePlugin( plugin => plugin.setTileActive && plugin.setTileActive( tile, false ) );\n\t\t\ttile.__active = false;\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tileSetDir, parentTile = null ) {\n\n\t\tthis.processedTiles.add( tile );\n\n\t\tif ( tile.content ) {\n\n\t\t\t// Fix old file formats\n\t\t\tif ( ! ( 'uri' in tile.content ) && 'url' in tile.content ) {\n\n\t\t\t\ttile.content.uri = tile.content.url;\n\t\t\t\tdelete tile.content.url;\n\n\t\t\t}\n\n\t\t\t// NOTE: fix for some cases where tilesets provide the bounding volume\n\t\t\t// but volumes are not present.\n\t\t\tif (\n\t\t\t\ttile.content.boundingVolume &&\n\t\t\t\t! (\n\t\t\t\t\t'box' in tile.content.boundingVolume ||\n\t\t\t\t\t'sphere' in tile.content.boundingVolume ||\n\t\t\t\t\t'region' in tile.content.boundingVolume\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tdelete tile.content.boundingVolume;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttile.parent = parentTile;\n\t\ttile.children = tile.children || [];\n\n\t\tif ( tile.content?.uri ) {\n\n\t\t\t// \"content\" should only indicate loadable meshes, not external tile sets\n\t\t\tconst extension = getUrlExtension( tile.content.uri );\n\n\t\t\ttile.__hasContent = true;\n\t\t\ttile.__hasUnrenderableContent = Boolean( extension && /json$/.test( extension ) );\n\t\t\ttile.__hasRenderableContent = ! tile.__hasUnrenderableContent;\n\n\t\t} else {\n\n\t\t\ttile.__hasContent = false;\n\t\t\ttile.__hasUnrenderableContent = false;\n\t\t\ttile.__hasRenderableContent = false;\n\n\t\t}\n\n\t\t// tracker for determining if all the children have been asynchronously\n\t\t// processed and are ready to be traversed\n\t\ttile.__childrenProcessed = 0;\n\t\tif ( parentTile ) {\n\n\t\t\tparentTile.__childrenProcessed ++;\n\n\t\t}\n\n\t\ttile.__distanceFromCamera = Infinity;\n\t\ttile.__error = Infinity;\n\n\t\ttile.__inFrustum = false;\n\t\ttile.__isLeaf = false;\n\n\t\ttile.__usedLastFrame = false;\n\t\ttile.__used = false;\n\n\t\ttile.__wasSetVisible = false;\n\t\ttile.__visible = false;\n\t\ttile.__allChildrenLoaded = false;\n\n\t\ttile.__wasSetActive = false;\n\t\ttile.__active = false;\n\n\t\ttile.__loadingState = UNLOADED;\n\n\t\tif ( parentTile === null ) {\n\n\t\t\ttile.__depth = 0;\n\t\t\ttile.__depthFromRenderedParent = ( tile.__hasRenderableContent ? 1 : 0 );\n\t\t\ttile.refine = tile.refine || 'REPLACE';\n\n\t\t} else {\n\n\t\t\t// increment the \"depth from parent\" when we encounter a new tile with content\n\t\t\ttile.__depth = parentTile.__depth + 1;\n\t\t\ttile.__depthFromRenderedParent = parentTile.__depthFromRenderedParent + ( tile.__hasRenderableContent ? 1 : 0 );\n\n\t\t\ttile.refine = tile.refine || parentTile.refine;\n\n\t\t}\n\n\t\ttile.__basePath = tileSetDir;\n\n\t\ttile.__lastFrameVisited = - 1;\n\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tplugin !== this && plugin.preprocessNode && plugin.preprocessNode( tile, tileSetDir, parentTile );\n\n\t\t} );\n\n\t}\n\n\tsetTileActive( tile, active ) {\n\n\t\tactive ? this.activeTiles.add( tile ) : this.activeTiles.delete( tile );\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tvisible ? this.visibleTiles.add( tile ) : this.visibleTiles.delete( tile );\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\t// retrieve whether the tile is visible, screen space error, and distance to camera\n\t\t// set \"inView\", \"error\", \"distance\"\n\n\t}\n\n\tensureChildrenArePreprocessed( tile, immediate = false ) {\n\n\t\tconst children = tile.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst child = children[ i ];\n\t\t\tif ( '__depth' in child ) {\n\n\t\t\t\t// the child has already been processed\n\t\t\t\tbreak;\n\n\t\t\t} else if ( immediate ) {\n\n\t\t\t\t// process the node immediately and make sure we don't double process it\n\t\t\t\tthis.processNodeQueue.remove( child );\n\t\t\t\tthis.preprocessNode( child, tile.__basePath, tile );\n\n\t\t\t} else {\n\n\t\t\t\t// queue the node for processing if it hasn't been already\n\t\t\t\tif ( ! this.processNodeQueue.has( child ) ) {\n\n\t\t\t\t\tthis.processNodeQueue.add( child, child => {\n\n\t\t\t\t\t\tthis.preprocessNode( child, tile.__basePath, tile );\n\t\t\t\t\t\tthis._dispatchNeedsUpdateEvent();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Private Functions\n\t// returns the total bytes used for by the given tile as reported by all plugins\n\tgetBytesUsed( tile ) {\n\n\t\tlet bytes = 0;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.calculateBytesUsed ) {\n\n\t\t\t\tbytes += plugin.calculateBytesUsed( tile, tile.cached.scene ) || 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bytes;\n\n\t}\n\n\t// force a recalculation of the tile or all tiles if no tile is provided\n\trecalculateBytesUsed( tile = null ) {\n\n\t\tconst { lruCache, processedTiles } = this;\n\t\tif ( tile === null ) {\n\n\t\t\tlruCache.itemSet.forEach( item => {\n\n\t\t\t\tif ( processedTiles.has( item ) ) {\n\n\t\t\t\t\tlruCache.setMemoryUsage( item, this.getBytesUsed( item ) );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tlruCache.setMemoryUsage( tile, this.getBytesUsed( tile ) );\n\n\t\t}\n\n\t}\n\n\tpreprocessTileSet( json, url, parent = null ) {\n\n\t\tconst version = json.asset.version;\n\t\tconst [ major, minor ] = version.split( '.' ).map( v => parseInt( v ) );\n\t\tconsole.assert(\n\t\t\tmajor <= 1,\n\t\t\t'TilesRenderer: asset.version is expected to be a 1.x or a compatible version.',\n\t\t);\n\n\t\tif ( major === 1 && minor > 0 ) {\n\n\t\t\tconsole.warn( 'TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.' );\n\n\t\t}\n\n\t\t// remove the last file path path-segment from the URL including the trailing slash\n\t\tlet basePath = url.replace( /\\/[^/]*$/, '' );\n\t\tbasePath = new URL( basePath, window.location.href ).toString();\n\t\tthis.preprocessNode( json.root, basePath, parent );\n\n\t}\n\n\tloadRootTileSet() {\n\n\t\t// transform the url\n\t\tlet processedUrl = this.rootURL;\n\t\tthis.invokeAllPlugins( plugin => processedUrl = plugin.preprocessURL ? plugin.preprocessURL( processedUrl, null ) : processedUrl );\n\n\t\t// load the tile set root\n\t\tconst pr = this\n\t\t\t.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( processedUrl, this.fetchOptions ) )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( ! ( res instanceof Response ) ) {\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else if ( res.ok ) {\n\n\t\t\t\t\treturn res.json();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `TilesRenderer: Failed to load tileset \"${ processedUrl }\" with status ${ res.status } : ${ res.statusText }` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( root => {\n\n\t\t\t\tthis.preprocessTileSet( root, processedUrl );\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t\treturn pr;\n\n\t}\n\n\trequestTileContents( tile ) {\n\n\t\t// If the tile is already being loaded then don't\n\t\t// start it again.\n\t\tif ( tile.__loadingState !== UNLOADED ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet isExternalTileSet = false;\n\t\tlet externalTileset = null;\n\t\tlet uri = new URL( tile.content.uri, tile.__basePath + '/' ).toString();\n\t\tthis.invokeAllPlugins( plugin => uri = plugin.preprocessURL ? plugin.preprocessURL( uri, tile ) : uri );\n\n\t\tconst stats = this.stats;\n\t\tconst lruCache = this.lruCache;\n\t\tconst downloadQueue = this.downloadQueue;\n\t\tconst parseQueue = this.parseQueue;\n\t\tconst extension = getUrlExtension( uri );\n\n\t\t// track an abort controller and pass-through the below conditions if aborted\n\t\tconst controller = new AbortController();\n\t\tconst signal = controller.signal;\n\t\tconst addedSuccessfully = lruCache.add( tile, t => {\n\n\t\t\t// Stop the load if it's started\n\t\t\tcontroller.abort();\n\n\t\t\t// Clear out all tile content\n\t\t\tif ( isExternalTileSet ) {\n\n\t\t\t\tt.children.length = 0;\n\t\t\t\tt.__childrenProcessed = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\t\t\tplugin.disposeTile && plugin.disposeTile( t );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// Decrement stats\n\t\t\tstats.inCache --;\n\t\t\tif ( this.cachedSinceLoadComplete.has( tile ) ) {\n\n\t\t\t\tthis.cachedSinceLoadComplete.delete( tile );\n\t\t\t\tstats.inCacheSinceLoad --;\n\n\t\t\t}\n\n\t\t\tif ( t.__loadingState === LOADING ) {\n\n\t\t\t\tstats.downloading --;\n\n\t\t\t} else if ( t.__loadingState === PARSING ) {\n\n\t\t\t\tstats.parsing --;\n\n\t\t\t}\n\n\t\t\tt.__loadingState = UNLOADED;\n\n\t\t\tparseQueue.remove( t );\n\t\t\tdownloadQueue.remove( t );\n\n\t\t} );\n\n\t\t// if we couldn't add the tile to the lru cache because it's full then skip\n\t\tif ( ! addedSuccessfully ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if this is the beginning of a new set of tiles to load and dispatch and event\n\t\tif ( ! this.isLoading ) {\n\n\t\t\tthis.isLoading = true;\n\t\t\tthis.dispatchEvent( { type: 'tiles-load-start' } );\n\n\t\t}\n\n\t\tlruCache.setMemoryUsage( tile, this.getBytesUsed( tile ) );\n\t\tthis.cachedSinceLoadComplete.add( tile );\n\t\tstats.inCacheSinceLoad ++;\n\t\tstats.inCache ++;\n\t\tstats.downloading ++;\n\t\ttile.__loadingState = LOADING;\n\n\t\t// queue the download and parse\n\t\treturn downloadQueue.add( tile, downloadTile => {\n\n\t\t\tif ( signal.aborted ) {\n\n\t\t\t\treturn Promise.resolve();\n\n\t\t\t}\n\n\t\t\tconst res = this.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( uri, { ...this.fetchOptions, signal } ) );\n\t\t\tthis.dispatchEvent( { type: 'tile-download-start', tile } );\n\t\t\treturn res;\n\n\t\t} )\n\t\t\t.then( res => {\n\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( res instanceof Response ) ) {\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else if ( res.ok ) {\n\n\t\t\t\t\treturn extension === 'json' ? res.json() : res.arrayBuffer();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `Failed to load model with error code ${res.status}` );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( content => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tstats.downloading --;\n\t\t\t\tstats.parsing ++;\n\t\t\t\ttile.__loadingState = PARSING;\n\n\t\t\t\treturn parseQueue.add( tile, parseTile => {\n\n\t\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( extension === 'json' && content.root ) {\n\n\t\t\t\t\t\tthis.preprocessTileSet( content, uri, tile );\n\t\t\t\t\t\ttile.children.push( content.root );\n\t\t\t\t\t\texternalTileset = content;\n\t\t\t\t\t\tisExternalTileSet = true;\n\t\t\t\t\t\treturn Promise.resolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn this.invokeOnePlugin( plugin => plugin.parseTile && plugin.parseTile( content, parseTile, extension, uri, signal ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( () => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tstats.parsing --;\n\t\t\t\ttile.__loadingState = LOADED;\n\t\t\t\tlruCache.setLoaded( tile, true );\n\n\t\t\t\t// If the memory of the item hasn't been registered yet then that means the memory usage hasn't\n\t\t\t\t// been accounted for by the cache yet so we need to check if it fits or if we should remove it.\n\t\t\t\tconst bytesUsed = this.getBytesUsed( tile );\n\t\t\t\tif ( lruCache.getMemoryUsage( tile ) === 0 && bytesUsed > 0 && lruCache.isFull() ) {\n\n\t\t\t\t\t// And if the cache is full due to newly loaded memory then lets discard this tile - it will\n\t\t\t\t\t// be loaded again later from the disk cache if needed.\n\t\t\t\t\tlruCache.remove( tile );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// update memory\n\t\t\t\tlruCache.setMemoryUsage( tile, bytesUsed );\n\n\t\t\t\t// dispatch an event indicating that this model has completed and that a new\n\t\t\t\t// call to \"update\" is needed.\n\t\t\t\tthis.dispatchEvent( { type: 'needs-update' } );\n\t\t\t\tthis.dispatchEvent( { type: 'load-content' } );\n\t\t\t\tif ( isExternalTileSet ) {\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-tile-set',\n\t\t\t\t\t\ttileSet: externalTileset,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\t\t\t\tif ( tile.cached.scene ) {\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-model',\n\t\t\t\t\t\tscene: tile.cached.scene,\n\t\t\t\t\t\ttile,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( error => {\n\n\t\t\t\t// if it has been unloaded then the tile has been disposed\n\t\t\t\tif ( signal.aborted ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( error.name !== 'AbortError' ) {\n\n\t\t\t\t\tparseQueue.remove( tile );\n\t\t\t\t\tdownloadQueue.remove( tile );\n\n\t\t\t\t\tif ( tile.__loadingState === PARSING ) {\n\n\t\t\t\t\t\tstats.parsing --;\n\n\t\t\t\t\t} else if ( tile.__loadingState === LOADING ) {\n\n\t\t\t\t\t\tstats.downloading --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstats.failed ++;\n\n\t\t\t\t\tconsole.error( `TilesRenderer : Failed to load tile at url \"${ tile.content.uri }\".` );\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\ttile.__loadingState = FAILED;\n\t\t\t\t\tlruCache.setLoaded( tile, true );\n\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\t\ttile,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\turl: uri,\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlruCache.remove( tile );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t}\n\n\tgetAttributions( target = [] ) {\n\n\t\tthis.invokeAllPlugins( plugin => plugin !== this && plugin.getAttributions && plugin.getAttributions( target ) );\n\t\treturn target;\n\n\t}\n\n\tinvokeOnePlugin( func ) {\n\n\t\tconst plugins = [ ...this.plugins, this ];\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst result = func( plugins[ i ] );\n\t\t\tif ( result ) {\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tinvokeAllPlugins( func ) {\n\n\t\tconst plugins = [ ...this.plugins, this ];\n\t\tconst pending = [];\n\t\tfor ( let i = 0; i < plugins.length; i ++ ) {\n\n\t\t\tconst result = func( plugins[ i ] );\n\t\t\tif ( result ) {\n\n\t\t\t\tpending.push( result );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn pending.length === 0 ? null : Promise.all( pending );\n\n\t}\n\n}\n","import { Group, Matrix4 } from 'three';\n\n// Specialization of \"Group\" that only updates world matrices of children if\n// the transform has changed since the last update and ignores the \"force\"\n// parameter under the assumption that the children tiles will not move.\nconst tempMat = new Matrix4();\nexport class TilesGroup extends Group {\n\n\tconstructor( tilesRenderer ) {\n\n\t\tsuper();\n\t\tthis.isTilesGroup = true;\n\t\tthis.name = 'TilesRenderer.TilesGroup';\n\t\tthis.tilesRenderer = tilesRenderer;\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\t// returning \"false\" ends raycast traversal\n\t\tif ( this.tilesRenderer.optimizeRaycast ) {\n\n\t\t\tthis.tilesRenderer.raycast( raycaster, intersects );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) {\n\n\t\t\tthis.updateMatrix();\n\n\t\t}\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\ttempMat.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\ttempMat.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t// check if the matrix changed relative to what it was.\n\t\t\tconst elA = tempMat.elements;\n\t\t\tconst elB = this.matrixWorld.elements;\n\t\t\tlet isDifferent = false;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\tconst itemA = elA[ i ];\n\t\t\t\tconst itemB = elB[ i ];\n\t\t\t\tconst diff = Math.abs( itemA - itemB );\n\n\t\t\t\tif ( diff > Number.EPSILON ) {\n\n\t\t\t\t\tisDifferent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isDifferent ) {\n\n\t\t\t\tthis.matrixWorld.copy( tempMat );\n\t\t\t\tthis.matrixWorldInverse.copy( tempMat ).invert();\n\n\t\t\t\t// update children\n\t\t\t\t// the children will not have to change unless the parent group has updated\n\t\t\t\tconst children = this.children;\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tchildren[ i ].updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tif ( this.parent && updateParents ) {\n\n\t\t\tthis.parent.updateWorldMatrix( updateParents, false );\n\n\t\t}\n\n\t\t// run the normal update function to ensure children and inverse matrices are in sync\n\t\tthis.updateMatrixWorld( true );\n\n\t}\n\n}\n","import { Ray, Vector3 } from 'three';\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst _localRay = new Ray();\nconst _vec = new Vector3();\nconst _hitArray = [];\n\nfunction distanceSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectTileScene( tile, raycaster, renderer, intersects ) {\n\n\tconst { scene } = tile.cached;\n\tconst didRaycast = renderer.invokeOnePlugin( plugin => plugin.raycastTile && plugin.raycastTile( tile, scene, raycaster, intersects ) );\n\tif ( ! didRaycast ) {\n\n\t\traycaster.intersectObject( scene, true, intersects );\n\n\t}\n\n}\n\nfunction intersectTileSceneFirstHist( tile, raycaster, renderer ) {\n\n\tintersectTileScene( tile, raycaster, renderer, _hitArray );\n\t_hitArray.sort( distanceSort );\n\n\tconst hit = _hitArray[ 0 ] || null;\n\t_hitArray.length = 0;\n\treturn hit;\n\n}\n\nfunction isTileInitialized( tile ) {\n\n\treturn '__used' in tile;\n\n}\n\n// Returns the closest hit when traversing the tree\nexport function raycastTraverseFirstHit( renderer, tile, raycaster, localRay = null ) {\n\n\tconst { group, activeTiles } = renderer;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// get a set of intersections so we intersect the nearest one first\n\tconst array = [];\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tconst child = children[ i ];\n\t\tif ( ! isTileInitialized( child ) || ! child.__used ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// track the tile and hit distance for sorting\n\t\tconst boundingVolume = child.cached.boundingVolume;\n\t\tif ( boundingVolume.intersectRay( localRay, _vec ) !== null ) {\n\n\t\t\t_vec.applyMatrix4( group.matrixWorld );\n\t\t\tarray.push( {\n\t\t\t\tdistance: _vec.distanceToSquared( raycaster.ray.origin ),\n\t\t\t\ttile: child,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sort them by ascending distance\n\tarray.sort( distanceSort );\n\n\t// If the root is active make sure we've checked it\n\tlet bestHit = null;\n\tlet bestHitDistSq = Infinity;\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tconst hit = intersectTileSceneFirstHist( tile, raycaster, renderer );\n\t\tif ( hit ) {\n\n\t\t\tbestHit = hit;\n\t\t\tbestHitDistSq = hit.distance * hit.distance;\n\n\t\t}\n\n\t}\n\n\t// traverse until we find the best hit and early out if a tile bounds\n\t// couldn't possible include a best hit\n\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\tconst data = array[ i ];\n\t\tconst boundingVolumeDistSq = data.distance;\n\t\tconst tile = data.tile;\n\t\tif ( boundingVolumeDistSq > bestHitDistSq ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tconst hit = raycastTraverseFirstHit( renderer, tile, raycaster, localRay );\n\t\tif ( hit ) {\n\n\t\t\tconst hitDistSq = hit.distance * hit.distance;\n\t\t\tif ( hitDistSq < bestHitDistSq ) {\n\n\t\t\t\tbestHit = hit;\n\t\t\t\tbestHitDistSq = hitDistSq;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bestHit;\n\n}\n\nexport function raycastTraverse( renderer, tile, raycaster, intersects, localRay = null ) {\n\n\t// if the tile has not been asynchronously initialized then there's no point in\n\t// traversing the tiles to check intersections.\n\tif ( ! isTileInitialized( tile ) ) {\n\n\t\treturn;\n\n\t}\n\n\tconst { group, activeTiles } = renderer;\n\tconst { boundingVolume } = tile.cached;\n\n\t// get the ray in the local group frame\n\tif ( localRay === null ) {\n\n\t\tlocalRay = _localRay;\n\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( group.matrixWorldInverse );\n\n\t}\n\n\t// exit early if the tile isn't used or the bounding volume is not intersected\n\tif ( ! tile.__used || ! boundingVolume.intersectsRay( localRay ) ) {\n\n\t\treturn;\n\n\t}\n\n\t// only intersect the tile geometry if it's active\n\tif ( activeTiles.has( tile ) ) {\n\n\t\tintersectTileScene( tile, raycaster, renderer, intersects );\n\n\t}\n\n\tconst children = tile.children;\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\traycastTraverse( renderer, children[ i ], raycaster, intersects, localRay );\n\n\t}\n\n}\n","import { Matrix4, Box3, Vector3, Plane, Ray } from 'three';\n\nconst _worldMin = new Vector3();\nconst _worldMax = new Vector3();\nconst _norm = new Vector3();\nconst _ray = new Ray();\n\nexport class OBB {\n\n\tconstructor( box = new Box3(), transform = new Matrix4() ) {\n\n\t\tthis.box = box.clone();\n\t\tthis.transform = transform.clone();\n\t\tthis.inverseTransform = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.planes = new Array( 6 ).fill().map( () => new Plane() );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.box.copy( source.box );\n\t\tthis.transform.copy( source.transform );\n\t\tthis.update();\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this OBB\n\t * @param {Vector3} point\n\t * @param {Vector3} result\n\t * @returns {Vector3}\n\t */\n\tclampPoint( point, result ) {\n\n\t\treturn result.copy( point )\n\t\t\t.applyMatrix4( this.inverseTransform )\n\t\t\t.clamp( this.box.min, this.box.max )\n\t\t\t.applyMatrix4( this.transform );\n\n\t}\n\n\t/**\n\t * Returns the distance from any edge of this OBB to the specified point.\n\t * If the point lies inside of this box, the distance will be 0.\n\t * @param {Vector3} point\n\t * @returns {number}\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _norm ).distanceTo( point );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\t_norm.copy( point ).applyMatrix4( this.inverseTransform );\n\t\treturn this.box.containsPoint( _norm );\n\n\t}\n\n\t// returns boolean indicating whether the ray has intersected the obb\n\tintersectsRay( ray ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\treturn _ray.intersectsBox( this.box );\n\n\t}\n\n\t// Sets \"target\" equal to the intersection point.\n\t// Returns \"null\" if no intersection found.\n\tintersectRay( ray, target ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\tif ( _ray.intersectBox( this.box, target ) ) {\n\n\t\t\ttarget.applyMatrix4( this.transform );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst { points, inverseTransform, transform, box } = this;\n\t\tinverseTransform.copy( transform ).invert();\n\n\t\tconst { min, max } = box;\n\t\tlet index = 0;\n\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\tpoints[ index ].set(\n\t\t\t\t\t\tx < 0 ? min.x : max.x,\n\t\t\t\t\t\ty < 0 ? min.y : max.y,\n\t\t\t\t\t\tz < 0 ? min.z : max.z,\n\t\t\t\t\t).applyMatrix4( transform );\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updatePlanes();\n\n\t}\n\n\tupdatePlanes() {\n\n\t\t_worldMin.copy( this.box.min ).applyMatrix4( this.transform );\n\t\t_worldMax.copy( this.box.max ).applyMatrix4( this.transform );\n\n\t\t_norm.set( 0, 0, 1 ).transformDirection( this.transform );\n\t\tthis.planes[ 0 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 1 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 0, 1, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 2 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 3 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 1, 0, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 4 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 5 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tthis.clampPoint( sphere.center, _norm );\n\t\treturn _norm.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\treturn this._intersectsPlaneShape( frustum.planes, frustum.points );\n\n\t}\n\n\tintersectsOBB( obb ) {\n\n\t\treturn this._intersectsPlaneShape( obb.planes, obb.points );\n\n\t}\n\n\t// takes a series of 6 planes that define and enclosed shape and the 8 points that lie at the corners\n\t// of that shape to determine whether the OBB is intersected with.\n\t_intersectsPlaneShape( otherPlanes, otherPoints ) {\n\n\t\tconst thisPoints = this.points;\n\t\tconst thisPlanes = this.planes;\n\n\t\t// based on three.js' Box3 \"intersects frustum\" function\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = otherPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = thisPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// do the opposite check using the obb planes to avoid false positives\n\t\t// this check is not performed by three.js' AABB logic but helps prevent a lot incorrect intersection reports\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = thisPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = otherPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n}\n","import { Vector3, Sphere } from 'three';\nimport { OBB } from './OBB.js';\nimport { EllipsoidRegion } from './EllipsoidRegion.js';\n\nconst _vecX = new Vector3();\nconst _vecY = new Vector3();\nconst _vecZ = new Vector3();\nconst _sphereVec = new Vector3();\nconst _obbVec = new Vector3();\n\n// TODO: check region more precisely in all functions\nexport class TileBoundingVolume {\n\n\tconstructor() {\n\n\t\tthis.sphere = null;\n\t\tthis.obb = null;\n\t\tthis.region = null;\n\n\t\tthis.regionObb = null;\n\n\t}\n\n\tintersectsRay( ray ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\t// Early out if we don't hit this tile sphere\n\t\tif ( sphere && ! ray.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Early out if we don't this this tile box\n\t\tif ( obb && ! obb.intersectsRay( ray ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectRay( ray, target = null ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistSq = - Infinity;\n\t\tlet obbDistSq = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\tif ( ray.intersectSphere( sphere, _sphereVec ) ) {\n\n\t\t\t\tsphereDistSq = sphere.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _sphereVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tif ( obb.intersectRay( ray, _obbVec ) ) {\n\n\t\t\t\tobbDistSq = obb.containsPoint( ray.origin ) ? 0 : ray.origin.distanceToSquared( _obbVec );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if we didn't hit anything then exit\n\t\tconst furthestDist = Math.max( sphereDistSq, obbDistSq );\n\t\tif ( furthestDist === - Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// get the furthest hit point if needed\n\t\tray.at( Math.sqrt( furthestDist ), target );\n\t\treturn target;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst sphere = this.sphere;\n\t\tconst obb = this.obb || this.regionObb;\n\n\t\tlet sphereDistance = - Infinity;\n\t\tlet obbDistance = - Infinity;\n\n\t\tif ( sphere ) {\n\n\t\t\t// Sphere#distanceToPoint is negative inside the sphere, whereas Box3#distanceToPoint is\n\t\t\t// zero inside the box. Clipping the distance to a minimum of zero ensures that both\n\t\t\t// types of bounding volume behave the same way.\n\t\t\tsphereDistance = Math.max( sphere.distanceToPoint( point ), 0 );\n\n\t\t}\n\n\t\tif ( obb ) {\n\n\t\t\tobbDistance = obb.distanceToPoint( point );\n\n\t\t}\n\n\t\t// return the further distance of the two volumes\n\t\treturn sphereDistance > obbDistance ? sphereDistance : obbDistance;\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! frustum.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsFrustum( frustum ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// if we don't have a sphere or obb then just say we did intersect\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsSphere( otherSphere ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! sphere.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsSphere( otherSphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tintersectsOBB( otherObb ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tconst sphere = this.sphere;\n\t\tif ( sphere && ! otherObb.intersectsSphere( sphere ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( obb && ! obb.intersectsOBB( otherObb ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn Boolean( sphere || obb );\n\n\t}\n\n\tgetOBB( targetBox, targetMatrix ) {\n\n\t\tconst obb = this.obb || this.regionObb;\n\t\tif ( obb ) {\n\n\t\t\ttargetBox.copy( obb.box );\n\t\t\ttargetMatrix.copy( obb.transform );\n\n\t\t} else {\n\n\t\t\tthis.getAABB( targetBox );\n\t\t\ttargetMatrix.identity();\n\n\t\t}\n\n\t}\n\n\tgetAABB( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\tthis.sphere.getBoundingBox( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\ttarget.copy( obb.box ).applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tgetSphere( target ) {\n\n\t\tif ( this.sphere ) {\n\n\t\t\ttarget.copy( this.sphere );\n\n\t\t} else if ( this.region ) {\n\n\t\t\tthis.region.getBoundingSphere( target );\n\n\t\t} else {\n\n\t\t\tconst obb = this.obb || this.regionObb;\n\t\t\tobb.box.getBoundingSphere( target );\n\t\t\ttarget.applyMatrix4( obb.transform );\n\n\t\t}\n\n\t}\n\n\tsetObbData( data, transform ) {\n\n\t\tconst obb = new OBB();\n\n\t\t// get the extents of the bounds in each axis\n\t\t_vecX.set( data[ 3 ], data[ 4 ], data[ 5 ] );\n\t\t_vecY.set( data[ 6 ], data[ 7 ], data[ 8 ] );\n\t\t_vecZ.set( data[ 9 ], data[ 10 ], data[ 11 ] );\n\n\t\tconst scaleX = _vecX.length();\n\t\tconst scaleY = _vecY.length();\n\t\tconst scaleZ = _vecZ.length();\n\n\t\t_vecX.normalize();\n\t\t_vecY.normalize();\n\t\t_vecZ.normalize();\n\n\t\t// handle the case where the box has a dimension of 0 in one axis\n\t\tif ( scaleX === 0 ) {\n\n\t\t\t_vecX.crossVectors( _vecY, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleY === 0 ) {\n\n\t\t\t_vecY.crossVectors( _vecX, _vecZ );\n\n\t\t}\n\n\t\tif ( scaleZ === 0 ) {\n\n\t\t\t_vecZ.crossVectors( _vecX, _vecY );\n\n\t\t}\n\n\t\t// create the oriented frame that the box exists in\n\t\tobb.transform\n\t\t\t.set(\n\t\t\t\t_vecX.x, _vecY.x, _vecZ.x, data[ 0 ],\n\t\t\t\t_vecX.y, _vecY.y, _vecZ.y, data[ 1 ],\n\t\t\t\t_vecX.z, _vecY.z, _vecZ.z, data[ 2 ],\n\t\t\t\t0, 0, 0, 1\n\t\t\t)\n\t\t\t.premultiply( transform );\n\n\t\t// scale the box by the extents\n\t\tobb.box.min.set( - scaleX, - scaleY, - scaleZ );\n\t\tobb.box.max.set( scaleX, scaleY, scaleZ );\n\t\tobb.update();\n\t\tthis.obb = obb;\n\n\t}\n\n\tsetSphereData( x, y, z, radius, transform ) {\n\n\t\tconst sphere = new Sphere();\n\t\tsphere.center.set( x, y, z );\n\t\tsphere.radius = radius;\n\t\tsphere.applyMatrix4( transform );\n\t\tthis.sphere = sphere;\n\n\t}\n\n\tsetRegionData( ellipsoid, west, south, east, north, minHeight, maxHeight ) {\n\n\t\tconst region = new EllipsoidRegion(\n\t\t\t...ellipsoid.radius,\n\t\t\tsouth, north,\n\t\t\twest, east,\n\t\t\tminHeight, maxHeight,\n\t\t);\n\n\t\tconst obb = new OBB();\n\t\tregion.getBoundingBox( obb.box, obb.transform );\n\t\tobb.update();\n\n\t\tthis.region = region;\n\t\tthis.regionObb = obb;\n\n\t}\n\n}\n","import { Frustum, Matrix3, Vector3 } from 'three';\n\nconst _mat3 = new Matrix3();\n\n// Solve a system of equations to find the point where the three planes intersect\nfunction findIntersectionPoint( plane1, plane2, plane3, target ) {\n\n\t// Create the matrix A using the normals of the planes as rows\n\tconst A = _mat3.set(\n\t\tplane1.normal.x, plane1.normal.y, plane1.normal.z,\n\t\tplane2.normal.x, plane2.normal.y, plane2.normal.z,\n\t\tplane3.normal.x, plane3.normal.y, plane3.normal.z\n\t);\n\n\t// Create the vector B using the constants of the planes\n\ttarget.set( - plane1.constant, - plane2.constant, - plane3.constant );\n\n\t// Solve for X by applying the inverse matrix to B\n\ttarget.applyMatrix3( A.invert() );\n\n\treturn target;\n\n}\n\nclass ExtendedFrustum extends Frustum {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.points = Array( 8 ).fill().map( () => new Vector3() );\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem ) {\n\n\t\tsuper.setFromProjectionMatrix( m, coordinateSystem );\n\t\tthis.calculateFrustumPoints();\n\t\treturn this;\n\n\t}\n\n\tcalculateFrustumPoints() {\n\n\t\tconst { planes, points } = this;\n\t\tconst planeIntersections = [\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 4 ] ], // Near top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 4 ] ], // Near top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 4 ] ], // Near bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 4 ] ], // Near bottom right\n\t\t\t[ planes[ 0 ], planes[ 3 ], planes[ 5 ] ], // Far top left\n\t\t\t[ planes[ 1 ], planes[ 3 ], planes[ 5 ] ], // Far top right\n\t\t\t[ planes[ 0 ], planes[ 2 ], planes[ 5 ] ], // Far bottom left\n\t\t\t[ planes[ 1 ], planes[ 2 ], planes[ 5 ] ], // Far bottom right\n\t\t];\n\n\t\tplaneIntersections.forEach( ( planes, index ) => {\n\n\t\t\tfindIntersectionPoint( planes[ 0 ], planes[ 1 ], planes[ 2 ], points[ index ] );\n\n\t\t} );\n\n\t}\n\n}\n\nexport { ExtendedFrustum };\n","import { estimateBytesUsed as _estimateBytesUsed } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport * as THREE from 'three';\n\nexport function safeTextureGetByteLength( tex ) {\n\n\t// NOTE: This is for backwards compatibility and should be removed later\n\t// deprecated: remove in next major release\n\tconst { TextureUtils } = THREE;\n\tif ( ! TextureUtils || ! tex ) {\n\n\t\treturn 0;\n\n\t}\n\n\n\tconst { format, type, image } = tex;\n\tconst { width, height } = image;\n\n\tlet bytes = TextureUtils.getByteLength( width, height, format, type );\n\tbytes *= tex.generateMipmaps ? 4 / 3 : 1;\n\n\treturn bytes;\n\n\n}\n\n// Returns the estimated number of bytes used by the object\nexport function estimateBytesUsed( object ) {\n\n\tconst dedupeSet = new Set();\n\n\tlet totalBytes = 0;\n\tobject.traverse( c => {\n\n\t\t// get geometry bytes\n\t\tif ( c.geometry && ! dedupeSet.has( c.geometry ) ) {\n\n\t\t\ttotalBytes += _estimateBytesUsed( c.geometry );\n\t\t\tdedupeSet.add( c.geometry );\n\n\t\t}\n\n\t\t// get material bytes\n\t\tif ( c.material ) {\n\n\t\t\tconst material = c.material;\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tconst value = material[ key ];\n\t\t\t\tif ( value && value.isTexture && ! dedupeSet.has( value ) ) {\n\n\t\t\t\t\ttotalBytes += safeTextureGetByteLength( value );\n\t\t\t\t\tdedupeSet.add( value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn totalBytes;\n\n}\n","import { TilesRendererBase } from '../../../core/renderer/tiles/TilesRendererBase.js';\nimport { B3DMLoader } from '../loaders/B3DMLoader.js';\nimport { PNTSLoader } from '../loaders/PNTSLoader.js';\nimport { I3DMLoader } from '../loaders/I3DMLoader.js';\nimport { CMPTLoader } from '../loaders/CMPTLoader.js';\nimport { TilesGroup } from './TilesGroup.js';\nimport {\n\tMatrix4,\n\tVector3,\n\tVector2,\n\tEuler,\n\tLoadingManager,\n\tEventDispatcher,\n\tGroup,\n} from 'three';\nimport { raycastTraverse, raycastTraverseFirstHit } from './raycastTraverse.js';\nimport { readMagicBytes } from '../../../core/renderer/utilities/readMagicBytes.js';\nimport { TileBoundingVolume } from '../math/TileBoundingVolume.js';\nimport { ExtendedFrustum } from '../math/ExtendedFrustum.js';\nimport { estimateBytesUsed } from './utilities.js';\nimport { WGS84_ELLIPSOID } from '../math/GeoConstants.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nconst _mat = new Matrix4();\nconst _euler = new Euler();\n\n// In three.js r165 and higher raycast traversal can be ended early\nconst INITIAL_FRUSTUM_CULLED = Symbol( 'INITIAL_FRUSTUM_CULLED' );\nconst tempMat = new Matrix4();\nconst tempVector = new Vector3();\nconst tempVector2 = new Vector2();\nconst viewErrorTarget = {\n\tinView: false,\n\terror: Infinity,\n};\n\nconst X_AXIS = new Vector3( 1, 0, 0 );\nconst Y_AXIS = new Vector3( 0, 1, 0 );\n\nfunction updateFrustumCulled( object, toInitialValue ) {\n\n\tobject.traverse( c => {\n\n\t\tc.frustumCulled = c[ INITIAL_FRUSTUM_CULLED ] && toInitialValue;\n\n\t} );\n\n}\n\nexport class TilesRenderer extends TilesRendererBase {\n\n\tget autoDisableRendererCulling() {\n\n\t\treturn this._autoDisableRendererCulling;\n\n\t}\n\n\tset autoDisableRendererCulling( value ) {\n\n\t\tif ( this._autoDisableRendererCulling !== value ) {\n\n\t\t\tsuper._autoDisableRendererCulling = value;\n\t\t\tthis.forEachLoadedModel( ( scene ) => {\n\n\t\t\t\tupdateFrustumCulled( scene, ! value );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tget optimizeRaycast() {\n\n\t\treturn this._optimizeRaycast;\n\n\t}\n\n\tset optimizeRaycast( v ) {\n\n\t\tconsole.warn( 'TilesRenderer: The \"optimizeRaycast\" option has been deprecated.' );\n\t\tthis._optimizeRaycast = v;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.group = new TilesGroup( this );\n\t\tthis.ellipsoid = WGS84_ELLIPSOID.clone();\n\t\tthis.cameras = [];\n\t\tthis.cameraMap = new Map();\n\t\tthis.cameraInfo = [];\n\t\tthis._optimizeRaycast = true;\n\t\tthis._upRotationMatrix = new Matrix4();\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\t// flag indicating whether frustum culling should be disabled\n\t\tthis._autoDisableRendererCulling = true;\n\n\t\tconst manager = new LoadingManager();\n\t\tmanager.setURLModifier( url => {\n\n\t\t\tif ( this.preprocessURL ) {\n\n\t\t\t\treturn this.preprocessURL( url );\n\n\t\t\t} else {\n\n\t\t\t\treturn url;\n\n\t\t\t}\n\n\t\t} );\n\t\tthis.manager = manager;\n\n\t\t// saved for event dispatcher functions\n\t\tthis._listeners = {};\n\n\t}\n\n\taddEventListener( ...args ) {\n\n\t\tEventDispatcher.prototype.addEventListener.call( this, ...args );\n\n\t}\n\n\thasEventListener( ...args ) {\n\n\t\tEventDispatcher.prototype.hasEventListener.call( this, ...args );\n\n\t}\n\n\tremoveEventListener( ...args ) {\n\n\t\tEventDispatcher.prototype.removeEventListener.call( this, ...args );\n\n\t}\n\n\tdispatchEvent( ...args ) {\n\n\t\tEventDispatcher.prototype.dispatchEvent.call( this, ...args );\n\n\t}\n\n\t/* Public API */\n\tgetBoundingBox( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getAABB( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetOrientedBoundingBox( targetBox, targetMatrix ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getOBB( targetBox, targetMatrix );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst boundingVolume = this.root.cached.boundingVolume;\n\t\tif ( boundingVolume ) {\n\n\t\t\tboundingVolume.getSphere( target );\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tforEachLoadedModel( callback ) {\n\n\t\tthis.traverse( tile => {\n\n\t\t\tconst scene = tile.cached && tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tcallback( scene, tile );\n\n\t\t\t}\n\n\t\t}, null, false );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( ! this.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( raycaster.firstHitOnly ) {\n\n\t\t\tconst hit = raycastTraverseFirstHit( this, this.root, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\traycastTraverse( this, this.root, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\thasCamera( camera ) {\n\n\t\treturn this.cameraMap.has( camera );\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\tcameraMap.set( camera, new Vector2() );\n\t\t\tcameras.push( camera );\n\t\t\tthis.dispatchEvent( { type: 'add-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\t\treturn false;\n\n\t}\n\n\tsetResolution( camera, xOrVec, y ) {\n\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( ! cameraMap.has( camera ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst width = xOrVec.isVector2 ? xOrVec.x : xOrVec;\n\t\tconst height = xOrVec.isVector2 ? xOrVec.y : y;\n\t\tconst cameraVec = cameraMap.get( camera );\n\n\t\tif ( cameraVec.width !== width || cameraVec.height !== height ) {\n\n\t\t\tcameraVec.set( width, height );\n\t\t\tthis.dispatchEvent( { type: 'camera-resolution-change' } );\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tsetResolutionFromRenderer( camera, renderer ) {\n\n\t\trenderer.getSize( tempVector2 );\n\n\t\treturn this.setResolution( camera, tempVector2.x, tempVector2.y );\n\n\t}\n\n\tdeleteCamera( camera ) {\n\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tif ( cameraMap.has( camera ) ) {\n\n\t\t\tconst index = cameras.indexOf( camera );\n\t\t\tcameras.splice( index, 1 );\n\t\t\tcameraMap.delete( camera );\n\t\t\tthis.dispatchEvent( { type: 'delete-camera', camera } );\n\n\t\t\treturn true;\n\n\t\t}\n\t\treturn false;\n\n\t}\n\n\t/* Overriden */\n\tloadRootTileSet( ...args ) {\n\n\t\treturn super.loadRootTileSet( ...args )\n\t\t\t.then( root => {\n\n\t\t\t\t// cache the gltf tile set rotation matrix\n\t\t\t\tconst { asset, extensions = {} } = root;\n\t\t\t\tconst upAxis = asset && asset.gltfUpAxis || 'y';\n\t\t\t\tswitch ( upAxis.toLowerCase() ) {\n\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( Y_AXIS, - Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tthis._upRotationMatrix.makeRotationAxis( X_AXIS, Math.PI / 2 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// update the ellipsoid based on the extension\n\t\t\t\tif ( '3DTILES_ellipsoid' in extensions ) {\n\n\t\t\t\t\tconst ext = extensions[ '3DTILES_ellipsoid' ];\n\t\t\t\t\tconst { ellipsoid } = this;\n\t\t\t\t\tellipsoid.name = ext.body;\n\t\t\t\t\tif ( ext.radii ) {\n\n\t\t\t\t\t\tellipsoid.radius.set( ...ext.radii );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tellipsoid.radius.set( 1, 1, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn root;\n\n\t\t\t} );\n\n\t}\n\n\tupdate() {\n\n\t\t// check if the plugins that can block the tile updates require it\n\t\tlet needsUpdate = null;\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin.doTilesNeedUpdate ) {\n\n\t\t\t\tconst res = plugin.doTilesNeedUpdate();\n\t\t\t\tif ( needsUpdate === null ) {\n\n\t\t\t\t\tneedsUpdate = res;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tneedsUpdate = Boolean( needsUpdate || res );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( needsUpdate === false ) {\n\n\t\t\tthis.dispatchEvent( { type: 'update-before' } );\n\t\t\tthis.dispatchEvent( { type: 'update-after' } );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// follow through with the update\n\t\tthis.dispatchEvent( { type: 'update-before' } );\n\n\t\tconst group = this.group;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraMap = this.cameraMap;\n\t\tconst cameraInfo = this.cameraInfo;\n\n\t\t// automatically scale the array of cameraInfo to match the cameras\n\t\twhile ( cameraInfo.length > cameras.length ) {\n\n\t\t\tcameraInfo.pop();\n\n\t\t}\n\n\t\twhile ( cameraInfo.length < cameras.length ) {\n\n\t\t\tcameraInfo.push( {\n\n\t\t\t\tfrustum: new ExtendedFrustum(),\n\t\t\t\tisOrthographic: false,\n\t\t\t\tsseDenominator: - 1, // used if isOrthographic:false\n\t\t\t\tposition: new Vector3(),\n\t\t\t\tinvScale: - 1,\n\t\t\t\tpixelSize: 0, // used if isOrthographic:true\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// extract scale of group container\n\t\ttempVector.setFromMatrixScale( group.matrixWorldInverse );\n\t\tif ( Math.abs( Math.max( tempVector.x - tempVector.y, tempVector.x - tempVector.z ) ) > 1e-6 ) {\n\n\t\t\tconsole.warn( 'ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.' );\n\n\t\t}\n\n\t\t// store the camera cameraInfo in the 3d tiles root frame\n\t\tfor ( let i = 0, l = cameraInfo.length; i < l; i ++ ) {\n\n\t\t\tconst camera = cameras[ i ];\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tconst frustum = info.frustum;\n\t\t\tconst position = info.position;\n\t\t\tconst resolution = cameraMap.get( camera );\n\n\t\t\tif ( resolution.width === 0 || resolution.height === 0 ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: resolution for camera error calculation is not set.' );\n\n\t\t\t}\n\n\t\t\t// Read the calculated projection matrix directly to support custom Camera implementations\n\t\t\tconst projection = camera.projectionMatrix.elements;\n\n\t\t\t// The last element of the projection matrix is 1 for orthographic, 0 for perspective\n\t\t\tinfo.isOrthographic = projection[ 15 ] === 1;\n\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\t// See OrthographicCamera.updateProjectionMatrix and Matrix4.makeOrthographic:\n\t\t\t\t// the view width and height are used to populate matrix elements 0 and 5.\n\t\t\t\tconst w = 2 / projection[ 0 ];\n\t\t\t\tconst h = 2 / projection[ 5 ];\n\t\t\t\tinfo.pixelSize = Math.max( h / resolution.height, w / resolution.width );\n\n\t\t\t} else {\n\n\t\t\t\t// See PerspectiveCamera.updateProjectionMatrix and Matrix4.makePerspective:\n\t\t\t\t// the vertical FOV is used to populate matrix element 5.\n\t\t\t\tinfo.sseDenominator = ( 2 / projection[ 5 ] ) / resolution.height;\n\n\t\t\t}\n\n\t\t\t// get frustum in group root frame\n\t\t\ttempMat.copy( group.matrixWorld );\n\t\t\ttempMat.premultiply( camera.matrixWorldInverse );\n\t\t\ttempMat.premultiply( camera.projectionMatrix );\n\n\t\t\tfrustum.setFromProjectionMatrix( tempMat );\n\n\t\t\t// get transform position in group root frame\n\t\t\tposition.set( 0, 0, 0 );\n\t\t\tposition.applyMatrix4( camera.matrixWorld );\n\t\t\tposition.applyMatrix4( group.matrixWorldInverse );\n\n\t\t}\n\n\t\tsuper.update();\n\n\t\tthis.dispatchEvent( { type: 'update-after' } );\n\n\t\t// check for cameras _after_ base update so we can enable pre-loading the root tile set\n\t\tif ( cameras.length === 0 && this.root ) {\n\n\t\t\tlet found = false;\n\t\t\tthis.invokeAllPlugins( plugin => found = found || Boolean( plugin !== this && plugin.calculateTileViewError ) );\n\t\t\tif ( found === false ) {\n\n\t\t\t\tconsole.warn( 'TilesRenderer: no cameras defined. Cannot update 3d tiles.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, tileSetDir, parentTile = null ) {\n\n\t\tsuper.preprocessNode( tile, tileSetDir, parentTile );\n\n\t\tconst transform = new Matrix4();\n\t\tif ( tile.transform ) {\n\n\t\t\tconst transformArr = tile.transform;\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransform.elements[ i ] = transformArr[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parentTile ) {\n\n\t\t\ttransform.premultiply( parentTile.cached.transform );\n\n\t\t}\n\n\t\tconst transformInverse = new Matrix4().copy( transform ).invert();\n\t\tconst boundingVolume = new TileBoundingVolume();\n\t\tif ( 'sphere' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setSphereData( ...tile.boundingVolume.sphere, transform );\n\n\t\t}\n\n\t\tif ( 'box' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setObbData( tile.boundingVolume.box, transform );\n\n\t\t}\n\n\t\tif ( 'region' in tile.boundingVolume ) {\n\n\t\t\tboundingVolume.setRegionData( this.ellipsoid, ...tile.boundingVolume.region );\n\n\t\t}\n\n\t\ttile.cached = {\n\n\t\t\ttransform,\n\t\t\ttransformInverse,\n\n\t\t\tactive: false,\n\n\t\t\tboundingVolume,\n\n\t\t\tmetadata: null,\n\t\t\tscene: null,\n\t\t\tgeometry: null,\n\t\t\tmaterials: null,\n\t\t\ttextures: null,\n\n\t\t};\n\n\t}\n\n\tasync parseTile( buffer, tile, extension, uri, abortSignal ) {\n\n\t\tconst cached = tile.cached;\n\t\tconst uriSplits = uri.split( /[\\\\/]/g );\n\t\turiSplits.pop();\n\t\tconst workingPath = uriSplits.join( '/' );\n\t\tconst fetchOptions = this.fetchOptions;\n\n\t\tconst manager = this.manager;\n\t\tlet promise = null;\n\n\t\tconst cachedTransform = cached.transform;\n\t\tconst upRotationMatrix = this._upRotationMatrix;\n\t\tconst fileType = ( readMagicBytes( buffer ) || extension ).toLowerCase();\n\t\tswitch ( fileType ) {\n\n\t\t\tcase 'b3dm': {\n\n\t\t\t\tconst loader = new B3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'pnts': {\n\n\t\t\t\tconst loader = new PNTSLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'i3dm': {\n\n\t\t\t\tconst loader = new I3DMLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader.parse( buffer );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcase 'cmpt': {\n\n\t\t\t\tconst loader = new CMPTLoader( manager );\n\t\t\t\tloader.workingPath = workingPath;\n\t\t\t\tloader.fetchOptions = fetchOptions;\n\n\t\t\t\tloader.adjustmentTransform.copy( upRotationMatrix );\n\t\t\t\tloader.ellipsoid.copy( this.ellipsoid );\n\n\t\t\t\tpromise = loader\n\t\t\t\t\t.parse( buffer )\n\t\t\t\t\t.then( res => res.scene\t);\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// 3DTILES_content_gltf\n\t\t\tcase 'gltf':\n\t\t\tcase 'glb': {\n\n\t\t\t\tconst loader = manager.getHandler( 'path.gltf' ) || manager.getHandler( 'path.glb' ) || new GLTFLoader( manager );\n\t\t\t\tloader.setWithCredentials( fetchOptions.credentials === 'include' );\n\t\t\t\tloader.setRequestHeader( fetchOptions.headers || {} );\n\t\t\t\tif ( fetchOptions.credentials === 'include' && fetchOptions.mode === 'cors' ) {\n\n\t\t\t\t\tloader.setCrossOrigin( 'use-credentials' );\n\n\t\t\t\t}\n\n\t\t\t\t// assume any pre-registered loader has paths configured as the user desires, but if we're making\n\t\t\t\t// a new loader, use the working path during parse to support relative uris on other hosts\n\t\t\t\tlet resourcePath = loader.resourcePath || loader.path || workingPath;\n\t\t\t\tif ( ! /[\\\\/]$/.test( resourcePath ) && resourcePath.length ) {\n\n\t\t\t\t\tresourcePath += '/';\n\n\t\t\t\t}\n\n\t\t\t\tpromise = loader.parseAsync( buffer, resourcePath ).then( result => {\n\n\t\t\t\t\t// glTF files are not guaranteed to include a scene object\n\t\t\t\t\tresult.scene = result.scene || new Group();\n\n\t\t\t\t\t// apply the local up-axis correction rotation\n\t\t\t\t\t// GLTFLoader seems to never set a transformation on the root scene object so\n\t\t\t\t\t// any transformations applied to it can be assumed to be applied after load\n\t\t\t\t\t// (such as applying RTC_CENTER) meaning they should happen _after_ the z-up\n\t\t\t\t\t// rotation fix which is why \"multiply\" happens here.\n\t\t\t\t\tconst { scene } = result;\n\t\t\t\t\tscene.updateMatrix();\n\t\t\t\t\tscene.matrix\n\t\t\t\t\t\t.multiply( upRotationMatrix )\n\t\t\t\t\t\t.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t\t\t\treturn result;\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tdefault: {\n\n\t\t\t\tpromise = this.invokeOnePlugin( plugin => plugin.parseToMesh && plugin.parseToMesh( buffer, tile, extension, uri, abortSignal ) );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// wait for the tile to load\n\t\tconst result = await promise;\n\t\tif ( result === null ) {\n\n\t\t\tthrow new Error( `TilesRenderer: Content type \"${ fileType }\" not supported.` );\n\n\t\t}\n\n\t\t// get the scene data\n\t\tlet scene;\n\t\tlet metadata;\n\t\tif ( result.isObject3D ) {\n\n\t\t\tscene = result;\n\t\t\tmetadata = null;\n\n\t\t} else {\n\n\t\t\tscene = result.scene;\n\t\t\tmetadata = result;\n\n\t\t}\n\n\t\t// ensure the matrix is up to date in case the scene has a transform applied\n\t\tscene.updateMatrix();\n\t\tscene.matrix.premultiply( cachedTransform );\n\t\tscene.matrix.decompose( scene.position, scene.quaternion, scene.scale );\n\n\t\t// wait for extra processing by plugins if needed\n\t\tawait this.invokeAllPlugins( plugin => {\n\n\t\t\treturn plugin.processTileModel && plugin.processTileModel( scene, tile );\n\n\t\t} );\n\n\t\t// frustum culling\n\t\tscene.traverse( c => {\n\n\t\t\tc[ INITIAL_FRUSTUM_CULLED ] = c.frustumCulled;\n\n\t\t} );\n\t\tupdateFrustumCulled( scene, ! this.autoDisableRendererCulling );\n\n\t\t// collect all original geometries, materials, etc to be disposed of later\n\t\tconst materials = [];\n\t\tconst geometry = [];\n\t\tconst textures = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.geometry ) {\n\n\t\t\t\tgeometry.push( c.geometry );\n\n\t\t\t}\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tmaterials.push( c.material );\n\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// exit early if a new request has already started\n\t\tif ( abortSignal.aborted ) {\n\n\t\t\t// dispose of any image bitmaps that have been opened.\n\t\t\t// TODO: share this code with the \"disposeTile\" code below, possibly allow for the tiles\n\t\t\t// renderer base to trigger a disposal of unneeded data\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tcached.materials = materials;\n\t\tcached.geometry = geometry;\n\t\tcached.textures = textures;\n\t\tcached.scene = scene;\n\t\tcached.metadata = metadata;\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tsuper.disposeTile( tile );\n\n\t\t// This could get called before the tile has finished downloading\n\t\tconst cached = tile.cached;\n\t\tif ( cached.scene ) {\n\n\t\t\tconst materials = cached.materials;\n\t\t\tconst geometry = cached.geometry;\n\t\t\tconst textures = cached.textures;\n\t\t\tconst parent = cached.scene.parent;\n\n\t\t\t// dispose of any textures required by the mesh features extension\n\t\t\t// TODO: these are being discarded here to remove the image bitmaps -\n\t\t\t// can this be handled in another way? Or more generically?\n\t\t\tcached.scene.traverse( child => {\n\n\t\t\t\tif ( child.userData.meshFeatures ) {\n\n\t\t\t\t\tchild.userData.meshFeatures.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tif ( child.userData.structuralMetadata ) {\n\n\t\t\t\t\tchild.userData.structuralMetadata.dispose();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tfor ( let i = 0, l = geometry.length; i < l; i ++ ) {\n\n\t\t\t\tgeometry[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterials[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tparent.remove( cached.scene );\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( {\n\t\t\t\ttype: 'dispose-model',\n\t\t\t\tscene: cached.scene,\n\t\t\t\ttile,\n\t\t\t} );\n\n\t\t\tcached.scene = null;\n\t\t\tcached.materials = null;\n\t\t\tcached.textures = null;\n\t\t\tcached.geometry = null;\n\t\t\tcached.metadata = null;\n\n\t\t}\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.cached.scene;\n\t\tconst group = this.group;\n\n\t\tif ( visible ) {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.add( scene );\n\t\t\t\tscene.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( scene ) {\n\n\t\t\t\tgroup.remove( scene );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsuper.setTileVisible( tile, visible );\n\n\t\tthis.dispatchEvent( {\n\t\t\ttype: 'tile-visibility-change',\n\t\t\tscene,\n\t\t\ttile,\n\t\t\tvisible,\n\t\t} );\n\n\t}\n\n\tcalculateBytesUsed( tile, scene ) {\n\n\t\tconst bytesUsed = this._bytesUsed;\n\t\tif ( ! bytesUsed.has( tile ) && scene ) {\n\n\t\t\tbytesUsed.set( tile, estimateBytesUsed( scene ) );\n\n\t\t}\n\n\t\treturn bytesUsed.get( tile ) ?? null;\n\n\t}\n\n\tcalculateTileViewError( tile, target ) {\n\n\t\tconst cached = tile.cached;\n\t\tconst cameras = this.cameras;\n\t\tconst cameraInfo = this.cameraInfo;\n\t\tconst boundingVolume = cached.boundingVolume;\n\n\t\tlet inView = false;\n\t\tlet inViewError = - Infinity;\n\t\tlet inViewDistance = Infinity;\n\t\tlet maxError = - Infinity;\n\t\tlet minDistance = Infinity;\n\n\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t// calculate the camera error\n\t\t\tconst info = cameraInfo[ i ];\n\t\t\tlet error;\n\t\t\tlet distance;\n\t\t\tif ( info.isOrthographic ) {\n\n\t\t\t\tconst pixelSize = info.pixelSize;\n\t\t\t\terror = tile.geometricError / pixelSize;\n\t\t\t\tdistance = Infinity;\n\n\t\t\t} else {\n\n\t\t\t\t// avoid dividing 0 by 0 which can result in NaN. If the distance to the tile is\n\t\t\t\t// 0 then the error should be infinity.\n\t\t\t\tconst sseDenominator = info.sseDenominator;\n\t\t\t\tdistance = boundingVolume.distanceToPoint( info.position );\n\t\t\t\terror = distance === 0 ? Infinity : tile.geometricError / ( distance * sseDenominator );\n\n\t\t\t}\n\n\t\t\t// Track which camera frustums this tile is in so we can use it\n\t\t\t// to ignore the error calculations for cameras that can't see it\n\t\t\tconst frustum = cameraInfo[ i ].frustum;\n\t\t\tif ( boundingVolume.intersectsFrustum( frustum ) ) {\n\n\t\t\t\tinView = true;\n\t\t\t\tinViewError = Math.max( inViewError, error );\n\t\t\t\tinViewDistance = Math.min( inViewDistance, distance );\n\n\t\t\t}\n\n\t\t\tmaxError = Math.max( maxError, error );\n\t\t\tminDistance = Math.min( minDistance, distance );\n\n\t\t}\n\n\t\t// check the plugin visibility\n\t\tthis.invokeAllPlugins( plugin => {\n\n\t\t\tif ( plugin !== this && plugin.calculateTileViewError ) {\n\n\t\t\t\tplugin.calculateTileViewError( tile, viewErrorTarget );\n\t\t\t\tif ( viewErrorTarget.inView ) {\n\n\t\t\t\t\tinView = true;\n\t\t\t\t\tinViewError = Math.max( inViewError, viewErrorTarget.error );\n\n\t\t\t\t}\n\n\t\t\t\tmaxError = Math.max( maxError, viewErrorTarget.error );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// If the tiles are out of view then use the global distance and error calculated\n\t\tif ( inView ) {\n\n\t\t\ttarget.inView = true;\n\t\t\ttarget.error = inViewError;\n\t\t\ttarget.distanceFromCamera = inViewDistance;\n\n\t\t} else {\n\n\t\t\ttarget.inView = false;\n\t\t\ttarget.error = maxError;\n\t\t\ttarget.distanceFromCamera = minDistance;\n\n\t\t}\n\n\t}\n\n\t// adjust the rotation of the group such that Y is altitude, X is North, and Z is East\n\tsetLatLonToYUp( lat, lon ) {\n\n\t\tconsole.warn( 'TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.' );\n\n\t\tconst { ellipsoid, group } = this;\n\n\t\t_euler.set( Math.PI / 2, Math.PI / 2, 0 );\n\t\t_mat.makeRotationFromEuler( _euler );\n\n\t\tellipsoid.getEastNorthUpFrame( lat, lon, 0, group.matrix )\n\t\t\t.multiply( _mat )\n\t\t\t.invert()\n\t\t\t.decompose(\n\t\t\t\tgroup.position,\n\t\t\t\tgroup.quaternion,\n\t\t\t\tgroup.scale,\n\t\t\t);\n\n\t\tgroup.updateMatrixWorld( true );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.group.removeFromParent();\n\n\t}\n\n}\n"],"names":["getUrlExtension","url","filename","lastPeriod","GIGABYTE_BYTES","LRUCache","cb","a","b","valA","valB","itemSet","item","bytes","bytesMap","removeCb","usedSet","itemList","callbacks","loadedSet","index","value","unloadPercent","minSize","maxSize","minBytesSize","maxBytesSize","unused","unloaded","excessNodes","excessBytes","unloadPriorityCallback","needsRerun","hasNodesToUnload","usedA","usedB","loadedA","loadedB","maxUnload","nodesToUnload","maxBytesUnload","bytesToUnload","removedNodes","removedBytes","PriorityQueue","func","priorityCallback","items","callback","data","resolve","reject","info","filter","i","maxJobs","iterated","completedCallback","result","err","viewErrorTarget","LOAD_ROOT_SIBLINGS","isDownloadFinished","LOADED","FAILED","isUsedThisFrame","tile","frameCount","areChildrenProcessed","resetFrameState","renderer","recursivelyMarkUsed","markUsed","children","l","recursivelyLoadNextRenderableTiles","canTraverse","traverseSet","beforeCb","afterCb","stack","depth","parent","markUsedTiles","anyChildrenUsed","anyChildrenInFrustum","c","markUsedSetLeaves","allChildrenLoaded","childLoaded","markVisibleTiles","stats","hasContent","loadedContent","errorRequirement","meetsSSE","isAdditiveRefine","toggleTiles","isUsed","setActive","setVisible","plugin","traverseAncestors","current","throttle","handle","PLUGIN_REGISTERED","aPriority","bPriority","lruPriorityCallback","TilesRendererBase","tileSet","isLoading","loading","total","v","UNLOADED","lruCache","downloadQueue","parseQueue","processNodeQueue","plugins","priority","insertionPoint","name","p","beforecb","aftercb","ensureFullyProcessed","args","root","LOADING","processedUrl","error","queuedTiles","toRemove","t","scene","options","buffer","extension","tileSetDir","parentTile","_a","active","visible","target","immediate","child","processedTiles","json","version","major","minor","basePath","res","isExternalTileSet","externalTileset","uri","controller","signal","PARSING","downloadTile","content","parseTile","bytesUsed","pending","tempMat","Matrix4","TilesGroup","Group","tilesRenderer","raycaster","intersects","force","elA","elB","isDifferent","itemA","itemB","updateParents","updateChildren","_localRay","Ray","_vec","Vector3","_hitArray","distanceSort","intersectTileScene","intersectTileSceneFirstHist","hit","isTileInitialized","raycastTraverseFirstHit","localRay","group","activeTiles","array","bestHit","bestHitDistSq","boundingVolumeDistSq","hitDistSq","raycastTraverse","boundingVolume","_worldMin","_worldMax","_norm","_ray","OBB","box","Box3","transform","Plane","source","point","ray","points","inverseTransform","min","max","x","y","z","sphere","frustum","obb","otherPlanes","otherPoints","thisPoints","thisPlanes","plane","maxDistance","j","dist","_vecX","_vecY","_vecZ","_sphereVec","_obbVec","TileBoundingVolume","sphereDistSq","obbDistSq","furthestDist","sphereDistance","obbDistance","otherSphere","otherObb","targetBox","targetMatrix","scaleX","scaleY","scaleZ","radius","Sphere","ellipsoid","west","south","east","north","minHeight","maxHeight","region","EllipsoidRegion","_mat3","Matrix3","findIntersectionPoint","plane1","plane2","plane3","A","ExtendedFrustum","Frustum","m","coordinateSystem","planes","safeTextureGetByteLength","tex","TextureUtils","THREE","format","type","image","width","height","estimateBytesUsed","object","dedupeSet","totalBytes","_estimateBytesUsed","material","key","_mat","_euler","Euler","INITIAL_FRUSTUM_CULLED","tempVector","tempVector2","Vector2","X_AXIS","Y_AXIS","updateFrustumCulled","toInitialValue","TilesRenderer","WGS84_ELLIPSOID","manager","LoadingManager","EventDispatcher","camera","cameras","cameraMap","xOrVec","cameraVec","asset","extensions","ext","needsUpdate","cameraInfo","position","resolution","projection","w","h","found","transformArr","transformInverse","abortSignal","cached","uriSplits","workingPath","fetchOptions","promise","cachedTransform","upRotationMatrix","fileType","readMagicBytes","loader","B3DMLoader","PNTSLoader","I3DMLoader","CMPTLoader","GLTFLoader","resourcePath","metadata","materials","geometry","textures","texture","inView","inViewError","inViewDistance","maxError","minDistance","distance","pixelSize","sseDenominator","lat","lon"],"mappings":"shBAKO,SAASA,GAAiBC,EAAM,CAEtC,GAAK,CAAEA,EAEN,OAAO,KAIR,MAAMC,EAAWD,EACf,QAAS,oBAAqB,EAAI,EAClC,QAAS,SAAU,EAAI,EACvB,QAAS,QAAS,IAEdE,EAAaD,EAAS,YAAa,GAAK,EAC9C,OAAKC,IAAe,GAEZ,KAIDD,EAAS,UAAWC,EAAa,CAAG,GAAI,IAEhD,CC3BA,MAAMC,GAAiB,GAAK,GAE5B,MAAMC,EAAS,CAEd,IAAI,wBAAyB,CAE5B,OAAO,KAAK,uBAEd,CAEC,IAAI,uBAAwBC,EAAK,CAE3BA,EAAG,SAAW,GAElB,QAAQ,KAAM,qFAAuF,EACrG,KAAK,wBAA0B,CAAEC,EAAGC,IAAO,CAE1C,MAAMC,EAAOH,EAAIC,CAAG,EACdG,EAAOJ,EAAIE,CAAG,EAEpB,OAAKC,EAAOC,EAAc,GACrBD,EAAOC,EAAc,EACnB,CAEP,GAID,KAAK,wBAA0BJ,CAIlC,CAEC,aAAc,CAGb,KAAK,QAAU,IACf,KAAK,QAAU,IACf,KAAK,aAAe,GAAMF,GAC1B,KAAK,aAAe,GAAMA,GAC1B,KAAK,cAAgB,IACrB,KAAK,eAAiB,GAKtB,KAAK,QAAU,IAAI,IACnB,KAAK,SAAW,CAAE,EAClB,KAAK,QAAU,IAAI,IACnB,KAAK,UAAY,IAAI,IACrB,KAAK,gBAAkB,GACvB,KAAK,YAAc,EACnB,KAAK,SAAW,IAAI,IACpB,KAAK,UAAY,IAAI,IAErB,KAAK,wBAA0B,KAE/B,MAAMO,EAAU,KAAK,QACrB,KAAK,wBAA0BC,GAAQD,EAAQ,IAAKC,CAAM,CAE5D,CAGC,QAAS,CAER,OAAO,KAAK,QAAQ,MAAQ,KAAK,SAAW,KAAK,aAAe,KAAK,YAEvE,CAEC,eAAgBA,EAAO,CAEtB,OAAO,KAAK,SAAS,IAAKA,CAAM,GAAI,CAEtC,CAEC,eAAgBA,EAAMC,EAAQ,CAE7B,KAAM,CAAE,SAAAC,EAAU,QAAAH,CAAO,EAAK,KACvBA,EAAQ,IAAKC,KAMpB,KAAK,aAAeE,EAAS,IAAKF,CAAM,GAAI,EAC5CE,EAAS,IAAKF,EAAMC,CAAO,EAC3B,KAAK,aAAeA,EAEtB,CAEC,IAAKD,EAAMG,EAAW,CAErB,MAAMJ,EAAU,KAAK,QAOrB,GANKA,EAAQ,IAAKC,IAMb,KAAK,SAET,MAAO,GAIR,MAAMI,EAAU,KAAK,QACfC,EAAW,KAAK,SAChBC,EAAY,KAAK,UACvB,OAAAD,EAAS,KAAML,CAAM,EACrBI,EAAQ,IAAKJ,CAAM,EACnBD,EAAQ,IAAKC,EAAM,KAAK,IAAG,CAAI,EAC/BM,EAAU,IAAKN,EAAMG,CAAU,EAExB,EAET,CAEC,IAAKH,EAAO,CAEX,OAAO,KAAK,QAAQ,IAAKA,CAAM,CAEjC,CAEC,OAAQA,EAAO,CAEd,MAAMI,EAAU,KAAK,QACfL,EAAU,KAAK,QACfM,EAAW,KAAK,SAChBH,EAAW,KAAK,SAChBI,EAAY,KAAK,UACjBC,EAAY,KAAK,UAEvB,GAAKR,EAAQ,IAAKC,GAAS,CAE1B,KAAK,aAAeE,EAAS,IAAKF,CAAM,GAAI,EAC5CE,EAAS,OAAQF,CAAM,EAEvBM,EAAU,IAAKN,CAAM,EAAEA,CAAM,EAE7B,MAAMQ,EAAQH,EAAS,QAASL,CAAM,EACtC,OAAAK,EAAS,OAAQG,EAAO,CAAG,EAC3BJ,EAAQ,OAAQJ,CAAM,EACtBD,EAAQ,OAAQC,CAAM,EACtBM,EAAU,OAAQN,CAAM,EACxBO,EAAU,OAAQP,CAAM,EAEjB,EAEV,CAEE,MAAO,EAET,CAKC,UAAWA,EAAMS,EAAQ,CAExB,KAAM,CAAE,QAAAV,EAAS,UAAAQ,CAAS,EAAK,KAC1BR,EAAQ,IAAKC,KAEZS,IAAU,GAEdF,EAAU,IAAKP,CAAM,EAIrBO,EAAU,OAAQP,CAAM,EAM5B,CAEC,SAAUA,EAAO,CAEhB,MAAMD,EAAU,KAAK,QACfK,EAAU,KAAK,QAChBL,EAAQ,IAAKC,CAAI,GAAM,CAAEI,EAAQ,IAAKJ,KAE1CD,EAAQ,IAAKC,EAAM,KAAK,IAAG,CAAI,EAC/BI,EAAQ,IAAKJ,CAAM,EAItB,CAEC,WAAYA,EAAO,CAElB,KAAK,QAAQ,OAAQA,CAAM,CAE7B,CAEC,eAAgB,CAEf,KAAK,QAAQ,MAAO,CAEtB,CAIC,qBAAsB,CAErB,KAAM,CACL,cAAAU,EACA,QAAAC,EACA,QAAAC,EACA,SAAAP,EACA,QAAAN,EACA,QAAAK,EACA,UAAAG,EACA,UAAAD,EACA,SAAAJ,EACA,aAAAW,EACA,aAAAC,CACH,EAAM,KAEEC,EAASV,EAAS,OAASD,EAAQ,KACnCY,EAAWX,EAAS,OAASE,EAAU,KACvCU,EAAc,KAAK,IAAK,KAAK,IAAKZ,EAAS,OAASM,EAASI,CAAM,EAAI,CAAG,EAC1EG,EAAc,KAAK,YAAcL,EACjCM,EAAyB,KAAK,wBAA0B,KAAK,wBACnE,IAAIC,EAAa,GAEjB,MAAMC,EAAmBJ,EAAc,GAAKF,EAAS,GAAKC,GAAYX,EAAS,OAASO,EAExF,GADyBG,GAAU,KAAK,YAAcF,GAAgBG,GAAY,KAAK,YAAcF,GAC5EO,EAAmB,CAG3ChB,EAAS,KAAM,CAAEV,EAAGC,IAAO,CAE1B,MAAM0B,GAAQlB,EAAQ,IAAKT,CAAG,EACxB4B,GAAQnB,EAAQ,IAAKR,CAAG,EAC9B,GAAK0B,KAAUC,GAAQ,CAEtB,MAAMC,GAAUjB,EAAU,IAAKZ,CAAG,EAC5B8B,GAAUlB,EAAU,IAAKX,CAAG,EAClC,OAAK4B,KAAYC,GAIT,CAAEN,EAAwBxB,EAAGC,CAAG,EAIhC4B,GAAU,EAAI,EAI3B,KAGK,QAAOF,GAAQ,EAAI,EAIxB,CAAM,EAIH,MAAMI,EAAY,KAAK,IAAKf,EAAUD,EAAeO,EAAcP,CAAe,EAC5EiB,EAAgB,KAAK,KAAM,KAAK,IAAKD,EAAWX,EAAQE,EAAe,EACvEW,EAAiB,KAAK,IAAKlB,EAAgBQ,EAAaR,EAAgBG,CAAc,EACtFgB,EAAgB,KAAK,IAAKD,EAAgBV,CAAa,EAE7D,IAAIY,EAAe,EACfC,EAAe,EAInB,KACC,KAAK,YAAcA,EAAejB,GAClCT,EAAS,OAASyB,EAAelB,GAChC,CAED,MAAMZ,EAAOK,EAAUyB,CAAc,EAC/B7B,EAAQC,EAAS,IAAKF,CAAM,GAAI,EACtC,GACCI,EAAQ,IAAKJ,CAAI,GAAMO,EAAU,IAAKP,CAAM,GAC5C,KAAK,YAAc+B,EAAe9B,EAAQa,GAC1CT,EAAS,OAASyB,GAAgBlB,EAGlC,MAIDmB,GAAgB9B,EAChB6B,GAEJ,CAIG,KACCC,EAAeF,GACfC,EAAeH,GACd,CAED,MAAM3B,EAAOK,EAAUyB,CAAc,EAC/B7B,EAAQC,EAAS,IAAKF,CAAM,GAAI,EACtC,GACCI,EAAQ,IAAKJ,CAAM,GACnB,KAAK,YAAc+B,EAAe9B,EAAQY,GAC1CiB,GAAgBH,EAGhB,MAIDI,GAAgB9B,EAChB6B,GAEJ,CAGGzB,EAAS,OAAQ,EAAGyB,CAAY,EAAG,QAAS9B,GAAQ,CAEnD,KAAK,aAAeE,EAAS,IAAKF,CAAM,GAAI,EAE5CM,EAAU,IAAKN,CAAM,EAAEA,CAAM,EAC7BE,EAAS,OAAQF,CAAM,EACvBD,EAAQ,OAAQC,CAAM,EACtBM,EAAU,OAAQN,CAAM,EACxBO,EAAU,OAAQP,CAAM,EACxBI,EAAQ,OAAQJ,CAAM,CAE1B,CAAM,EAIHoB,EAAaU,EAAeb,GAAec,EAAeb,GAAeY,EAAef,EACxFK,EAAaA,GAAcU,EAAe,CAE7C,CAEOV,IAEJ,KAAK,gBAAkB,sBAAuB,IAAM,KAAK,eAAc,CAAI,EAI9E,CAEC,gBAAiB,CAEhB,qBAAsB,KAAK,eAAiB,EAErC,KAAK,YAEX,KAAK,UAAY,GACjB,eAAgB,IAAM,CAErB,KAAK,UAAY,GACjB,KAAK,oBAAqB,CAE9B,CAAM,EAIN,CAEA,CC9WA,MAAMY,CAAc,CAGnB,IAAI,SAAU,CAEb,OAAO,KAAK,MAAM,SAAW,GAAK,KAAK,WAAa,CAEtD,CAEC,aAAc,CAGb,KAAK,QAAU,EAEf,KAAK,MAAQ,CAAE,EACf,KAAK,UAAY,IAAI,IACrB,KAAK,SAAW,EAChB,KAAK,UAAY,GACjB,KAAK,WAAa,GAElB,KAAK,iBAAmB,KAGxB,KAAK,mBAAqBC,GAAQ,CAEjC,sBAAuBA,CAAM,CAE7B,EAED,KAAK,SAAW,IAAM,CAErB,KAAK,UAAY,GACjB,KAAK,WAAY,CAEjB,CAEH,CAEC,MAAO,CAEN,MAAMC,EAAmB,KAAK,iBACxBC,EAAQ,KAAK,MACdD,IAAqB,MAEzBC,EAAM,KAAMD,CAAkB,CAIjC,CAEC,IAAKlC,EAAO,CAEX,OAAO,KAAK,UAAU,IAAKA,CAAM,CAEnC,CAEC,IAAKA,EAAMoC,EAAW,CAErB,MAAMC,EAAO,CACZ,SAAAD,EACA,OAAQ,KACR,QAAS,KACT,QAAS,IACT,EAED,OAAAC,EAAK,QAAU,IAAI,QAAS,CAAEC,EAASC,IAAY,CAElD,MAAMJ,EAAQ,KAAK,MACb7B,EAAY,KAAK,UAEvB+B,EAAK,QAAUC,EACfD,EAAK,OAASE,EAEdJ,EAAM,QAASnC,CAAM,EACrBM,EAAU,IAAKN,EAAMqC,CAAM,EAEtB,KAAK,YAET,KAAK,eAAgB,CAIzB,CAAK,EAEIA,EAAK,OAEd,CAEC,OAAQrC,EAAO,CAEd,MAAMmC,EAAQ,KAAK,MACb7B,EAAY,KAAK,UAEjBE,EAAQ2B,EAAM,QAASnC,CAAM,EACnC,GAAKQ,IAAU,GAAM,CAKpB,MAAMgC,EAAOlC,EAAU,IAAKN,CAAM,EAClCwC,EAAK,QAAQ,MAAO,IAAM,EAAI,EAC9BA,EAAK,OAAQ,IAAI,MAAO,8BAA8B,CAAI,EAE1DL,EAAM,OAAQ3B,EAAO,CAAG,EACxBF,EAAU,OAAQN,CAAM,CAE3B,CAEA,CAEC,eAAgByC,EAAS,CAExB,KAAM,CAAE,MAAAN,CAAK,EAAK,KAClB,QAAUO,EAAI,EAAGA,EAAIP,EAAM,OAAQO,IAAO,CAEzC,MAAM1C,EAAOmC,EAAOO,CAAG,EAClBD,EAAQzC,IAEZ,KAAK,OAAQA,CAAM,CAIvB,CAEA,CAEC,YAAa,CAEZ,KAAK,KAAM,EAEX,MAAMmC,EAAQ,KAAK,MACb7B,EAAY,KAAK,UACjBqC,EAAU,KAAK,QACrB,IAAIC,EAAW,EAEf,MAAMC,EAAoB,IAAM,CAE/B,KAAK,WAEA,KAAK,YAET,KAAK,eAAgB,CAItB,EAED,KAAQF,EAAU,KAAK,UAAYR,EAAM,OAAS,GAAKS,EAAWD,GAAU,CAE3E,KAAK,WACLC,IACA,MAAM5C,EAAOmC,EAAM,IAAK,EAClB,CAAE,SAAAC,EAAU,QAAAE,EAAS,OAAAC,CAAQ,EAAGjC,EAAU,IAAKN,CAAM,EAC3DM,EAAU,OAAQN,CAAM,EAExB,IAAI8C,EACJ,GAAI,CAEHA,EAASV,EAAUpC,CAAM,CAEzB,OAAS+C,EAAM,CAEfR,EAAQQ,CAAK,EACbF,EAAmB,CAEvB,CAEQC,aAAkB,QAEtBA,EACE,KAAMR,CAAO,EACb,MAAOC,CAAM,EACb,QAASM,CAAmB,GAI9BP,EAASQ,CAAQ,EACjBD,EAAmB,EAIvB,CAEA,CAEC,gBAAiB,CAET,KAAK,YAEX,KAAK,mBAAoB,KAAK,QAAU,EAExC,KAAK,UAAY,GAIpB,CAEA,CCnMA,MAAMG,EAAkB,CACvB,OAAQ,GACR,MAAO,IACP,mBAAoB,GACrB,EAMMC,GAAqB,GAE3B,SAASC,GAAoBzC,EAAQ,CAEpC,OAAOA,IAAU0C,GAAU1C,IAAU2C,CAEtC,CAGA,SAASC,EAAiBC,EAAMC,EAAa,CAE5C,OAAOD,EAAK,qBAAuBC,GAAcD,EAAK,MAEvD,CAEA,SAASE,GAAsBF,EAAO,CAErC,OAAOA,EAAK,sBAAwBA,EAAK,SAAS,MAEnD,CAGA,SAASG,GAAiBH,EAAMI,EAAW,CAErCJ,EAAK,qBAAuBI,EAAS,aAEzCJ,EAAK,mBAAqBI,EAAS,WACnCJ,EAAK,OAAS,GACdA,EAAK,YAAc,GACnBA,EAAK,SAAW,GAChBA,EAAK,UAAY,GACjBA,EAAK,SAAW,GAChBA,EAAK,QAAU,IACfA,EAAK,qBAAuB,IAC5BA,EAAK,oBAAsB,GAG3BI,EAAS,uBAAwBJ,EAAMN,CAAiB,EACxDM,EAAK,YAAcN,EAAgB,OACnCM,EAAK,QAAUN,EAAgB,MAC/BM,EAAK,qBAAuBN,EAAgB,mBAI9C,CAGA,SAASW,GAAqBL,EAAMI,EAAW,CAS9C,GAPAA,EAAS,8BAA+BJ,CAAM,EAE9CG,GAAiBH,EAAMI,CAAU,EACjCE,EAAUN,EAAMI,CAAU,EAIrBJ,EAAK,0BAA4BE,GAAsBF,CAAI,EAAK,CAEpE,MAAMO,EAAWP,EAAK,SACtB,QAAUZ,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAE5CiB,GAAqBE,EAAUnB,CAAG,EAAEgB,CAAU,CAIjD,CAEA,CAGA,SAASK,GAAoCT,EAAMI,EAAW,CAK7D,GAHAA,EAAS,8BAA+BJ,CAAM,EAGzCD,EAAiBC,EAAMI,EAAS,UAAU,IAGzCJ,EAAK,cAETI,EAAS,qBAAsBJ,CAAM,EAIjCE,GAAsBF,IAAS,CAGnC,MAAMO,EAAWP,EAAK,SACtB,QAAUZ,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAE5CqB,GAAoCF,EAAUnB,CAAG,EAAEgB,CAAU,CAIjE,CAIA,CAGA,SAASE,EAAUN,EAAMI,EAAW,CAE9BJ,EAAK,SAMVA,EAAK,OAAS,GACdI,EAAS,aAAcJ,CAAM,EAC7BI,EAAS,MAAM,OAEVJ,EAAK,cAAgB,IAEzBI,EAAS,MAAM,YAIjB,CAGA,SAASM,GAAaV,EAAMI,EAAW,CAkBtC,MAdK,EAAAJ,EAAK,SAAWI,EAAS,aAAe,CAAEJ,EAAK,0BAO/CI,EAAS,SAAW,GAAKJ,EAAK,QAAU,GAAKI,EAAS,UAOtD,CAAEF,GAAsBF,GAQ9B,CAIO,SAASW,GAAaX,EAAMY,EAAW,KAAMC,EAAU,KAAO,CAEpE,MAAMC,EAAQ,CAAE,EAShB,IAJAA,EAAM,KAAMd,CAAM,EAClBc,EAAM,KAAM,IAAM,EAClBA,EAAM,KAAM,CAAG,EAEPA,EAAM,OAAS,GAAI,CAE1B,MAAMC,EAAQD,EAAM,IAAK,EACnBE,EAASF,EAAM,IAAK,EACpBd,EAAOc,EAAM,IAAK,EAExB,GAAKF,GAAYA,EAAUZ,EAAMgB,EAAQD,CAAK,EAAK,CAE7CF,GAEJA,EAASb,EAAMgB,EAAQD,CAAO,EAI/B,MAEH,CAEE,MAAMR,EAAWP,EAAK,SAGtB,GAAKO,EAEJ,QAAUnB,EAAImB,EAAS,OAAS,EAAGnB,GAAK,EAAGA,IAE1C0B,EAAM,KAAMP,EAAUnB,EAAK,EAC3B0B,EAAM,KAAMd,CAAM,EAClBc,EAAM,KAAMC,EAAQ,CAAG,EAMpBF,GAEJA,EAASb,EAAMgB,EAAQD,CAAO,CAIjC,CAEA,CAGO,SAASE,GAAejB,EAAMI,EAAW,CAQ/C,GAJAA,EAAS,8BAA+BJ,CAAM,EAE9CG,GAAiBH,EAAMI,CAAU,EAE5B,CAAEJ,EAAK,YAEX,OAID,GAAK,CAAEU,GAAaV,EAAMI,GAAa,CAEtCE,EAAUN,EAAMI,CAAU,EAC1B,MAEF,CAGC,IAAIc,EAAkB,GAClBC,EAAuB,GAC3B,MAAMZ,EAAWP,EAAK,SACtB,QAAUZ,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAAO,CAEnD,MAAMgC,EAAIb,EAAUnB,CAAG,EACvB6B,GAAeG,EAAGhB,CAAU,EAC5Bc,EAAkBA,GAAmBnB,EAAiBqB,EAAGhB,EAAS,UAAY,EAC9Ee,EAAuBA,GAAwBC,EAAE,WAEnD,CA0BC,GAJAd,EAAUN,EAAMI,CAAU,EAIrBc,GAAmBlB,EAAK,SAAW,YAAeA,EAAK,UAAY,GAAKL,IAE5E,QAAUP,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAAO,CAEnD,MAAMgC,EAAIb,EAAUnB,CAAG,EACvBiB,GAAqBe,EAAGhB,CAAU,CAErC,CAIA,CAGO,SAASiB,GAAmBrB,EAAMI,EAAW,CAEnD,MAAMH,EAAaG,EAAS,WAC5B,GAAK,CAAEL,EAAiBC,EAAMC,GAE7B,OAKD,MAAMM,EAAWP,EAAK,SACtB,IAAIkB,EAAkB,GACtB,QAAU9B,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAAO,CAEnD,MAAMgC,EAAIb,EAAUnB,CAAG,EACvB8B,EAAkBA,GAAmBnB,EAAiBqB,EAAGnB,CAAY,CAEvE,CAEC,GAAK,CAAEiB,EAENlB,EAAK,SAAW,OAEV,CAEN,IAAIsB,EAAoB,GACxB,QAAUlC,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAAO,CAEnD,MAAMgC,EAAIb,EAAUnB,CAAG,EAGvB,GAFAiC,GAAmBD,EAAGhB,CAAU,EAE3BL,EAAiBqB,EAAGnB,GAAe,CAOvC,MAAMsB,EACLH,EAAE,qBACF,CAAEA,EAAE,cACFA,EAAE,wBAA0BxB,GAAoBwB,EAAE,cAAc,GAChEA,EAAE,0BAA4BA,EAAE,iBAAmBtB,EACtDwB,EAAoBA,GAAqBC,CAE7C,CAEA,CAEEvB,EAAK,oBAAsBsB,CAE7B,CAEA,CAIO,SAASE,GAAkBxB,EAAMI,EAAW,CAElD,MAAMqB,EAAQrB,EAAS,MACvB,GAAK,CAAEL,EAAiBC,EAAMI,EAAS,UAAU,EAEhD,OAKD,GAAKJ,EAAK,SAAW,CAEfA,EAAK,iBAAmBH,GAEvBG,EAAK,cAETA,EAAK,UAAY,GACjByB,EAAM,WAGPzB,EAAK,SAAW,GAChByB,EAAM,UAEKzB,EAAK,cAEhBI,EAAS,qBAAsBJ,CAAM,EAItC,MAEF,CAEC,MAAMO,EAAWP,EAAK,SAChB0B,EAAa1B,EAAK,aAClB2B,EAAgB/B,GAAoBI,EAAK,cAAgB,GAAI0B,EAC7DE,GAAqBxB,EAAS,YAAc,GAAMA,EAAS,eAC3DyB,EAAW7B,EAAK,SAAW4B,EAC3BE,EAAmB9B,EAAK,SAAW,MAMnCsB,EAAoBtB,EAAK,qBAAyBA,EAAK,UAAY,GAAK,GA6B9E,GA1BK0B,IAAgBG,GAAYC,IAEhC1B,EAAS,qBAAsBJ,CAAM,GASjC6B,GAAYF,GAAiB,CAAEL,GAAqBK,GAAiBG,KAEpE9B,EAAK,cAETA,EAAK,UAAY,GACjByB,EAAM,WAGPzB,EAAK,SAAW,GAChByB,EAAM,UAMF,CAAEK,GAAoBD,GAAY,CAAEP,EAIxC,QAAUlC,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAAO,CAEnD,MAAMgC,EAAIb,EAAUnB,CAAG,EAClBW,EAAiBqB,EAAGhB,EAAS,UAAU,GAE3CK,GAAoCW,EAAGhB,CAAU,CAIrD,KAIE,SAAUhB,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAE5CoC,GAAkBjB,EAAUnB,CAAG,EAAEgB,CAAU,CAM9C,CAGO,SAAS2B,GAAa/B,EAAMI,EAAW,CAE7C,MAAM4B,EAASjC,EAAiBC,EAAMI,EAAS,UAAY,EAC3D,GAAK4B,GAAUhC,EAAK,gBAAkB,CAErC,IAAIiC,EAAY,GACZC,EAAa,GACZF,GAGJC,EAAYjC,EAAK,SACZI,EAAS,mBAEb8B,EAAalC,EAAK,UAAYA,EAAK,UAInCkC,EAAalC,EAAK,WASnBG,GAAiBH,EAAMI,CAAU,EAK7BJ,EAAK,wBAA0BA,EAAK,iBAAmBH,IAEtDG,EAAK,iBAAmBiC,GAE5B7B,EAAS,gBAAiB+B,GAAUA,EAAO,eAAiBA,EAAO,cAAenC,EAAMiC,EAAa,EAIjGjC,EAAK,kBAAoBkC,GAE7B9B,EAAS,gBAAiB+B,GAAUA,EAAO,gBAAkBA,EAAO,eAAgBnC,EAAMkC,EAAc,GAK1GlC,EAAK,eAAiBiC,EACtBjC,EAAK,gBAAkBkC,EACvBlC,EAAK,gBAAkBgC,EAEvB,MAAMzB,EAAWP,EAAK,SACtB,QAAUZ,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAAO,CAEnD,MAAMgC,EAAIb,EAAUnB,CAAG,EACvB2C,GAAaX,EAAGhB,CAAU,CAE7B,CAEA,CAEA,CAKO,SAASgC,GAAmBpC,EAAMlB,EAAW,KAAO,CAE1D,IAAIuD,EAAUrC,EAEd,KAAQqC,GAAU,CAEjB,MAAMtB,EAAQsB,EAAQ,QAChBrB,EAASqB,EAAQ,OAElBvD,GAEJA,EAAUuD,EAASrB,EAAQD,CAAO,EAInCsB,EAAUrB,CAEZ,CAGA,CCphBO,SAASsB,GAAUxD,EAAW,CAEpC,IAAIyD,EAAS,KACb,MAAO,IAAM,CAEPA,IAAW,OAEfA,EAAS,sBAAuB,IAAM,CAErCA,EAAS,KACTzD,EAAU,CAEd,CAAM,EAIJ,CAEF,CCbA,MAAM0D,GAAoB,OAAQ,mBAAqB,EAIjD5D,GAAmB,CAAEvC,EAAGC,IAAO,CAEpC,MAAMmG,EAAYpG,EAAE,UAAY,EAC1BqG,EAAYpG,EAAE,UAAY,EAEhC,OAAKmG,IAAcC,EAGXD,EAAYC,EAAY,EAAI,GAExBrG,EAAE,SAAWC,EAAE,OAGnBD,EAAE,OAAS,EAAI,GAEXA,EAAE,UAAYC,EAAE,QAGpBD,EAAE,QAAUC,EAAE,QAAU,EAAI,GAExBD,EAAE,uBAAyBC,EAAE,qBAIjCD,EAAE,qBAAuBC,EAAE,qBAAuB,GAAM,EAEpDD,EAAE,4BAA8BC,EAAE,0BAEtCD,EAAE,0BAA4BC,EAAE,0BAA4B,GAAM,EAInE,CAER,EAIMqG,GAAsB,CAAEtG,EAAGC,IAAO,CAEvC,MAAMmG,EAAYpG,EAAE,UAAY,EAC1BqG,EAAYpG,EAAE,UAAY,EAEhC,OAAKmG,IAAcC,EAGXD,EAAYC,EAAY,EAAI,GAExBrG,EAAE,qBAAuBC,EAAE,mBAG/BD,EAAE,mBAAqBC,EAAE,mBAAqB,GAAM,EAEhDD,EAAE,4BAA8BC,EAAE,0BAGtCD,EAAE,0BAA4BC,EAAE,0BAA4B,EAAI,GAE5DD,EAAE,iBAAmBC,EAAE,eAG3BD,EAAE,eAAiBC,EAAE,eAAiB,GAAM,EAExCD,EAAE,2BAA6BC,EAAE,yBAGrCD,EAAE,yBAA2B,GAAM,EAE/BA,EAAE,UAAYC,EAAE,QAGpBD,EAAE,QAAUC,EAAE,QAAU,GAAM,EAI/B,CAER,EAEO,MAAMsG,EAAkB,CAE9B,IAAI,MAAO,CAEV,MAAMC,EAAU,KAAK,YACrB,OAAOA,EAAUA,EAAQ,KAAO,IAElC,CAEC,IAAI,cAAe,CAElB,KAAM,CAAE,MAAApB,EAAO,UAAAqB,CAAS,EAAK,KACvBC,EAAUtB,EAAM,YAAcA,EAAM,QACpCuB,EAAQvB,EAAM,kBAAqBqB,EAAY,EAAI,GACzD,OAAOE,IAAU,EAAI,EAAM,EAAMD,EAAUC,CAE7C,CAEC,IAAI,gBAAiB,CAEpB,OAAO,KAAK,eAEd,CAEC,IAAI,eAAgBC,EAAI,CAEvB,QAAQ,KAAM,iEAAmE,EACjF,KAAK,gBAAkBA,CAEzB,CAEC,YAAalH,EAAM,KAAO,CAGzB,KAAK,iBAAmBmH,EACxB,KAAK,YAAc,KACnB,KAAK,QAAUnH,EACf,KAAK,aAAe,CAAE,EACtB,KAAK,QAAU,CAAE,EACjB,KAAK,YAAc,CAAE,EACrB,KAAK,wBAA0B,IAAI,IACnC,KAAK,UAAY,GAEjB,MAAMoH,EAAW,IAAIhH,GACrBgH,EAAS,uBAAyBR,GAElC,MAAMS,EAAgB,IAAI1E,EAC1B0E,EAAc,QAAU,GACxBA,EAAc,iBAAmBxE,GAEjC,MAAMyE,EAAa,IAAI3E,EACvB2E,EAAW,QAAU,EACrBA,EAAW,iBAAmBzE,GAE9B,MAAM0E,EAAmB,IAAI5E,EAC7B4E,EAAiB,QAAU,GAE3B,KAAK,eAAiB,IAAI,QAC1B,KAAK,aAAe,IAAI,IACxB,KAAK,YAAc,IAAI,IACvB,KAAK,QAAU,IAAI,IACnB,KAAK,SAAWH,EAChB,KAAK,cAAgBC,EACrB,KAAK,WAAaC,EAClB,KAAK,iBAAmBC,EACxB,KAAK,MAAQ,CACZ,iBAAkB,EAClB,QAAS,EACT,QAAS,EACT,YAAa,EACb,OAAQ,EACR,UAAW,EACX,KAAM,EACN,OAAQ,EACR,QAAS,CACT,EACD,KAAK,WAAa,EAGlB,KAAK,0BAA4BhB,GAAU,IAAM,CAEhD,KAAK,cAAe,CAAE,KAAM,cAAc,CAAI,CAEjD,CAAK,EAGH,KAAK,YAAc,GACnB,KAAK,gBAAkB,IACvB,KAAK,mBAAqB,GAC1B,KAAK,SAAW,GAElB,CAGC,eAAgBH,EAAS,CAExB,GAAKA,EAAQK,EAAmB,IAAK,GAEpC,MAAM,IAAI,MAAO,yEAA2E,EAK7F,MAAMe,EAAU,KAAK,QACfC,EAAWrB,EAAO,UAAY,EACpC,IAAIsB,EAAiBF,EAAQ,OAC7B,QAAUnE,EAAI,EAAGA,EAAImE,EAAQ,OAAQnE,IAGpC,IADsBmE,EAASnE,CAAG,EAAC,UAAY,GAC1BoE,EAAW,CAE/BC,EAAiBrE,EACjB,KAEJ,CAIEmE,EAAQ,OAAQE,EAAgB,EAAGtB,CAAQ,EAC3CA,EAAQK,EAAiB,EAAK,GACzBL,EAAO,MAEXA,EAAO,KAAM,IAAM,CAItB,CAEC,iBAAkBA,EAAS,CAE1B,MAAMoB,EAAU,KAAK,QAOrB,GANK,OAAOpB,GAAW,WAEtBA,EAAS,KAAK,gBAAiB,IAAM,GAIjCoB,EAAQ,SAAUpB,GAAW,CAEjC,MAAMjF,EAAQqG,EAAQ,QAASpB,CAAQ,EACvC,OAAAoB,EAAQ,OAAQrG,EAAO,CAAG,EACrBiF,EAAO,SAEXA,EAAO,QAAS,EAIV,EAEV,CAEE,MAAO,EAET,CAEC,gBAAiBuB,EAAO,CAEvB,OAAO,KAAK,QAAQ,KAAMC,GAAKA,EAAE,OAASD,CAAI,GAAM,IAEtD,CAEC,SAAUE,EAAUC,EAASC,EAAuB,GAAO,CAEnD,KAAK,MAEZnD,GAAa,KAAK,KAAM,CAAEX,KAAS+D,KAE7BD,GAEJ,KAAK,8BAA+B9D,EAAM,EAAM,EAI1C4D,EAAWA,EAAU5D,EAAM,GAAG+D,CAAM,EAAG,IAE5CF,CAAS,CAEd,CAEC,qBAAsB7D,EAAO,CAEvBA,EAAK,iBAAmBkD,GAAY,KAAK,SAAS,UAMvD,KAAK,YAAY,KAAMlD,CAAM,CAE/B,CAEC,aAAcA,EAAO,CAIpB,KAAK,QAAQ,IAAKA,CAAM,EACxB,KAAK,SAAS,SAAUA,CAAM,CAEhC,CAGC,QAAS,CAER,KAAM,CAAE,SAAAmD,EAAU,QAAArG,EAAS,MAAA2E,EAAO,KAAAuC,EAAM,cAAAZ,EAAe,WAAAC,EAAY,iBAAAC,CAAgB,EAAK,KAyCxF,GAxCK,KAAK,mBAAqBJ,IAE9B,KAAK,iBAAmBe,EACxB,KAAK,gBAAiB9B,GAAUA,EAAO,iBAAmBA,EAAO,gBAAiB,CAAA,EAChF,KAAM6B,GAAQ,CAEd,IAAIE,EAAe,KAAK,QACnBA,IAAiB,MAErB,KAAK,iBAAkB/B,GAAU+B,EAAe/B,EAAO,cAAgBA,EAAO,cAAe+B,EAAc,IAAI,EAAKA,CAAc,EAGnI,KAAK,iBAAmBrE,EACxB,KAAK,YAAcmE,EACnB,KAAK,cAAe,CAAE,KAAM,cAAc,CAAI,EAC9C,KAAK,cAAe,CAAE,KAAM,cAAc,CAAI,EAC9C,KAAK,cAAe,CACnB,KAAM,gBACN,QAASA,EACT,IAAKE,CACX,CAAQ,CAEH,CAAA,EACA,MAAOC,GAAS,CAEhB,KAAK,iBAAmBrE,EACxB,QAAQ,MAAOqE,CAAO,EAEtB,KAAK,YAAc,KACnB,KAAK,cAAe,CACnB,KAAM,aACN,KAAM,KACN,MAAAA,EACA,IAAK,KAAK,OAChB,CAAQ,CAER,CAAO,GAIA,CAAEH,EAEN,OAIDvC,EAAM,UAAY,EAClBA,EAAM,KAAO,EACbA,EAAM,OAAS,EACfA,EAAM,QAAU,EAChB,KAAK,aAEL3E,EAAQ,QAASkD,GAAQmD,EAAS,WAAYnD,CAAI,CAAI,EACtDlD,EAAQ,MAAO,EAEfmE,GAAe+C,EAAM,IAAM,EAC3B3C,GAAmB2C,EAAM,IAAM,EAC/BxC,GAAkBwC,EAAM,IAAM,EAC9BjC,GAAaiC,EAAM,IAAM,EAKzB,MAAMI,EAAc,KAAK,YACzBA,EAAY,KAAMjB,EAAS,sBAAwB,EACnD,QAAU/D,EAAI,EAAGoB,EAAI4D,EAAY,OAAQhF,EAAIoB,GAAK,CAAE2C,EAAS,OAAQ,EAAE/D,IAEtE,KAAK,oBAAqBgF,EAAahF,EAAK,EAI7CgF,EAAY,OAAS,EAGrBjB,EAAS,eAAgB,GAGJC,EAAc,SAAWC,EAAW,SAAWC,EAAiB,WAC/D,IAAS,KAAK,YAAc,KAEjD,KAAK,wBAAwB,MAAO,EACpC7B,EAAM,iBAAmB,EAEzB,KAAK,cAAe,CAAE,KAAM,gBAAgB,CAAI,EAChD,KAAK,UAAY,GAIpB,CAEC,kBAAmB,CAGb,KAAK,mBAAqB3B,IAE9B,KAAK,iBAAmBoD,GAIzB,MAAMzB,EAAQ,KAAK,MACdA,EAAM,SAAW,IAMtB,KAAK,SAAUzB,GAAQ,CAEjBA,EAAK,iBAAmBF,IAE5BE,EAAK,eAAiBkD,EAI1B,EAAK,KAAM,EAAO,EAEhBzB,EAAM,OAAS,EAEjB,CAEC,SAAU,CAGO,CAAE,GAAG,KAAK,OAAS,EAC3B,QAASU,GAAU,CAE1B,KAAK,iBAAkBA,CAAQ,CAElC,CAAK,EAEH,MAAMgB,EAAW,KAAK,SAIhBkB,EAAW,CAAE,EACnB,KAAK,SAAUC,IAEdD,EAAS,KAAMC,CAAG,EACX,IAEL,KAAM,EAAO,EAChB,QAAUlF,EAAI,EAAGoB,EAAI6D,EAAS,OAAQjF,EAAIoB,EAAGpB,IAE5C+D,EAAS,OAAQkB,EAAUjF,EAAK,EAIjC,KAAK,MAAQ,CACZ,QAAS,EACT,YAAa,EACb,OAAQ,EACR,UAAW,EACX,KAAM,EACN,OAAQ,EACR,QAAS,CACT,EACD,KAAK,WAAa,CAEpB,CAGC,mBAAoBmF,EAAOvE,EAAO,CAEjC,MAAO,EAET,CAEC,cAAe,EAAI,CAIpB,CAEC,UAAWjE,EAAKyI,EAAU,CAEzB,OAAO,MAAOzI,EAAKyI,CAAS,CAE9B,CAEC,UAAWC,EAAQzE,EAAM0E,EAAY,CAEpC,OAAO,IAET,CAEC,YAAa1E,EAAO,CAGdA,EAAK,YAET,KAAK,gBAAiBmC,GAAUA,EAAO,gBAAkBA,EAAO,eAAgBnC,EAAM,GAAS,EAC/FA,EAAK,UAAY,IAIbA,EAAK,WAET,KAAK,gBAAiBmC,GAAUA,EAAO,eAAiBA,EAAO,cAAenC,EAAM,GAAS,EAC7FA,EAAK,SAAW,GAInB,CAEC,eAAgBA,EAAM2E,EAAYC,EAAa,KAAO,OAkCrD,GAhCA,KAAK,eAAe,IAAK5E,CAAM,EAE1BA,EAAK,UAGJ,EAAI,QAASA,EAAK,UAAa,QAASA,EAAK,UAEjDA,EAAK,QAAQ,IAAMA,EAAK,QAAQ,IAChC,OAAOA,EAAK,QAAQ,KAOpBA,EAAK,QAAQ,gBACb,EACC,QAASA,EAAK,QAAQ,gBACtB,WAAYA,EAAK,QAAQ,gBACzB,WAAYA,EAAK,QAAQ,iBAI1B,OAAOA,EAAK,QAAQ,gBAMtBA,EAAK,OAAS4E,EACd5E,EAAK,SAAWA,EAAK,UAAY,CAAE,GAE9B6E,EAAA7E,EAAK,UAAL,MAAA6E,EAAc,IAAM,CAGxB,MAAMH,EAAY5I,GAAiBkE,EAAK,QAAQ,GAAK,EAErDA,EAAK,aAAe,GACpBA,EAAK,yBAA2B,GAAS0E,GAAa,QAAQ,KAAMA,IACpE1E,EAAK,uBAAyB,CAAEA,EAAK,wBAExC,MAEGA,EAAK,aAAe,GACpBA,EAAK,yBAA2B,GAChCA,EAAK,uBAAyB,GAM/BA,EAAK,oBAAsB,EACtB4E,GAEJA,EAAW,sBAIZ5E,EAAK,qBAAuB,IAC5BA,EAAK,QAAU,IAEfA,EAAK,YAAc,GACnBA,EAAK,SAAW,GAEhBA,EAAK,gBAAkB,GACvBA,EAAK,OAAS,GAEdA,EAAK,gBAAkB,GACvBA,EAAK,UAAY,GACjBA,EAAK,oBAAsB,GAE3BA,EAAK,eAAiB,GACtBA,EAAK,SAAW,GAEhBA,EAAK,eAAiBkD,EAEjB0B,IAAe,MAEnB5E,EAAK,QAAU,EACfA,EAAK,0BAA8BA,EAAK,uBAAyB,EAAI,EACrEA,EAAK,OAASA,EAAK,QAAU,YAK7BA,EAAK,QAAU4E,EAAW,QAAU,EACpC5E,EAAK,0BAA4B4E,EAAW,2BAA8B5E,EAAK,uBAAyB,EAAI,GAE5GA,EAAK,OAASA,EAAK,QAAU4E,EAAW,QAIzC5E,EAAK,WAAa2E,EAElB3E,EAAK,mBAAqB,GAE1B,KAAK,iBAAkBmC,GAAU,CAEhCA,IAAW,MAAQA,EAAO,gBAAkBA,EAAO,eAAgBnC,EAAM2E,EAAYC,CAAY,CAEpG,CAAK,CAEL,CAEC,cAAe5E,EAAM8E,EAAS,CAE7BA,EAAS,KAAK,YAAY,IAAK9E,CAAM,EAAG,KAAK,YAAY,OAAQA,CAAM,CAEzE,CAEC,eAAgBA,EAAM+E,EAAU,CAE/BA,EAAU,KAAK,aAAa,IAAK/E,CAAM,EAAG,KAAK,aAAa,OAAQA,CAAM,CAE5E,CAEC,uBAAwBA,EAAMgF,EAAS,CAKxC,CAEC,8BAA+BhF,EAAMiF,EAAY,GAAQ,CAExD,MAAM1E,EAAWP,EAAK,SACtB,QAAUZ,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAAO,CAEnD,MAAM8F,EAAQ3E,EAAUnB,CAAG,EAC3B,GAAK,YAAa8F,EAGjB,MAEWD,GAGX,KAAK,iBAAiB,OAAQC,CAAO,EACrC,KAAK,eAAgBA,EAAOlF,EAAK,WAAYA,CAAM,GAK5C,KAAK,iBAAiB,IAAKkF,CAAK,GAEtC,KAAK,iBAAiB,IAAKA,EAAOA,GAAS,CAE1C,KAAK,eAAgBA,EAAOlF,EAAK,WAAYA,CAAM,EACnD,KAAK,0BAA2B,CAEtC,CAAQ,CAMR,CAEA,CAIC,aAAcA,EAAO,CAEpB,IAAIrD,EAAQ,EACZ,YAAK,iBAAkBwF,GAAU,CAE3BA,EAAO,qBAEXxF,GAASwF,EAAO,mBAAoBnC,EAAMA,EAAK,OAAO,KAAK,GAAM,EAIrE,CAAK,EAEIrD,CAET,CAGC,qBAAsBqD,EAAO,KAAO,CAEnC,KAAM,CAAE,SAAAmD,EAAU,eAAAgC,CAAc,EAAK,KAChCnF,IAAS,KAEbmD,EAAS,QAAQ,QAASzG,GAAQ,CAE5ByI,EAAe,IAAKzI,IAExByG,EAAS,eAAgBzG,EAAM,KAAK,aAAcA,CAAI,CAAI,CAI/D,CAAM,EAIHyG,EAAS,eAAgBnD,EAAM,KAAK,aAAcA,CAAI,CAAI,CAI7D,CAEC,kBAAmBoF,EAAMrJ,EAAKiF,EAAS,KAAO,CAE7C,MAAMqE,EAAUD,EAAK,MAAM,QACrB,CAAEE,EAAOC,CAAO,EAAGF,EAAQ,MAAO,GAAK,EAAC,IAAKpC,GAAK,SAAUA,CAAC,CAAI,EACvE,QAAQ,OACPqC,GAAS,EACT,+EACA,EAEIA,IAAU,GAAKC,EAAQ,GAE3B,QAAQ,KAAM,6HAA+H,EAK9I,IAAIC,EAAWzJ,EAAI,QAAS,WAAY,EAAI,EAC5CyJ,EAAW,IAAI,IAAKA,EAAU,OAAO,SAAS,IAAM,EAAC,SAAU,EAC/D,KAAK,eAAgBJ,EAAK,KAAMI,EAAUxE,CAAQ,CAEpD,CAEC,iBAAkB,CAGjB,IAAIkD,EAAe,KAAK,QACxB,YAAK,iBAAkB/B,GAAU+B,EAAe/B,EAAO,cAAgBA,EAAO,cAAe+B,EAAc,IAAI,EAAKA,CAAc,EAGvH,KACT,gBAAiB/B,GAAUA,EAAO,WAAaA,EAAO,UAAW+B,EAAc,KAAK,YAAc,CAAA,EAClG,KAAMuB,GAAO,CAEb,GAASA,aAAe,SAIjB,IAAKA,EAAI,GAEf,OAAOA,EAAI,KAAM,EAIjB,MAAM,IAAI,MAAO,0CAA2CvB,CAAY,iBAAmBuB,EAAI,YAAcA,EAAI,UAAY,EAAG,MARhI,QAAOA,CAYR,CAAA,EACA,KAAMzB,IAEN,KAAK,kBAAmBA,EAAME,CAAc,EACrCF,EAEL,CAIN,CAEC,oBAAqBhE,EAAO,CAI3B,GAAKA,EAAK,iBAAmBkD,EAE5B,OAID,IAAIwC,EAAoB,GACpBC,EAAkB,KAClBC,EAAM,IAAI,IAAK5F,EAAK,QAAQ,IAAKA,EAAK,WAAa,GAAK,EAAC,SAAU,EACvE,KAAK,iBAAkBmC,GAAUyD,EAAMzD,EAAO,cAAgBA,EAAO,cAAeyD,EAAK5F,CAAI,EAAK4F,CAAK,EAEvG,MAAMnE,EAAQ,KAAK,MACb0B,EAAW,KAAK,SAChBC,EAAgB,KAAK,cACrBC,EAAa,KAAK,WAClBqB,EAAY5I,GAAiB8J,CAAK,EAGlCC,EAAa,IAAI,gBACjBC,EAASD,EAAW,OAiD1B,GAhD0B1C,EAAS,IAAKnD,EAAMsE,GAAK,CAGlDuB,EAAW,MAAO,EAGbH,GAEJpB,EAAE,SAAS,OAAS,EACpBA,EAAE,oBAAsB,GAIxB,KAAK,iBAAkBnC,GAAU,CAEhCA,EAAO,aAAeA,EAAO,YAAamC,CAAG,CAElD,CAAO,EAKJ7C,EAAM,UACD,KAAK,wBAAwB,IAAKzB,CAAI,IAE1C,KAAK,wBAAwB,OAAQA,CAAM,EAC3CyB,EAAM,oBAIF6C,EAAE,iBAAmBL,EAEzBxC,EAAM,cAEK6C,EAAE,iBAAmByB,GAEhCtE,EAAM,UAIP6C,EAAE,eAAiBpB,EAEnBG,EAAW,OAAQiB,CAAG,EACtBlB,EAAc,OAAQkB,CAAG,CAE5B,CAAK,EAUH,OAAO,KAAK,YAEX,KAAK,UAAY,GACjB,KAAK,cAAe,CAAE,KAAM,kBAAkB,CAAI,GAInDnB,EAAS,eAAgBnD,EAAM,KAAK,aAAcA,CAAI,CAAI,EAC1D,KAAK,wBAAwB,IAAKA,CAAM,EACxCyB,EAAM,mBACNA,EAAM,UACNA,EAAM,cACNzB,EAAK,eAAiBiE,EAGfb,EAAc,IAAKpD,EAAMgG,GAAgB,CAE/C,GAAKF,EAAO,QAEX,OAAO,QAAQ,QAAS,EAIzB,MAAML,EAAM,KAAK,gBAAiBtD,GAAUA,EAAO,WAAaA,EAAO,UAAWyD,EAAK,CAAE,GAAG,KAAK,aAAc,OAAAE,CAAQ,CAAA,CAAI,EAC3H,YAAK,cAAe,CAAE,KAAM,sBAAuB,KAAA9F,CAAI,CAAI,EACpDyF,CAEP,CAAA,EACC,KAAMA,GAAO,CAEb,GAAK,CAAAK,EAAO,QAMZ,GAASL,aAAe,SAIjB,IAAKA,EAAI,GAEf,OAAOf,IAAc,OAASe,EAAI,KAAM,EAAGA,EAAI,YAAa,EAI5D,MAAM,IAAI,MAAO,wCAAwCA,EAAI,MAAM,EAAI,MARvE,QAAOA,CAYR,CAAA,EACA,KAAMQ,GAAW,CAGjB,GAAK,CAAAH,EAAO,QAMZ,OAAArE,EAAM,cACNA,EAAM,UACNzB,EAAK,eAAiB+F,EAEf1C,EAAW,IAAKrD,EAAMkG,GAGvBJ,EAAO,QAEJ,QAAQ,QAAS,EAIpBpB,IAAc,QAAUuB,EAAQ,MAEpC,KAAK,kBAAmBA,EAASL,EAAK5F,CAAM,EAC5CA,EAAK,SAAS,KAAMiG,EAAQ,IAAM,EAClCN,EAAkBM,EAClBP,EAAoB,GACb,QAAQ,QAAS,GAIjB,KAAK,gBAAiBvD,GAAUA,EAAO,WAAaA,EAAO,UAAW8D,EAASC,EAAWxB,EAAWkB,EAAKE,CAAM,CAAI,CAI1H,CAEH,CAAA,EACA,KAAM,IAAM,CAGZ,GAAKA,EAAO,QAEX,OAIDrE,EAAM,UACNzB,EAAK,eAAiBH,EACtBsD,EAAS,UAAWnD,EAAM,EAAM,EAIhC,MAAMmG,EAAY,KAAK,aAAcnG,CAAM,EAC3C,GAAKmD,EAAS,eAAgBnD,KAAW,GAAKmG,EAAY,GAAKhD,EAAS,SAAW,CAIlFA,EAAS,OAAQnD,CAAM,EACvB,MAEL,CAGImD,EAAS,eAAgBnD,EAAMmG,CAAW,EAI1C,KAAK,cAAe,CAAE,KAAM,cAAc,CAAI,EAC9C,KAAK,cAAe,CAAE,KAAM,cAAc,CAAI,EACzCT,GAEJ,KAAK,cAAe,CACnB,KAAM,gBACN,QAASC,EACT,IAAKC,CACX,CAAQ,EAGC5F,EAAK,OAAO,OAEhB,KAAK,cAAe,CACnB,KAAM,aACN,MAAOA,EAAK,OAAO,MACnB,KAAAA,CACN,CAAQ,CAIJ,CAAA,EACA,MAAOmE,GAAS,CAGX2B,EAAO,UAMP3B,EAAM,OAAS,cAEnBd,EAAW,OAAQrD,CAAM,EACzBoD,EAAc,OAAQpD,CAAM,EAEvBA,EAAK,iBAAmB+F,EAE5BtE,EAAM,UAEKzB,EAAK,iBAAmBiE,GAEnCxC,EAAM,cAIPA,EAAM,SAEN,QAAQ,MAAO,+CAAgDzB,EAAK,QAAQ,GAAK,IAAK,EACtF,QAAQ,MAAOmE,CAAO,EACtBnE,EAAK,eAAiBF,EACtBqD,EAAS,UAAWnD,EAAM,EAAM,EAEhC,KAAK,cAAe,CACnB,KAAM,aACN,KAAAA,EACA,MAAAmE,EACA,IAAKyB,CACX,CAAQ,GAIHzC,EAAS,OAAQnD,CAAM,EAI5B,CAAM,CAEN,CAEC,gBAAiBgF,EAAS,GAAK,CAE9B,YAAK,iBAAkB7C,GAAUA,IAAW,MAAQA,EAAO,iBAAmBA,EAAO,gBAAiB6C,EAAU,EACzGA,CAET,CAEC,gBAAiBrG,EAAO,CAEvB,MAAM4E,EAAU,CAAE,GAAG,KAAK,QAAS,IAAM,EACzC,QAAUnE,EAAI,EAAGA,EAAImE,EAAQ,OAAQnE,IAAO,CAE3C,MAAMI,EAASb,EAAM4E,EAASnE,CAAC,CAAI,EACnC,GAAKI,EAEJ,OAAOA,CAIX,CAEE,OAAO,IAET,CAEC,iBAAkBb,EAAO,CAExB,MAAM4E,EAAU,CAAE,GAAG,KAAK,QAAS,IAAM,EACnC6C,EAAU,CAAE,EAClB,QAAUhH,EAAI,EAAGA,EAAImE,EAAQ,OAAQnE,IAAO,CAE3C,MAAMI,EAASb,EAAM4E,EAASnE,CAAC,CAAI,EAC9BI,GAEJ4G,EAAQ,KAAM5G,CAAQ,CAI1B,CAEE,OAAO4G,EAAQ,SAAW,EAAI,KAAO,QAAQ,IAAKA,CAAS,CAE7D,CAEA,CC9iCA,MAAMC,EAAU,IAAIC,EACb,MAAMC,WAAmBC,EAAM,CAErC,YAAaC,EAAgB,CAE5B,MAAO,EACP,KAAK,aAAe,GACpB,KAAK,KAAO,2BACZ,KAAK,cAAgBA,EACrB,KAAK,mBAAqB,IAAIH,CAEhC,CAEC,QAASI,EAAWC,EAAa,CAGhC,OAAK,KAAK,cAAc,iBAEvB,KAAK,cAAc,QAASD,EAAWC,CAAY,EAC5C,IAID,EAET,CAEC,kBAAmBC,EAAQ,CAQ1B,GANK,KAAK,kBAET,KAAK,aAAc,EAIf,KAAK,wBAA0BA,EAAQ,CAEtC,KAAK,SAAW,KAEpBP,EAAQ,KAAM,KAAK,MAAQ,EAI3BA,EAAQ,iBAAkB,KAAK,OAAO,YAAa,KAAK,MAAQ,EAIjE,KAAK,uBAAyB,GAG9B,MAAMQ,EAAMR,EAAQ,SACdS,EAAM,KAAK,YAAY,SAC7B,IAAIC,EAAc,GAClB,QAAU3H,EAAI,EAAGA,EAAI,GAAIA,IAAO,CAE/B,MAAM4H,EAAQH,EAAKzH,CAAG,EAChB6H,EAAQH,EAAK1H,CAAG,EAGtB,GAFa,KAAK,IAAK4H,EAAQC,CAAO,EAE1B,OAAO,QAAU,CAE5BF,EAAc,GACd,KAEL,CAEA,CAEG,GAAKA,EAAc,CAElB,KAAK,YAAY,KAAMV,CAAS,EAChC,KAAK,mBAAmB,KAAMA,CAAO,EAAG,OAAQ,EAIhD,MAAM9F,EAAW,KAAK,SACtB,QAAUnB,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAE5CmB,EAAUnB,CAAG,EAAC,kBAAmB,CAItC,CAEA,CAEA,CAEC,kBAAmB8H,EAAeC,EAAiB,CAE7C,KAAK,QAAUD,GAEnB,KAAK,OAAO,kBAAmBA,EAAe,EAAO,EAKtD,KAAK,kBAAmB,EAAM,CAEhC,CAEA,CCvGA,MAAME,GAAY,IAAIC,GAChBC,EAAO,IAAIC,EACXC,EAAY,CAAE,EAEpB,SAASC,GAAcpL,EAAGC,EAAI,CAE7B,OAAOD,EAAE,SAAWC,EAAE,QAEvB,CAEA,SAASoL,GAAoB1H,EAAM0G,EAAWtG,EAAUuG,EAAa,CAEpE,KAAM,CAAE,MAAApC,GAAUvE,EAAK,OACJI,EAAS,gBAAiB+B,GAAUA,EAAO,aAAeA,EAAO,YAAanC,EAAMuE,EAAOmC,EAAWC,CAAU,CAAI,GAGtID,EAAU,gBAAiBnC,EAAO,GAAMoC,CAAY,CAItD,CAEA,SAASgB,GAA6B3H,EAAM0G,EAAWtG,EAAW,CAEjEsH,GAAoB1H,EAAM0G,EAAWtG,EAAUoH,CAAW,EAC1DA,EAAU,KAAMC,EAAc,EAE9B,MAAMG,EAAMJ,EAAW,CAAC,GAAM,KAC9B,OAAAA,EAAU,OAAS,EACZI,CAER,CAEA,SAASC,GAAmB7H,EAAO,CAElC,MAAO,WAAYA,CAEpB,CAGO,SAAS8H,GAAyB1H,EAAUJ,EAAM0G,EAAWqB,EAAW,KAAO,CAErF,KAAM,CAAE,MAAAC,EAAO,YAAAC,CAAW,EAAK7H,EAG1B2H,IAAa,OAEjBA,EAAWX,GACXW,EAAS,KAAMrB,EAAU,GAAK,EAAC,aAAcsB,EAAM,kBAAoB,GAKxE,MAAME,EAAQ,CAAE,EACV3H,EAAWP,EAAK,SACtB,QAAUZ,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAAO,CAEnD,MAAM8F,EAAQ3E,EAAUnB,CAAG,EAC3B,GAAK,CAAEyI,GAAmB3C,CAAO,GAAI,CAAEA,EAAM,OAE5C,SAKsBA,EAAM,OAAO,eAChB,aAAc6C,EAAUT,CAAI,IAAO,OAEtDA,EAAK,aAAcU,EAAM,WAAa,EACtCE,EAAM,KAAM,CACX,SAAUZ,EAAK,kBAAmBZ,EAAU,IAAI,MAAQ,EACxD,KAAMxB,CACV,CAAM,EAIN,CAGCgD,EAAM,KAAMT,EAAc,EAG1B,IAAIU,EAAU,KACVC,EAAgB,IACpB,GAAKH,EAAY,IAAKjI,GAAS,CAE9B,MAAM4H,EAAMD,GAA6B3H,EAAM0G,EAAWtG,CAAU,EAC/DwH,IAEJO,EAAUP,EACVQ,EAAgBR,EAAI,SAAWA,EAAI,SAItC,CAIC,QAAUxI,EAAI,EAAGoB,EAAI0H,EAAM,OAAQ9I,EAAIoB,EAAGpB,IAAO,CAEhD,MAAML,EAAOmJ,EAAO9I,CAAG,EACjBiJ,EAAuBtJ,EAAK,SAC5BiB,EAAOjB,EAAK,KAClB,GAAKsJ,EAAuBD,EAE3B,MAID,MAAMR,EAAME,GAAyB1H,EAAUJ,EAAM0G,EAAWqB,CAAU,EAC1E,GAAKH,EAAM,CAEV,MAAMU,EAAYV,EAAI,SAAWA,EAAI,SAChCU,EAAYF,IAEhBD,EAAUP,EACVQ,EAAgBE,EAIpB,CAEA,CAEC,OAAOH,CAER,CAEO,SAASI,GAAiBnI,EAAUJ,EAAM0G,EAAWC,EAAYoB,EAAW,KAAO,CAIzF,GAAK,CAAEF,GAAmB7H,GAEzB,OAID,KAAM,CAAE,MAAAgI,EAAO,YAAAC,CAAW,EAAK7H,EACzB,CAAE,eAAAoI,GAAmBxI,EAAK,OAWhC,GARK+H,IAAa,OAEjBA,EAAWX,GACXW,EAAS,KAAMrB,EAAU,GAAK,EAAC,aAAcsB,EAAM,kBAAoB,GAKnE,CAAEhI,EAAK,QAAU,CAAEwI,EAAe,cAAeT,GAErD,OAKIE,EAAY,IAAKjI,IAErB0H,GAAoB1H,EAAM0G,EAAWtG,EAAUuG,CAAY,EAI5D,MAAMpG,EAAWP,EAAK,SACtB,QAAUZ,EAAI,EAAGoB,EAAID,EAAS,OAAQnB,EAAIoB,EAAGpB,IAE5CmJ,GAAiBnI,EAAUG,EAAUnB,CAAG,EAAEsH,EAAWC,EAAYoB,CAAU,CAI7E,CC3KA,MAAMU,EAAY,IAAIlB,EAChBmB,EAAY,IAAInB,EAChBoB,EAAQ,IAAIpB,EACZqB,EAAO,IAAIvB,GAEV,MAAMwB,EAAI,CAEhB,YAAaC,EAAM,IAAIC,GAAQC,EAAY,IAAI1C,EAAY,CAE1D,KAAK,IAAMwC,EAAI,MAAO,EACtB,KAAK,UAAYE,EAAU,MAAO,EAClC,KAAK,iBAAmB,IAAI1C,EAC5B,KAAK,OAAS,IAAI,MAAO,CAAC,EAAG,KAAI,EAAG,IAAK,IAAM,IAAIiB,CAAW,EAC9D,KAAK,OAAS,IAAI,MAAO,CAAC,EAAG,KAAI,EAAG,IAAK,IAAM,IAAI0B,EAAS,CAE9D,CAEC,KAAMC,EAAS,CAEd,YAAK,IAAI,KAAMA,EAAO,GAAK,EAC3B,KAAK,UAAU,KAAMA,EAAO,SAAW,EACvC,KAAK,OAAQ,EACN,IAET,CAEC,OAAQ,CAEP,OAAO,IAAI,KAAK,cAAc,KAAM,IAAM,CAE5C,CAQC,WAAYC,EAAO3J,EAAS,CAE3B,OAAOA,EAAO,KAAM2J,CAAK,EACvB,aAAc,KAAK,gBAAgB,EACnC,MAAO,KAAK,IAAI,IAAK,KAAK,IAAI,GAAG,EACjC,aAAc,KAAK,SAAW,CAElC,CAQC,gBAAiBA,EAAQ,CAExB,OAAO,KAAK,WAAYA,EAAOR,CAAO,EAAC,WAAYQ,CAAO,CAE5D,CAEC,cAAeA,EAAQ,CAEtB,OAAAR,EAAM,KAAMQ,CAAK,EAAG,aAAc,KAAK,gBAAkB,EAClD,KAAK,IAAI,cAAeR,CAAO,CAExC,CAGC,cAAeS,EAAM,CAEpB,OAAAR,EAAK,KAAMQ,CAAG,EAAG,aAAc,KAAK,gBAAkB,EAC/CR,EAAK,cAAe,KAAK,GAAK,CAEvC,CAIC,aAAcQ,EAAKpE,EAAS,CAG3B,OADA4D,EAAK,KAAMQ,CAAG,EAAG,aAAc,KAAK,gBAAkB,EACjDR,EAAK,aAAc,KAAK,IAAK5D,CAAM,GAEvCA,EAAO,aAAc,KAAK,SAAW,EAC9BA,GAIA,IAIV,CAEC,QAAS,CAER,KAAM,CAAE,OAAAqE,EAAQ,iBAAAC,EAAkB,UAAAN,EAAW,IAAAF,CAAK,EAAG,KACrDQ,EAAiB,KAAMN,CAAW,EAAC,OAAQ,EAE3C,KAAM,CAAE,IAAAO,EAAK,IAAAC,CAAG,EAAKV,EACrB,IAAI5L,EAAQ,EACZ,QAAUuM,EAAI,GAAKA,GAAK,EAAGA,GAAK,EAE/B,QAAUC,EAAI,GAAKA,GAAK,EAAGA,GAAK,EAE/B,QAAUC,EAAI,GAAKA,GAAK,EAAGA,GAAK,EAE/BN,EAAQnM,CAAK,EAAG,IACfuM,EAAI,EAAIF,EAAI,EAAIC,EAAI,EACpBE,EAAI,EAAIH,EAAI,EAAIC,EAAI,EACpBG,EAAI,EAAIJ,EAAI,EAAIC,EAAI,CAC1B,EAAO,aAAcR,CAAW,EAC3B9L,IAQH,KAAK,aAAc,CAErB,CAEC,cAAe,CAEduL,EAAU,KAAM,KAAK,IAAI,GAAG,EAAG,aAAc,KAAK,SAAW,EAC7DC,EAAU,KAAM,KAAK,IAAI,GAAG,EAAG,aAAc,KAAK,SAAW,EAE7DC,EAAM,IAAK,EAAG,EAAG,CAAC,EAAG,mBAAoB,KAAK,SAAW,EACzD,KAAK,OAAQ,CAAC,EAAG,8BAA+BA,EAAOF,CAAW,EAClE,KAAK,OAAQ,CAAG,EAAC,8BAA+BE,EAAOD,CAAW,EAAC,OAAQ,EAE3EC,EAAM,IAAK,EAAG,EAAG,CAAC,EAAG,mBAAoB,KAAK,SAAW,EACzD,KAAK,OAAQ,CAAC,EAAG,8BAA+BA,EAAOF,CAAW,EAClE,KAAK,OAAQ,CAAG,EAAC,8BAA+BE,EAAOD,CAAW,EAAC,OAAQ,EAE3EC,EAAM,IAAK,EAAG,EAAG,CAAC,EAAG,mBAAoB,KAAK,SAAW,EACzD,KAAK,OAAQ,CAAC,EAAG,8BAA+BA,EAAOF,CAAW,EAClE,KAAK,OAAQ,CAAG,EAAC,8BAA+BE,EAAOD,CAAW,EAAC,OAAQ,CAE7E,CAEC,iBAAkBkB,EAAS,CAE1B,YAAK,WAAYA,EAAO,OAAQjB,CAAO,EAChCA,EAAM,kBAAmBiB,EAAO,MAAQ,GAAMA,EAAO,OAASA,EAAO,MAE9E,CAEC,kBAAmBC,EAAU,CAE5B,OAAO,KAAK,sBAAuBA,EAAQ,OAAQA,EAAQ,MAAQ,CAErE,CAEC,cAAeC,EAAM,CAEpB,OAAO,KAAK,sBAAuBA,EAAI,OAAQA,EAAI,MAAQ,CAE7D,CAIC,sBAAuBC,EAAaC,EAAc,CAEjD,MAAMC,EAAa,KAAK,OAClBC,EAAa,KAAK,OAGxB,QAAU9K,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAM+K,EAAQJ,EAAa3K,CAAG,EAC9B,IAAIgL,EAAc,KAClB,QAAUC,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAMpH,EAAIgH,EAAYI,CAAG,EACnBC,EAAOH,EAAM,gBAAiBlH,CAAG,EACvCmH,EAAcA,EAAcE,EAAOA,EAAOF,CAE9C,CAEG,GAAKA,EAAc,EAElB,MAAO,EAIX,CAIE,QAAUhL,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAM+K,EAAQD,EAAY9K,CAAG,EAC7B,IAAIgL,EAAc,KAClB,QAAUC,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAMpH,EAAI+G,EAAaK,CAAG,EACpBC,EAAOH,EAAM,gBAAiBlH,CAAG,EACvCmH,EAAcA,EAAcE,EAAOA,EAAOF,CAE9C,CAEG,GAAKA,EAAc,EAElB,MAAO,EAIX,CAEE,MAAO,EAET,CAEA,CCpNA,MAAMG,EAAQ,IAAIhD,EACZiD,EAAQ,IAAIjD,EACZkD,EAAQ,IAAIlD,EACZmD,GAAa,IAAInD,EACjBoD,GAAU,IAAIpD,EAGb,MAAMqD,EAAmB,CAE/B,aAAc,CAEb,KAAK,OAAS,KACd,KAAK,IAAM,KACX,KAAK,OAAS,KAEd,KAAK,UAAY,IAEnB,CAEC,cAAexB,EAAM,CAEpB,MAAMQ,EAAS,KAAK,OACdE,EAAM,KAAK,KAAO,KAAK,UAU7B,MAPK,EAAAF,GAAU,CAAER,EAAI,iBAAkBQ,CAAM,GAOxCE,GAAO,CAAEA,EAAI,cAAeV,CAAG,EAQtC,CAEC,aAAcA,EAAKpE,EAAS,KAAO,CAElC,MAAM4E,EAAS,KAAK,OACdE,EAAM,KAAK,KAAO,KAAK,UAE7B,IAAIe,EAAe,KACfC,EAAY,KAEXlB,GAECR,EAAI,gBAAiBQ,EAAQc,EAAU,IAE3CG,EAAejB,EAAO,cAAeR,EAAI,MAAM,EAAK,EAAIA,EAAI,OAAO,kBAAmBsB,EAAY,GAM/FZ,GAECA,EAAI,aAAcV,EAAKuB,EAAO,IAElCG,EAAYhB,EAAI,cAAeV,EAAI,MAAM,EAAK,EAAIA,EAAI,OAAO,kBAAmBuB,EAAS,GAO3F,MAAMI,EAAe,KAAK,IAAKF,EAAcC,CAAW,EACxD,OAAKC,IAAiB,KAEd,MAKR3B,EAAI,GAAI,KAAK,KAAM2B,CAAY,EAAI/F,CAAQ,EACpCA,EAET,CAEC,gBAAiBmE,EAAQ,CAExB,MAAMS,EAAS,KAAK,OACdE,EAAM,KAAK,KAAO,KAAK,UAE7B,IAAIkB,EAAiB,KACjBC,EAAc,KAElB,OAAKrB,IAKJoB,EAAiB,KAAK,IAAKpB,EAAO,gBAAiBT,CAAO,EAAE,CAAG,GAI3DW,IAEJmB,EAAcnB,EAAI,gBAAiBX,CAAO,GAKpC6B,EAAiBC,EAAcD,EAAiBC,CAEzD,CAEC,kBAAmBpB,EAAU,CAE5B,MAAMC,EAAM,KAAK,KAAO,KAAK,UACvBF,EAAS,KAAK,OAOpB,OANKA,GAAU,CAAEC,EAAQ,iBAAkBD,CAAM,GAM5CE,GAAO,CAAEA,EAAI,kBAAmBD,CAAO,EAEpC,GAKD,GAASD,GAAUE,EAE5B,CAEC,iBAAkBoB,EAAc,CAE/B,MAAMpB,EAAM,KAAK,KAAO,KAAK,UACvBF,EAAS,KAAK,OAOpB,OANKA,GAAU,CAAEA,EAAO,iBAAkBsB,CAAW,GAMhDpB,GAAO,CAAEA,EAAI,iBAAkBoB,CAAW,EAEvC,GAID,GAAStB,GAAUE,EAE5B,CAEC,cAAeqB,EAAW,CAEzB,MAAMrB,EAAM,KAAK,KAAO,KAAK,UACvBF,EAAS,KAAK,OAOpB,OANKA,GAAU,CAAEuB,EAAS,iBAAkBvB,CAAM,GAM7CE,GAAO,CAAEA,EAAI,cAAeqB,CAAQ,EAEjC,GAID,GAASvB,GAAUE,EAE5B,CAEC,OAAQsB,EAAWC,EAAe,CAEjC,MAAMvB,EAAM,KAAK,KAAO,KAAK,UACxBA,GAEJsB,EAAU,KAAMtB,EAAI,GAAK,EACzBuB,EAAa,KAAMvB,EAAI,SAAW,IAIlC,KAAK,QAASsB,CAAW,EACzBC,EAAa,SAAU,EAI1B,CAEC,QAASrG,EAAS,CAEjB,GAAK,KAAK,OAET,KAAK,OAAO,eAAgBA,CAAQ,MAE9B,CAEN,MAAM8E,EAAM,KAAK,KAAO,KAAK,UAC7B9E,EAAO,KAAM8E,EAAI,GAAK,EAAC,aAAcA,EAAI,SAAW,CAEvD,CAEA,CAEC,UAAW9E,EAAS,CAEnB,GAAK,KAAK,OAETA,EAAO,KAAM,KAAK,MAAQ,UAEf,KAAK,OAEhB,KAAK,OAAO,kBAAmBA,CAAQ,MAEjC,CAEN,MAAM8E,EAAM,KAAK,KAAO,KAAK,UAC7BA,EAAI,IAAI,kBAAmB9E,CAAQ,EACnCA,EAAO,aAAc8E,EAAI,SAAW,CAEvC,CAEA,CAEC,WAAY/K,EAAMiK,EAAY,CAE7B,MAAMc,EAAM,IAAIjB,GAGhB0B,EAAM,IAAKxL,EAAM,CAAG,EAAEA,EAAM,CAAG,EAAEA,EAAM,EAAK,EAC5CyL,EAAM,IAAKzL,EAAM,CAAG,EAAEA,EAAM,CAAG,EAAEA,EAAM,EAAK,EAC5C0L,EAAM,IAAK1L,EAAM,CAAG,EAAEA,EAAM,EAAI,EAAEA,EAAM,GAAM,EAE9C,MAAMuM,EAASf,EAAM,OAAQ,EACvBgB,EAASf,EAAM,OAAQ,EACvBgB,EAASf,EAAM,OAAQ,EAE7BF,EAAM,UAAW,EACjBC,EAAM,UAAW,EACjBC,EAAM,UAAW,EAGZa,IAAW,GAEff,EAAM,aAAcC,EAAOC,CAAO,EAI9Bc,IAAW,GAEff,EAAM,aAAcD,EAAOE,CAAO,EAI9Be,IAAW,GAEff,EAAM,aAAcF,EAAOC,CAAO,EAKnCV,EAAI,UACF,IACAS,EAAM,EAAGC,EAAM,EAAGC,EAAM,EAAG1L,EAAM,CAAG,EACpCwL,EAAM,EAAGC,EAAM,EAAGC,EAAM,EAAG1L,EAAM,CAAG,EACpCwL,EAAM,EAAGC,EAAM,EAAGC,EAAM,EAAG1L,EAAM,CAAG,EACpC,EAAG,EAAG,EAAG,CACb,EACI,YAAaiK,CAAW,EAG1Bc,EAAI,IAAI,IAAI,IAAK,CAAEwB,EAAQ,CAAEC,EAAQ,CAAEC,CAAQ,EAC/C1B,EAAI,IAAI,IAAI,IAAKwB,EAAQC,EAAQC,CAAQ,EACzC1B,EAAI,OAAQ,EACZ,KAAK,IAAMA,CAEb,CAEC,cAAeL,EAAGC,EAAGC,EAAG8B,EAAQzC,EAAY,CAE3C,MAAMY,EAAS,IAAI8B,GACnB9B,EAAO,OAAO,IAAKH,EAAGC,EAAGC,CAAG,EAC5BC,EAAO,OAAS6B,EAChB7B,EAAO,aAAcZ,CAAW,EAChC,KAAK,OAASY,CAEhB,CAEC,cAAe+B,EAAWC,EAAMC,EAAOC,EAAMC,EAAOC,EAAWC,EAAY,CAE1E,MAAMC,EAAS,IAAIC,GAClB,GAAGR,EAAU,OACbE,EAAOE,EACPH,EAAME,EACNE,EAAWC,CACX,EAEKnC,EAAM,IAAIjB,GAChBqD,EAAO,eAAgBpC,EAAI,IAAKA,EAAI,SAAW,EAC/CA,EAAI,OAAQ,EAEZ,KAAK,OAASoC,EACd,KAAK,UAAYpC,CAEnB,CAEA,CCrTA,MAAMsC,GAAQ,IAAIC,GAGlB,SAASC,GAAuBC,EAAQC,EAAQC,EAAQzH,EAAS,CAGhE,MAAM0H,EAAIN,GAAM,IACfG,EAAO,OAAO,EAAGA,EAAO,OAAO,EAAGA,EAAO,OAAO,EAChDC,EAAO,OAAO,EAAGA,EAAO,OAAO,EAAGA,EAAO,OAAO,EAChDC,EAAO,OAAO,EAAGA,EAAO,OAAO,EAAGA,EAAO,OAAO,CAChD,EAGD,OAAAzH,EAAO,IAAK,CAAEuH,EAAO,SAAU,CAAEC,EAAO,SAAU,CAAEC,EAAO,QAAU,EAGrEzH,EAAO,aAAc0H,EAAE,QAAU,EAE1B1H,CAER,CAEA,MAAM2H,WAAwBC,EAAQ,CAErC,aAAc,CAEb,MAAO,EACP,KAAK,OAAS,MAAO,CAAG,EAAC,KAAI,EAAG,IAAK,IAAM,IAAIrF,CAAW,CAE5D,CAEC,wBAAyBsF,EAAGC,EAAmB,CAE9C,aAAM,wBAAyBD,EAAGC,CAAkB,EACpD,KAAK,uBAAwB,EACtB,IAET,CAEC,wBAAyB,CAExB,KAAM,CAAE,OAAAC,EAAQ,OAAA1D,CAAM,EAAK,KACA,CAC1B,CAAE0D,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,EAAK,EACzC,CAAEA,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,EAAK,EACzC,CAAEA,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,EAAK,EACzC,CAAEA,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,EAAK,EACzC,CAAEA,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,EAAK,EACzC,CAAEA,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,EAAK,EACzC,CAAEA,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,EAAK,EACzC,CAAEA,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,EAAK,CACzC,EAEkB,QAAS,CAAEA,EAAQ7P,IAAW,CAEhDoP,GAAuBS,EAAQ,CAAG,EAAEA,EAAQ,GAAKA,EAAQ,CAAC,EAAI1D,EAAQnM,CAAK,CAAI,CAElF,CAAK,CAEL,CAEA,CC5DO,SAAS8P,GAA0BC,EAAM,CAI/C,KAAM,CAAE,aAAAC,CAAY,EAAKC,GACzB,GAAK,CAAED,GAAgB,CAAED,EAExB,MAAO,GAKR,KAAM,CAAE,OAAAG,EAAQ,KAAAC,EAAM,MAAAC,CAAO,EAAGL,EAC1B,CAAE,MAAAM,EAAO,OAAAC,CAAM,EAAKF,EAE1B,IAAI3Q,EAAQuQ,EAAa,cAAeK,EAAOC,EAAQJ,EAAQC,CAAM,EACrE,OAAA1Q,GAASsQ,EAAI,gBAAkB,EAAI,EAAI,EAEhCtQ,CAGR,CAGO,SAAS8Q,GAAmBC,EAAS,CAE3C,MAAMC,EAAY,IAAI,IAEtB,IAAIC,EAAa,EACjB,OAAAF,EAAO,SAAUtM,GAAK,CAWrB,GARKA,EAAE,UAAY,CAAEuM,EAAU,IAAKvM,EAAE,YAErCwM,GAAcC,GAAoBzM,EAAE,QAAU,EAC9CuM,EAAU,IAAKvM,EAAE,QAAU,GAKvBA,EAAE,SAAW,CAEjB,MAAM0M,EAAW1M,EAAE,SACnB,UAAY2M,KAAOD,EAAW,CAE7B,MAAM3Q,EAAQ2Q,EAAUC,CAAK,EACxB5Q,GAASA,EAAM,WAAa,CAAEwQ,EAAU,IAAKxQ,KAEjDyQ,GAAcZ,GAA0B7P,CAAO,EAC/CwQ,EAAU,IAAKxQ,CAAO,EAI3B,CAEA,CAEA,CAAI,EAEIyQ,CAER,CCzCA,MAAMI,GAAO,IAAI1H,EACX2H,GAAS,IAAIC,GAGbC,GAAyB,OAAQ,wBAA0B,EAC3D9H,EAAU,IAAIC,EACd8H,EAAa,IAAI7G,EACjB8G,EAAc,IAAIC,GAClB5O,EAAkB,CACvB,OAAQ,GACR,MAAO,GACR,EAEM6O,GAAS,IAAIhH,EAAS,EAAG,EAAG,CAAG,EAC/BiH,GAAS,IAAIjH,EAAS,EAAG,EAAG,CAAG,EAErC,SAASkH,GAAqBf,EAAQgB,EAAiB,CAEtDhB,EAAO,SAAUtM,GAAK,CAErBA,EAAE,cAAgBA,EAAG+M,EAAwB,GAAIO,CAEnD,CAAI,CAEJ,CAEO,MAAMC,WAAsB/L,EAAkB,CAEpD,IAAI,4BAA6B,CAEhC,OAAO,KAAK,2BAEd,CAEC,IAAI,2BAA4BzF,EAAQ,CAElC,KAAK,8BAAgCA,IAEzC,MAAM,4BAA8BA,EACpC,KAAK,mBAAsBoH,GAAW,CAErCkK,GAAqBlK,EAAO,CAAEpH,CAAO,CAEzC,CAAM,EAIN,CAEC,IAAI,iBAAkB,CAErB,OAAO,KAAK,gBAEd,CAEC,IAAI,gBAAiB8F,EAAI,CAExB,QAAQ,KAAM,kEAAoE,EAClF,KAAK,iBAAmBA,CAE1B,CAEC,eAAgBc,EAAO,CAEtB,MAAO,GAAGA,CAAM,EAChB,KAAK,MAAQ,IAAIwC,GAAY,IAAM,EACnC,KAAK,UAAYqI,GAAgB,MAAO,EACxC,KAAK,QAAU,CAAE,EACjB,KAAK,UAAY,IAAI,IACrB,KAAK,WAAa,CAAE,EACpB,KAAK,iBAAmB,GACxB,KAAK,kBAAoB,IAAItI,EAC7B,KAAK,WAAa,IAAI,QAGtB,KAAK,4BAA8B,GAEnC,MAAMuI,EAAU,IAAIC,GACpBD,EAAQ,eAAgB9S,GAElB,KAAK,cAEF,KAAK,cAAeA,CAAK,EAIzBA,CAIN,EACH,KAAK,QAAU8S,EAGf,KAAK,WAAa,CAAE,CAEtB,CAEC,oBAAqB9K,EAAO,CAE3BgL,EAAgB,UAAU,iBAAiB,KAAM,KAAM,GAAGhL,CAAM,CAElE,CAEC,oBAAqBA,EAAO,CAE3BgL,EAAgB,UAAU,iBAAiB,KAAM,KAAM,GAAGhL,CAAM,CAElE,CAEC,uBAAwBA,EAAO,CAE9BgL,EAAgB,UAAU,oBAAoB,KAAM,KAAM,GAAGhL,CAAM,CAErE,CAEC,iBAAkBA,EAAO,CAExBgL,EAAgB,UAAU,cAAc,KAAM,KAAM,GAAGhL,CAAM,CAE/D,CAGC,eAAgBiB,EAAS,CAExB,GAAK,CAAE,KAAK,KAEX,MAAO,GAIR,MAAMwD,EAAiB,KAAK,KAAK,OAAO,eACxC,OAAKA,GAEJA,EAAe,QAASxD,CAAQ,EACzB,IAIA,EAIV,CAEC,uBAAwBoG,EAAWC,EAAe,CAEjD,GAAK,CAAE,KAAK,KAEX,MAAO,GAIR,MAAM7C,EAAiB,KAAK,KAAK,OAAO,eACxC,OAAKA,GAEJA,EAAe,OAAQ4C,EAAWC,CAAc,EACzC,IAIA,EAIV,CAEC,kBAAmBrG,EAAS,CAE3B,GAAK,CAAE,KAAK,KAEX,MAAO,GAIR,MAAMwD,EAAiB,KAAK,KAAK,OAAO,eACxC,OAAKA,GAEJA,EAAe,UAAWxD,CAAQ,EAC3B,IAIA,EAIV,CAEC,mBAAoBlG,EAAW,CAE9B,KAAK,SAAUkB,GAAQ,CAEtB,MAAMuE,EAAQvE,EAAK,QAAUA,EAAK,OAAO,MACpCuE,GAEJzF,EAAUyF,EAAOvE,CAAM,CAI3B,EAAK,KAAM,EAAO,CAElB,CAEC,QAAS0G,EAAWC,EAAa,CAEhC,GAAO,KAAK,KAMZ,GAAKD,EAAU,aAAe,CAE7B,MAAMkB,EAAME,GAAyB,KAAM,KAAK,KAAMpB,CAAW,EAC5DkB,GAEJjB,EAAW,KAAMiB,CAAK,CAI1B,MAEGW,GAAiB,KAAM,KAAK,KAAM7B,EAAWC,CAAY,CAI5D,CAEC,UAAWqI,EAAS,CAEnB,OAAO,KAAK,UAAU,IAAKA,CAAQ,CAErC,CAEC,UAAWA,EAAS,CAEnB,MAAMC,EAAU,KAAK,QACfC,EAAY,KAAK,UACvB,OAAOA,EAAU,IAAKF,GASf,IAPNE,EAAU,IAAKF,EAAQ,IAAIV,EAAW,EACtCW,EAAQ,KAAMD,CAAQ,EACtB,KAAK,cAAe,CAAE,KAAM,aAAc,OAAAA,CAAM,CAAI,EAE7C,GAKV,CAEC,cAAeA,EAAQG,EAAQzF,EAAI,CAElC,MAAMwF,EAAY,KAAK,UACvB,GAAK,CAAEA,EAAU,IAAKF,GAErB,MAAO,GAIR,MAAMzB,EAAQ4B,EAAO,UAAYA,EAAO,EAAIA,EACtC3B,EAAS2B,EAAO,UAAYA,EAAO,EAAIzF,EACvC0F,EAAYF,EAAU,IAAKF,CAAQ,EAEzC,OAAKI,EAAU,QAAU7B,GAAS6B,EAAU,SAAW5B,KAEtD4B,EAAU,IAAK7B,EAAOC,CAAQ,EAC9B,KAAK,cAAe,CAAE,KAAM,0BAA0B,CAAI,GAIpD,EAET,CAEC,0BAA2BwB,EAAQ5O,EAAW,CAE7C,OAAAA,EAAS,QAASiO,CAAa,EAExB,KAAK,cAAeW,EAAQX,EAAY,EAAGA,EAAY,CAAG,CAEnE,CAEC,aAAcW,EAAS,CAEtB,MAAMC,EAAU,KAAK,QACfC,EAAY,KAAK,UACvB,GAAKA,EAAU,IAAKF,GAAW,CAE9B,MAAM9R,EAAQ+R,EAAQ,QAASD,CAAQ,EACvC,OAAAC,EAAQ,OAAQ/R,EAAO,CAAG,EAC1BgS,EAAU,OAAQF,CAAQ,EAC1B,KAAK,cAAe,CAAE,KAAM,gBAAiB,OAAAA,CAAM,CAAI,EAEhD,EAEV,CACE,MAAO,EAET,CAGC,mBAAoBjL,EAAO,CAE1B,OAAO,MAAM,gBAAiB,GAAGA,CAAI,EACnC,KAAMC,GAAQ,CAGd,KAAM,CAAE,MAAAqL,EAAO,WAAAC,EAAa,CAAA,CAAI,EAAGtL,EAEnC,QADeqL,GAASA,EAAM,YAAc,KAC5B,YAAa,EAAA,CAE5B,IAAK,IACJ,KAAK,kBAAkB,iBAAkBb,GAAQ,CAAE,KAAK,GAAK,CAAG,EAChE,MAED,IAAK,IACJ,KAAK,kBAAkB,iBAAkBD,GAAQ,KAAK,GAAK,CAAG,EAC9D,KAEN,CAGI,GAAK,sBAAuBe,EAAa,CAExC,MAAMC,EAAMD,EAAY,mBAAqB,EACvC,CAAE,UAAA3D,CAAS,EAAK,KACtBA,EAAU,KAAO4D,EAAI,KAChBA,EAAI,MAER5D,EAAU,OAAO,IAAK,GAAG4D,EAAI,KAAO,EAIpC5D,EAAU,OAAO,IAAK,EAAG,EAAG,CAAG,CAIrC,CAEI,OAAO3H,CAEX,CAAM,CAEN,CAEC,QAAS,CAGR,IAAIwL,EAAc,KAoBlB,GAnBA,KAAK,iBAAkBrN,GAAU,CAEhC,GAAKA,EAAO,kBAAoB,CAE/B,MAAMsD,EAAMtD,EAAO,kBAAmB,EACjCqN,IAAgB,KAEpBA,EAAc/J,EAId+J,EAAc,GAASA,GAAe/J,EAI3C,CAEA,CAAK,EAEE+J,IAAgB,GAAQ,CAE5B,KAAK,cAAe,CAAE,KAAM,eAAe,CAAI,EAC/C,KAAK,cAAe,CAAE,KAAM,cAAc,CAAI,EAC9C,MAEH,CAGE,KAAK,cAAe,CAAE,KAAM,eAAe,CAAI,EAE/C,MAAMxH,EAAQ,KAAK,MACbiH,EAAU,KAAK,QACfC,EAAY,KAAK,UACjBO,EAAa,KAAK,WAGxB,KAAQA,EAAW,OAASR,EAAQ,QAEnCQ,EAAW,IAAK,EAIjB,KAAQA,EAAW,OAASR,EAAQ,QAEnCQ,EAAW,KAAM,CAEhB,QAAS,IAAI9C,GACb,eAAgB,GAChB,eAAgB,GAChB,SAAU,IAAIpF,EACd,SAAU,GACV,UAAW,CAEf,CAAM,EAKJ6G,EAAW,mBAAoBpG,EAAM,kBAAoB,EACpD,KAAK,IAAK,KAAK,IAAKoG,EAAW,EAAIA,EAAW,EAAGA,EAAW,EAAIA,EAAW,CAAG,CAAA,EAAK,MAEvF,QAAQ,KAAM,kHAAoH,EAKnI,QAAUhP,EAAI,EAAGoB,EAAIiP,EAAW,OAAQrQ,EAAIoB,EAAGpB,IAAO,CAErD,MAAM4P,EAASC,EAAS7P,CAAG,EACrBF,EAAOuQ,EAAYrQ,CAAG,EACtByK,EAAU3K,EAAK,QACfwQ,EAAWxQ,EAAK,SAChByQ,EAAaT,EAAU,IAAKF,CAAQ,GAErCW,EAAW,QAAU,GAAKA,EAAW,SAAW,IAEpD,QAAQ,KAAM,oEAAsE,EAKrF,MAAMC,EAAaZ,EAAO,iBAAiB,SAK3C,GAFA9P,EAAK,eAAiB0Q,EAAY,EAAI,IAAK,EAEtC1Q,EAAK,eAAiB,CAI1B,MAAM2Q,EAAI,EAAID,EAAY,CAAG,EACvBE,EAAI,EAAIF,EAAY,CAAG,EAC7B1Q,EAAK,UAAY,KAAK,IAAK4Q,EAAIH,EAAW,OAAQE,EAAIF,EAAW,KAAO,CAE5E,MAIIzQ,EAAK,eAAmB,EAAI0Q,EAAY,CAAC,EAAOD,EAAW,OAK5DtJ,EAAQ,KAAM2B,EAAM,WAAa,EACjC3B,EAAQ,YAAa2I,EAAO,kBAAoB,EAChD3I,EAAQ,YAAa2I,EAAO,gBAAkB,EAE9CnF,EAAQ,wBAAyBxD,CAAS,EAG1CqJ,EAAS,IAAK,EAAG,EAAG,CAAG,EACvBA,EAAS,aAAcV,EAAO,WAAa,EAC3CU,EAAS,aAAc1H,EAAM,kBAAoB,CAEpD,CAOE,GALA,MAAM,OAAQ,EAEd,KAAK,cAAe,CAAE,KAAM,cAAc,CAAI,EAGzCiH,EAAQ,SAAW,GAAK,KAAK,KAAO,CAExC,IAAIc,EAAQ,GACZ,KAAK,iBAAkB5N,GAAU4N,EAAQA,GAAS,GAAS5N,IAAW,MAAQA,EAAO,uBAA0B,EAC1G4N,IAAU,IAEd,QAAQ,KAAM,4DAA8D,CAIhF,CAEA,CAEC,eAAgB/P,EAAM2E,EAAYC,EAAa,KAAO,CAErD,MAAM,eAAgB5E,EAAM2E,EAAYC,CAAY,EAEpD,MAAMoE,EAAY,IAAI1C,EACtB,GAAKtG,EAAK,UAAY,CAErB,MAAMgQ,EAAehQ,EAAK,UAC1B,QAAUZ,EAAI,EAAGA,EAAI,GAAIA,IAExB4J,EAAU,SAAU5J,GAAM4Q,EAAc5Q,CAAG,CAI/C,CAEOwF,GAEJoE,EAAU,YAAapE,EAAW,OAAO,SAAW,EAIrD,MAAMqL,EAAmB,IAAI3J,EAAO,EAAG,KAAM0C,CAAW,EAAC,OAAQ,EAC3DR,EAAiB,IAAIoC,GACtB,WAAY5K,EAAK,gBAErBwI,EAAe,cAAe,GAAGxI,EAAK,eAAe,OAAQgJ,CAAW,EAIpE,QAAShJ,EAAK,gBAElBwI,EAAe,WAAYxI,EAAK,eAAe,IAAKgJ,CAAW,EAI3D,WAAYhJ,EAAK,gBAErBwI,EAAe,cAAe,KAAK,UAAW,GAAGxI,EAAK,eAAe,MAAQ,EAI9EA,EAAK,OAAS,CAEb,UAAAgJ,EACA,iBAAAiH,EAEA,OAAQ,GAER,eAAAzH,EAEA,SAAU,KACV,MAAO,KACP,SAAU,KACV,UAAW,KACX,SAAU,IAEV,CAEH,CAEC,MAAM,UAAW/D,EAAQzE,EAAM0E,EAAWkB,EAAKsK,EAAc,CAE5D,MAAMC,EAASnQ,EAAK,OACdoQ,EAAYxK,EAAI,MAAO,QAAU,EACvCwK,EAAU,IAAK,EACf,MAAMC,EAAcD,EAAU,KAAM,GAAK,EACnCE,EAAe,KAAK,aAEpBzB,EAAU,KAAK,QACrB,IAAI0B,EAAU,KAEd,MAAMC,EAAkBL,EAAO,UACzBM,EAAmB,KAAK,kBACxBC,GAAaC,GAAgBlM,CAAM,GAAMC,GAAY,YAAa,EACxE,OAASgM,EAAQ,CAEhB,IAAK,OAAQ,CAEZ,MAAME,EAAS,IAAIC,GAAYhC,CAAS,EACxC+B,EAAO,YAAcP,EACrBO,EAAO,aAAeN,EAEtBM,EAAO,oBAAoB,KAAMH,CAAkB,EAEnDF,EAAUK,EAAO,MAAOnM,CAAQ,EAChC,KAEJ,CAEG,IAAK,OAAQ,CAEZ,MAAMmM,EAAS,IAAIE,GAAYjC,CAAS,EACxC+B,EAAO,YAAcP,EACrBO,EAAO,aAAeN,EACtBC,EAAUK,EAAO,MAAOnM,CAAQ,EAChC,KAEJ,CAEG,IAAK,OAAQ,CAEZ,MAAMmM,EAAS,IAAIG,GAAYlC,CAAS,EACxC+B,EAAO,YAAcP,EACrBO,EAAO,aAAeN,EAEtBM,EAAO,oBAAoB,KAAMH,CAAkB,EACnDG,EAAO,UAAU,KAAM,KAAK,SAAW,EAEvCL,EAAUK,EAAO,MAAOnM,CAAQ,EAChC,KAEJ,CAEG,IAAK,OAAQ,CAEZ,MAAMmM,EAAS,IAAII,GAAYnC,CAAS,EACxC+B,EAAO,YAAcP,EACrBO,EAAO,aAAeN,EAEtBM,EAAO,oBAAoB,KAAMH,CAAkB,EACnDG,EAAO,UAAU,KAAM,KAAK,SAAW,EAEvCL,EAAUK,EACR,MAAOnM,CAAM,EACb,KAAMgB,GAAOA,EAAI,KAAO,EAC1B,KAEJ,CAGG,IAAK,OACL,IAAK,MAAO,CAEX,MAAMmL,EAAS/B,EAAQ,WAAY,WAAa,GAAIA,EAAQ,WAAY,UAAU,GAAM,IAAIoC,GAAYpC,CAAS,EACjH+B,EAAO,mBAAoBN,EAAa,cAAgB,SAAW,EACnEM,EAAO,iBAAkBN,EAAa,SAAW,CAAA,CAAI,EAChDA,EAAa,cAAgB,WAAaA,EAAa,OAAS,QAEpEM,EAAO,eAAgB,iBAAmB,EAM3C,IAAIM,EAAeN,EAAO,cAAgBA,EAAO,MAAQP,EACpD,CAAE,SAAS,KAAMa,CAAY,GAAMA,EAAa,SAEpDA,GAAgB,KAIjBX,EAAUK,EAAO,WAAYnM,EAAQyM,CAAc,EAAC,KAAM1R,GAAU,CAGnEA,EAAO,MAAQA,EAAO,OAAS,IAAIgH,GAOnC,KAAM,CAAE,MAAAjC,CAAK,EAAK/E,EAClB,OAAA+E,EAAM,aAAc,EACpBA,EAAM,OACJ,SAAUkM,CAAgB,EAC1B,UAAWlM,EAAM,SAAUA,EAAM,WAAYA,EAAM,KAAO,EAErD/E,CAEZ,CAAO,EACH,KAEJ,CAEG,QAAS,CAER+Q,EAAU,KAAK,gBAAiBpO,GAAUA,EAAO,aAAeA,EAAO,YAAasC,EAAQzE,EAAM0E,EAAWkB,EAAKsK,CAAW,CAAI,EACjI,KAEJ,CAEA,CAGE,MAAM1Q,EAAS,MAAM+Q,EACrB,GAAK/Q,IAAW,KAEf,MAAM,IAAI,MAAO,gCAAiCkR,CAAQ,kBAAqB,EAKhF,IAAInM,EACA4M,EACC3R,EAAO,YAEX+E,EAAQ/E,EACR2R,EAAW,OAIX5M,EAAQ/E,EAAO,MACf2R,EAAW3R,GAKZ+E,EAAM,aAAc,EACpBA,EAAM,OAAO,YAAaiM,CAAiB,EAC3CjM,EAAM,OAAO,UAAWA,EAAM,SAAUA,EAAM,WAAYA,EAAM,KAAO,EAGvE,MAAM,KAAK,iBAAkBpC,GAErBA,EAAO,kBAAoBA,EAAO,iBAAkBoC,EAAOvE,CAAM,CAEtE,EAGHuE,EAAM,SAAUnD,GAAK,CAEpBA,EAAG+M,IAA2B/M,EAAE,aAEnC,CAAK,EACHqN,GAAqBlK,EAAO,CAAE,KAAK,0BAA4B,EAG/D,MAAM6M,EAAY,CAAE,EACdC,EAAW,CAAE,EACbC,EAAW,CAAE,EA8BnB,GA7BA/M,EAAM,SAAUnD,GAAK,CAQpB,GANKA,EAAE,UAENiQ,EAAS,KAAMjQ,EAAE,QAAU,EAIvBA,EAAE,SAAW,CAEjB,MAAM0M,EAAW1M,EAAE,SACnBgQ,EAAU,KAAMhQ,EAAE,QAAU,EAE5B,UAAY2M,KAAOD,EAAW,CAE7B,MAAM3Q,EAAQ2Q,EAAUC,CAAK,EACxB5Q,GAASA,EAAM,WAEnBmU,EAAS,KAAMnU,CAAO,CAI5B,CAEA,CAEA,CAAK,EAGE+S,EAAY,QAAU,CAK1B,QAAU9Q,EAAI,EAAGoB,EAAI8Q,EAAS,OAAQlS,EAAIoB,EAAGpB,IAAO,CAEnD,MAAMmS,EAAUD,EAAUlS,CAAG,EAExBmS,EAAQ,iBAAiB,aAE7BA,EAAQ,MAAM,MAAO,EAItBA,EAAQ,QAAS,CAErB,CAEG,MAEH,CAEEpB,EAAO,UAAYiB,EACnBjB,EAAO,SAAWkB,EAClBlB,EAAO,SAAWmB,EAClBnB,EAAO,MAAQ5L,EACf4L,EAAO,SAAWgB,CAEpB,CAEC,YAAanR,EAAO,CAEnB,MAAM,YAAaA,CAAM,EAGzB,MAAMmQ,EAASnQ,EAAK,OACpB,GAAKmQ,EAAO,MAAQ,CAEnB,MAAMiB,EAAYjB,EAAO,UACnBkB,EAAWlB,EAAO,SAClBmB,EAAWnB,EAAO,SAClBnP,EAASmP,EAAO,MAAM,OAK5BA,EAAO,MAAM,SAAUjL,GAAS,CAE1BA,EAAM,SAAS,cAEnBA,EAAM,SAAS,aAAa,QAAS,EAIjCA,EAAM,SAAS,oBAEnBA,EAAM,SAAS,mBAAmB,QAAS,CAIhD,CAAM,EAEH,QAAU9F,EAAI,EAAG,EAAIiS,EAAS,OAAQjS,EAAI,EAAGA,IAE5CiS,EAAUjS,CAAG,EAAC,QAAS,EAIxB,QAAUA,EAAI,EAAG,EAAIgS,EAAU,OAAQhS,EAAI,EAAGA,IAE7CgS,EAAWhS,CAAG,EAAC,QAAS,EAIzB,QAAUA,EAAI,EAAG,EAAIkS,EAAS,OAAQlS,EAAI,EAAGA,IAAO,CAEnD,MAAMmS,EAAUD,EAAUlS,CAAG,EAExBmS,EAAQ,iBAAiB,aAE7BA,EAAQ,MAAM,MAAO,EAItBA,EAAQ,QAAS,CAErB,CAEQvQ,GAEJA,EAAO,OAAQmP,EAAO,KAAO,EAI9B,KAAK,cAAe,CACnB,KAAM,gBACN,MAAOA,EAAO,MACd,KAAAnQ,CACJ,CAAM,EAEHmQ,EAAO,MAAQ,KACfA,EAAO,UAAY,KACnBA,EAAO,SAAW,KAClBA,EAAO,SAAW,KAClBA,EAAO,SAAW,IAErB,CAEA,CAEC,eAAgBnQ,EAAM+E,EAAU,CAE/B,MAAMR,EAAQvE,EAAK,OAAO,MACpBgI,EAAQ,KAAK,MAEdjD,EAECR,IAEJyD,EAAM,IAAKzD,CAAO,EAClBA,EAAM,kBAAmB,EAAM,GAM3BA,GAEJyD,EAAM,OAAQzD,CAAO,EAMvB,MAAM,eAAgBvE,EAAM+E,CAAS,EAErC,KAAK,cAAe,CACnB,KAAM,yBACN,MAAAR,EACA,KAAAvE,EACA,QAAA+E,CACH,CAAK,CAEL,CAEC,mBAAoB/E,EAAMuE,EAAQ,CAEjC,MAAM4B,EAAY,KAAK,WACvB,MAAK,CAAEA,EAAU,IAAKnG,CAAI,GAAMuE,GAE/B4B,EAAU,IAAKnG,EAAMyN,GAAmBlJ,CAAK,CAAI,EAI3C4B,EAAU,IAAKnG,CAAI,GAAM,IAElC,CAEC,uBAAwBA,EAAMgF,EAAS,CAEtC,MAAMmL,EAASnQ,EAAK,OACdiP,EAAU,KAAK,QACfQ,EAAa,KAAK,WAClBjH,EAAiB2H,EAAO,eAE9B,IAAIqB,EAAS,GACTC,EAAc,KACdC,EAAiB,IACjBC,EAAW,KACXC,EAAc,IAElB,QAAUxS,EAAI,EAAGoB,EAAIyO,EAAQ,OAAQ7P,EAAIoB,EAAGpB,IAAO,CAGlD,MAAMF,EAAOuQ,EAAYrQ,CAAG,EAC5B,IAAI+E,EACA0N,EACJ,GAAK3S,EAAK,eAAiB,CAE1B,MAAM4S,EAAY5S,EAAK,UACvBiF,EAAQnE,EAAK,eAAiB8R,EAC9BD,EAAW,GAEf,KAAU,CAIN,MAAME,EAAiB7S,EAAK,eAC5B2S,EAAWrJ,EAAe,gBAAiBtJ,EAAK,QAAU,EAC1DiF,EAAQ0N,IAAa,EAAI,IAAW7R,EAAK,gBAAmB6R,EAAWE,EAE3E,CAIG,MAAMlI,EAAU4F,EAAYrQ,CAAC,EAAG,QAC3BoJ,EAAe,kBAAmBqB,KAEtC2H,EAAS,GACTC,EAAc,KAAK,IAAKA,EAAatN,CAAO,EAC5CuN,EAAiB,KAAK,IAAKA,EAAgBG,CAAU,GAItDF,EAAW,KAAK,IAAKA,EAAUxN,CAAO,EACtCyN,EAAc,KAAK,IAAKA,EAAaC,CAAU,CAElD,CAGE,KAAK,iBAAkB1P,GAAU,CAE3BA,IAAW,MAAQA,EAAO,yBAE9BA,EAAO,uBAAwBnC,EAAMN,CAAiB,EACjDA,EAAgB,SAEpB8R,EAAS,GACTC,EAAc,KAAK,IAAKA,EAAa/R,EAAgB,KAAO,GAI7DiS,EAAW,KAAK,IAAKA,EAAUjS,EAAgB,KAAO,EAI1D,CAAK,EAGE8R,GAEJxM,EAAO,OAAS,GAChBA,EAAO,MAAQyM,EACfzM,EAAO,mBAAqB0M,IAI5B1M,EAAO,OAAS,GAChBA,EAAO,MAAQ2M,EACf3M,EAAO,mBAAqB4M,EAI/B,CAGC,eAAgBI,EAAKC,EAAM,CAE1B,QAAQ,KAAM,oFAAsF,EAEpG,KAAM,CAAE,UAAAtG,EAAW,MAAA3D,CAAK,EAAK,KAE7BiG,GAAO,IAAK,KAAK,GAAK,EAAG,KAAK,GAAK,EAAG,CAAG,EACzCD,GAAK,sBAAuBC,EAAQ,EAEpCtC,EAAU,oBAAqBqG,EAAKC,EAAK,EAAGjK,EAAM,MAAM,EACtD,SAAUgG,EAAI,EACd,OAAM,EACN,UACAhG,EAAM,SACNA,EAAM,WACNA,EAAM,KACN,EAEFA,EAAM,kBAAmB,EAAM,CAEjC,CAEC,SAAU,CAET,MAAM,QAAS,EACf,KAAK,MAAM,iBAAkB,CAE/B,CAEA"}