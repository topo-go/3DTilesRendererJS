import{j as N,k as D,l as R,m as H,h as j,B as V,d as $,n as k,o as v,p as q,q as Q,W as X,S as Z,a as J,O as K,M as y}from"./three.module-CQU0seT4.js";/* empty css               */import{D as Y}from"./DRACOLoader-BRrjJKJj.js";import{g as ee}from"./lil-gui.module.min-Vka56b52.js";import{S as te}from"./stats.module--VATS4Kh.js";import{T as ae}from"./TopoLinesPlugin-CY-r0AnE.js";import{U as ie}from"./UnloadTilesPlugin-C6lJ6nje.js";import{F as ne,G as se}from"./GLTFExtensionsPlugin-DKG5_O3O.js";import{C as re}from"./CameraTransitionManager-BIWFAn1E.js";import{G as oe}from"./GlobeControls-CKSk7BfI.js";import{W as P}from"./I3DMLoader--guqwtSo.js";import{C as W,t as ce}from"./Ellipsoid-BKsGN9dG.js";import{T as de}from"./TilesRenderer-Dt06WWnf.js";import{C as le}from"./CesiumIonAuthPlugin-DL6JcDIR.js";import{T as he}from"./TileCompressionPlugin-D2vhaUyU.js";import{U as me}from"./UpdateOnChangePlugin-Dcw2gdwr.js";import{T as ue}from"./TilesFadePlugin-D_u_P2Qt.js";import"./GLTFLoader-Bzr6GmPM.js";import"./EnvironmentControls-CLbQ_1-I.js";import"./readMagicBytes-ReGFEf36.js";import"./B3DMLoader-BZtrZCNg.js";import"./PNTSLoader-gB5YPyhc.js";import"./CMPTLoader-VEto4VOC.js";import"./EllipsoidRegion-BEIhCuST.js";import"./GeometryClipper-DDKqlNfA.js";import"./EPSGTilesPlugin-DJF9gzHX.js";import"./ImageFormatPlugin-gd2xpo9t.js";import"./TMSImageSource-BwMpBOyS.js";import"./TiledImageSource-Dter0Emb.js";const A=new D,B=new R,F=new R;class pe extends N{constructor(...e){super(...e),this.resetDistance=1e4,this._matricesTextureHandle=null,this._lastCameraPos=new D,this._forceUpdate=!0,this._matrices=[]}setMatrixAt(e,t){super.setMatrixAt(e,t),this._forceUpdate=!0;const a=this._matrices;for(;a.length<=e;)a.push(new D);a[e].copy(t)}setInstanceCount(...e){super.setInstanceCount(...e);const t=this._matrices;for(;t.length>this.instanceCount;)t.pop()}onBeforeRender(e,t,a,i,l,s){super.onBeforeRender(e,t,a,i,l,s),B.setFromMatrixPosition(a.matrixWorld),F.setFromMatrixPosition(this._lastCameraPos);const o=this._matricesTexture;let r=this._modelViewMatricesTexture;if((!r||r.image.width!==o.image.width||r.image.height!==o.image.height)&&(r&&r.dispose(),r=o.clone(),r.source=new H({...r.image,data:r.image.data.slice()}),this._modelViewMatricesTexture=r),this._forceUpdate||B.distanceTo(F)>this.resetDistance){const h=this._matrices,m=r.image.data;for(let u=0;u<this.maxInstanceCount;u++){const p=h[u];p?A.copy(p):A.identity(),A.premultiply(this.matrixWorld).premultiply(a.matrixWorldInverse).toArray(m,u*16)}r.needsUpdate=!0,this._lastCameraPos.copy(a.matrixWorld),this._forceUpdate=!1}this._matricesTextureHandle=this._matricesTexture,this._matricesTexture=this._modelViewMatricesTexture,this.matrixWorld.copy(this._lastCameraPos)}onAfterRender(){this.updateMatrixWorld(),this._matricesTexture=this._matricesTextureHandle,this._matricesTextureHandle=null}onAfterShadow(e,t,a,i,l,s){this.onAfterRender(e,null,i,l,s)}dispose(){super.dispose(),this._modelViewMatricesTexture&&this._modelViewMatricesTexture.dispose()}}const T=new j,_=[];class ge extends pe{constructor(...e){super(...e),this.expandPercent=.25,this.maxInstanceExpansionSize=1/0,this._freeGeometryIds=[]}findFreeId(e,t,a){const i=!!this.geometry.index,l=Math.max(i?e.index.count:-1,a),s=Math.max(e.attributes.position.count,t);let o=-1,r=1/0;const h=this._freeGeometryIds;if(h.forEach((m,u)=>{const p=this.getGeometryRangeAt(m),{reservedIndexCount:g,reservedVertexCount:x}=p;if(g>=l&&x>=s){const M=l-g+(s-x);M<r&&(o=u,r=M)}}),o!==-1){const m=h[o];return h.splice(o,1),m}else return-1}addGeometry(e,t,a){const i=!!this.geometry.index;a=Math.max(i?e.index.count:-1,a),t=Math.max(e.attributes.position.count,t);const{expandPercent:l,_freeGeometryIds:s}=this;let o=this.findFreeId(e,t,a);if(o!==-1)this.setGeometryAt(o,e);else{const r=()=>{const u=this.unusedVertexCount<t,p=this.unusedIndexCount<a;return u||p},h=e.index,m=e.attributes.position;if(t=Math.max(t,m.count),a=Math.max(a,h?h.count:0),r()&&(s.forEach(u=>this.deleteGeometry(u)),s.length=0,this.optimize(),r())){const u=this.geometry.index,p=this.geometry.attributes.position;let g,x;if(u){const M=Math.ceil(l*u.count);g=Math.max(M,a,h.count)+u.count}else g=Math.max(this.unusedIndexCount,a);if(p){const M=Math.ceil(l*p.count);x=Math.max(M,t,m.count)+p.count}else x=Math.max(this.unusedVertexCount,t);this.setGeometrySize(x,g)}o=super.addGeometry(e,t,a)}return o}addInstance(e){if(this.maxInstanceCount===this.instanceCount){const t=Math.ceil(this.maxInstanceCount*(1+this.expandPercent));this.setInstanceCount(Math.min(t,this.maxInstanceExpansionSize))}return super.addInstance(e)}deleteInstance(e){const t=this.getGeometryIdAt(e);return t!==-1&&this._freeGeometryIds.push(t),super.deleteInstance(e)}raycastInstance(e,t,a){const i=this.geometry,l=this.getGeometryIdAt(e);T.material=this.material,T.geometry.index=i.index,T.geometry.attributes=i.attributes;const s=this.getGeometryRangeAt(l);T.geometry.setDrawRange(s.start,s.count),T.geometry.boundingBox===null&&(T.geometry.boundingBox=new V),T.geometry.boundingSphere===null&&(T.geometry.boundingSphere=new $),this.getMatrixAt(e,T.matrixWorld).premultiply(this.matrixWorld),this.getBoundingBoxAt(l,T.geometry.boundingBox),this.getBoundingSphereAt(l,T.geometry.boundingSphere),T.raycast(t,_);for(let o=0,r=_.length;o<r;o++){const h=_[o];h.object=this,h.batchId=e,a.push(h)}_.length=0}}function xe(c){return c.r===1&&c.g===1&&c.b===1}function fe(c){c.needsUpdate=!0,c.onBeforeCompile=e=>{e.vertexShader=e.vertexShader.replace("#include <common>",`
				#include <common>
				varying float texture_index;
				`).replace("#include <uv_vertex>",`
				#include <uv_vertex>
				texture_index = getIndirectIndex( gl_DrawID );
				`),e.fragmentShader=e.fragmentShader.replace("#include <map_pars_fragment>",`
				#ifdef USE_MAP
				precision highp sampler2DArray;
				uniform sampler2DArray map;
				varying float texture_index;
				#endif
				`).replace("#include <map_fragment>",`
				#ifdef USE_MAP
					diffuseColor *= texture( map, vec3( vMapUv, texture_index ) );
				#endif
				`)}}const E=new ne(new Q),U=new q(new Uint8Array([255,255,255,255]),1,1);U.needsUpdate=!0;class Ce{constructor(e={}){if(parseInt(k)<170)throw new Error("BatchedTilesPlugin: Three.js revision 170 or higher required.");e={instanceCount:500,vertexCount:750,indexCount:2e3,expandPercent:.25,maxInstanceCount:1/0,discardOriginalContent:!0,textureSize:null,material:null,renderer:null,...e},this.name="BATCHED_TILES_PLUGIN",this.priority=-1;const t=e.renderer.getContext();this.instanceCount=e.instanceCount,this.vertexCount=e.vertexCount,this.indexCount=e.indexCount,this.material=e.material?e.material.clone():null,this.expandPercent=e.expandPercent,this.maxInstanceCount=Math.min(e.maxInstanceCount,t.getParameter(t.MAX_3D_TEXTURE_SIZE)),this.renderer=e.renderer,this.discardOriginalContent=e.discardOriginalContent,this.textureSize=e.textureSize,this.batchedMesh=null,this.arrayTarget=null,this.tiles=null,this._onLoadModel=null,this._onDisposeModel=null,this._onVisibilityChange=null,this._tileToInstanceId=new Map}init(e){this._onDisposeModel=({scene:t,tile:a})=>{this.removeSceneFromBatchedMesh(t,a)},e.addEventListener("dispose-model",this._onDisposeModel),this.tiles=e}initBatchedMesh(e){if(this.batchedMesh!==null)return;const{instanceCount:t,vertexCount:a,indexCount:i,tiles:l,renderer:s,textureSize:o}=this,r=this.material?this.material:new e.material.constructor,h=new ge(t,t*a,t*i,r);h.name="BatchTilesPlugin",h.frustumCulled=!1,l.group.add(h),h.updateMatrixWorld();const m=e.material.map,u={colorSpace:m.colorSpace,wrapS:m.wrapS,wrapT:m.wrapT,wrapR:m.wrapS,magFilter:m.magFilter},p=new v(o||m.image.width,o||m.image.height,t);Object.assign(p.texture,u),s.initRenderTarget(p),r.map=p.texture,fe(r),this.arrayTarget=p,this.batchedMesh=h}setTileVisible(e,t){const a=e.cached.scene;if(t&&this.addSceneToBatchedMesh(a,e),this._tileToInstanceId.has(e)){this._tileToInstanceId.get(e).forEach(s=>{this.batchedMesh.setVisibleAt(s,t)});const l=this.tiles;return t?l.visibleTiles.add(e):l.visibleTiles.delete(e),l.dispatchEvent({type:"tile-visibility-change",scene:a,tile:e,visible:t}),!0}return!1}unloadTileFromGPU(e,t){return!this.discardOriginalContent&&this._tileToInstanceId.has(t)?(this.removeSceneFromBatchedMesh(e,t),!0):!1}assignTextureToLayer(e,t){this.expandArrayTargetIfNeeded();const{renderer:a}=this,i=a.getRenderTarget();a.setRenderTarget(this.arrayTarget,t),E.material.map=e,E.render(a),a.setRenderTarget(i),E.material.map=null,e.dispose()}expandArrayTargetIfNeeded(){const{batchedMesh:e,arrayTarget:t,renderer:a}=this,i=Math.min(e.maxInstanceCount,this.maxInstanceCount);if(i>t.depth){const l={colorSpace:t.texture.colorSpace,wrapS:t.texture.wrapS,wrapT:t.texture.wrapT,generateMipmaps:t.texture.generateMipmaps,minFilter:t.texture.minFilter,magFilter:t.texture.magFilter},s=new v(t.width,t.height,i);Object.assign(s.texture,l),a.initRenderTarget(s),a.copyTextureToTexture(t.texture,s.texture),t.dispose(),e.material.map=s.texture,this.arrayTarget=s}}removeSceneFromBatchedMesh(e,t){if(this._tileToInstanceId.has(t)){const a=this._tileToInstanceId.get(t);this._tileToInstanceId.delete(t),a.forEach(i=>{this.batchedMesh.deleteInstance(i)})}}addSceneToBatchedMesh(e,t){if(this._tileToInstanceId.has(t))return;const a=[];e.traverse(s=>{s.isMesh&&a.push(s)});let i=!0;a.forEach(s=>{if(this.batchedMesh&&i){const o=s.geometry.attributes,r=this.batchedMesh.geometry.attributes;for(const h in r)if(!(h in o)){i=!1;return}}});const l=!this.batchedMesh||this.batchedMesh.instanceCount+a.length<=this.maxInstanceCount;if(i&&l){e.updateMatrixWorld();const s=[];a.forEach(o=>{this.initBatchedMesh(o);const{geometry:r,material:h}=o,{batchedMesh:m,expandPercent:u}=this;m.expandPercent=u;const p=m.addGeometry(r,this.vertexCount,this.indexCount),g=m.addInstance(p);s.push(g),m.setMatrixAt(g,o.matrixWorld),m.setVisibleAt(g,!1),xe(h.color)||(h.color.setHSL(Math.random(),.5,.5),m.setColorAt(g,h.color));const x=h.map;x?this.assignTextureToLayer(x,g):this.assignTextureToLayer(U,g)}),this._tileToInstanceId.set(t,s),this.discardOriginalContent&&(t.cached.textures.forEach(o=>{o.image instanceof ImageBitmap&&o.image.close()}),t.cached.scene=null,t.cached.materials=[],t.cached.geometries=[],t.cached.textures=[])}}raycastTile(e,t,a,i){return this._tileToInstanceId.has(e)?(this._tileToInstanceId.get(e).forEach(s=>{this.batchedMesh.raycastInstance(s,a,i)}),!0):!1}dispose(){const{arrayTarget:e,tiles:t,batchedMesh:a}=this;e&&e.dispose(),a&&(a.material.dispose(),a.geometry.dispose(),a.dispose(),a.removeFromParent()),t.removeEventListener("dispose-model",this._onDisposeModel)}getTileBatchIds(e){return this._tileToInstanceId.get(e)}}let w,I,C,n,d,S,b;const f={orthographic:!1,enableCacheDisplay:!1,enableRendererStats:!1,useBatchedMesh:!!new URLSearchParams(window.location.hash.replace(/^#/,"")).get("batched"),displayTopoLines:!1,errorTarget:20,reload:O};Te();z();function O(){n&&(I.remove(n.group),n.dispose(),n=null),n=new de,n.registerPlugin(new le({apiToken:"",assetId:"2275207",autoRefreshToken:!0})),n.registerPlugin(new he),n.registerPlugin(new me),n.registerPlugin(new ie),n.registerPlugin(new ue),n.registerPlugin(new ae({projection:"ellipsoid"})),n.registerPlugin(new se({dracoLoader:new Y().setDecoderPath("https://unpkg.com/three@0.153.0/examples/jsm/libs/draco/gltf/")})),f.useBatchedMesh&&n.registerPlugin(new Ce({renderer:C,discardOriginalContent:!1,instanceCount:250})),n.group.rotation.x=-Math.PI/2,I.add(n.group),n.setResolutionFromRenderer(d.camera,C),n.setCamera(d.camera),w.setEllipsoid(n.ellipsoid,n.group)}function Te(){C=new X({antialias:!0}),C.setClearColor(1383455),document.body.appendChild(C.domElement),I=new Z,d=new re(new J(60,window.innerWidth/window.innerHeight,1,16e7),new K(-1,1,1,-1,1,16e7)),d.perspectiveCamera.position.set(48e5,257e4,1472e4),d.perspectiveCamera.lookAt(0,0,0),d.autoSync=!1,d.addEventListener("camera-change",({camera:a,prevCamera:i})=>{n.deleteCamera(i),n.setCamera(a),w.setCamera(a)}),d.orthographicPositionalZoom=!1,w=new oe(I,d.camera,C.domElement,null),w.enableDamping=!0,O(),G(),window.addEventListener("resize",G,!1),window.addEventListener("hashchange",L);const c=new ee;c.width=300,c.add(f,"orthographic").onChange(a=>{w.getPivotPoint(d.fixedPoint),d.animating||(d.syncCameras(),w.adjustCamera(d.perspectiveCamera),w.adjustCamera(d.orthographicCamera)),d.toggle()});const e=c.addFolder("Google Photorealistic Tiles");e.add(f,"useBatchedMesh").listen(),e.add(f,"reload");const t=c.addFolder("Example Options");t.add(f,"displayTopoLines").listen(),t.add(f,"enableCacheDisplay"),t.add(f,"enableRendererStats"),t.add(f,"errorTarget",5,100,1).onChange(()=>{n.getPluginByName("UPDATE_ON_CHANGE_PLUGIN").needsUpdate=!0}),S=document.createElement("div"),document.getElementById("info").appendChild(S),b=new te,b.showPanel(0),document.body.appendChild(b.dom),L(),setInterval(ye,100)}function G(){const{perspectiveCamera:c,orthographicCamera:e}=d,t=window.innerWidth/window.innerHeight;c.aspect=t,c.updateProjectionMatrix(),e.left=-e.top*t,e.right=-e.left,e.updateProjectionMatrix(),C.setSize(window.innerWidth,window.innerHeight),C.setPixelRatio(window.devicePixelRatio)}function ye(){if(!n)return;d.mode!=="perspective"&&!d.animating&&(w.getPivotPoint(d.fixedPoint),d.syncCameras());const c=d.perspectiveCamera,e={},t=n.group.matrixWorld.clone().invert(),a=c.matrixWorld.clone().premultiply(t);P.getCartographicFromObjectFrame(a,e,W),e.azimuth*=y.RAD2DEG,e.elevation*=y.RAD2DEG,e.roll*=y.RAD2DEG,e.lat*=y.RAD2DEG,e.lon*=y.RAD2DEG;const i=new URLSearchParams;i.set("lat",e.lat.toFixed(4)),i.set("lon",e.lon.toFixed(4)),i.set("height",e.height.toFixed(2)),i.set("az",e.azimuth.toFixed(2)),i.set("el",e.elevation.toFixed(2)),i.set("roll",e.roll.toFixed(2)),f.useBatchedMesh&&i.set("batched",1),window.history.replaceState(void 0,void 0,`#${i}`)}function L(){const c=window.location.hash.replace(/^#/,""),e=new URLSearchParams(c);if(e.has("batched")&&(f.useBatchedMesh=!!e.get("batched")),!e.has("lat")&&!e.has("lon"))return;n.group.updateMatrixWorld();const t=d.perspectiveCamera,a=parseFloat(e.get("lat")),i=parseFloat(e.get("lon")),l=parseFloat(e.get("height"))||1e3;if(e.has("az")&&e.has("el")){const s=parseFloat(e.get("az")),o=parseFloat(e.get("el")),r=parseFloat(e.get("roll"))||0;P.getObjectFrame(a*y.DEG2RAD,i*y.DEG2RAD,l,s*y.DEG2RAD,o*y.DEG2RAD,r*y.DEG2RAD,t.matrixWorld,W),t.matrixWorld.premultiply(n.group.matrixWorld),t.matrixWorld.decompose(t.position,t.quaternion,t.scale)}else P.getCartographicToPosition(a*y.DEG2RAD,i*y.DEG2RAD,l,t.position),t.position.applyMatrix4(n.group.matrixWorld),t.lookAt(0,0,0);if(d.mode!=="perspective"){const s=d.mode;d.mode="perspective",d.syncCameras(),d.mode=s}}function z(){if(requestAnimationFrame(z),!n)return;w.enabled=!d.animating,w.update(),d.update();const c=d.camera;n.setResolutionFromRenderer(c,C),n.setCamera(c);const e=n.getPluginByName("TOPO_LINES_PLUGIN");e.topoOpacity=f.displayTopoLines?.5:0,e.cartoOpacity=f.displayTopoLines?.5:0,c.updateMatrixWorld(),n.errorTarget=f.errorTarget,n.update(),C.render(I,c),b.update(),we()}function we(){var l,s,o;let c="";if(f.enableCacheDisplay){const r=n.lruCache,h=r.cachedBytes/r.maxBytesSize;c+=`Downloading: ${n.stats.downloading} Parsing: ${n.stats.parsing} Visible: ${n.visibleTiles.size}<br/>`,c+=`Cache: ${(100*h).toFixed(2)}% ~${(r.cachedBytes/1e3/1e3).toFixed(2)}mb<br/>`}if(f.enableRendererStats){const r=C.info.memory,h=C.info.render,m=C.info.programs.length;c+=`Geometries: ${r.geometries} Textures: ${r.textures} Programs: ${m} Draw Calls: ${h.calls}`;const u=n.getPluginByName("BATCHED_TILES_PLUGIN"),p=n.getPluginByName("FADE_TILES_PLUGIN");if(u){let g=0;(l=u.batchedMesh)==null||l._instanceInfo.forEach(x=>{x.visible&&x.active&&g++}),(s=p.batchedMesh)==null||s._instanceInfo.forEach(x=>{x.visible&&x.active&&g++}),c+=", Batched: "+g}}S.innerHTML!==c&&(S.innerHTML=c);const e=n.group.matrixWorld.clone().invert(),t=d.camera.position.clone().applyMatrix4(e),a={};P.getPositionToCartographic(t,a);const i=((o=n.getAttributions()[0])==null?void 0:o.value)||"";document.getElementById("credits").innerText=ce(a.lat,a.lon)+`
`+i}
//# sourceMappingURL=googleMapsExample-BBE91gw6.js.map
