{"version":3,"file":"DebugTilesPlugin-CJlX0XLV.js","sources":["../../../src/three/plugins/DebugTilesPlugin.js"],"sourcesContent":["import { Box3Helper, Group, MeshStandardMaterial, PointsMaterial, Sphere, Color, MeshBasicMaterial } from 'three';\nimport { SphereHelper } from './objects/SphereHelper.js';\nimport { EllipsoidRegionLineHelper } from './objects/EllipsoidRegionHelper.js';\nimport { traverseAncestors, traverseSet } from '../../core/renderer/tiles/traverseFunctions.js';\n\nconst ORIGINAL_MATERIAL = Symbol( 'ORIGINAL_MATERIAL' );\nconst HAS_RANDOM_COLOR = Symbol( 'HAS_RANDOM_COLOR' );\nconst HAS_RANDOM_NODE_COLOR = Symbol( 'HAS_RANDOM_NODE_COLOR' );\nconst LOAD_TIME = Symbol( 'LOAD_TIME' );\nconst PARENT_BOUND_REF_COUNT = Symbol( 'PARENT_BOUND_REF_COUNT' );\n\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst emptyRaycast = () => {};\nconst colors = {};\n\n// Return a consistent random color for an index\nexport function getIndexedRandomColor( index ) {\n\n\tif ( ! colors[ index ] ) {\n\n\t\tconst h = Math.random();\n\t\tconst s = 0.5 + Math.random() * 0.5;\n\t\tconst l = 0.375 + Math.random() * 0.25;\n\n\t\tcolors[ index ] = new Color().setHSL( h, s, l );\n\n\t}\n\treturn colors[ index ];\n\n}\n\n// color modes\nconst NONE = 0;\nconst SCREEN_ERROR = 1;\nconst GEOMETRIC_ERROR = 2;\nconst DISTANCE = 3;\nconst DEPTH = 4;\nconst RELATIVE_DEPTH = 5;\nconst IS_LEAF = 6;\nconst RANDOM_COLOR = 7;\nconst RANDOM_NODE_COLOR = 8;\nconst CUSTOM_COLOR = 9;\nconst LOAD_ORDER = 10;\n\nconst ColorModes = Object.freeze( {\n\tNONE,\n\tSCREEN_ERROR,\n\tGEOMETRIC_ERROR,\n\tDISTANCE,\n\tDEPTH,\n\tRELATIVE_DEPTH,\n\tIS_LEAF,\n\tRANDOM_COLOR,\n\tRANDOM_NODE_COLOR,\n\tCUSTOM_COLOR,\n\tLOAD_ORDER,\n} );\n\nexport class DebugTilesPlugin {\n\n\tstatic get ColorModes() {\n\n\t\treturn ColorModes;\n\n\t}\n\n\tget unlit() {\n\n\t\treturn this._unlit;\n\n\t}\n\n\tset unlit( v ) {\n\n\t\tif ( v !== this._unlit ) {\n\n\t\t\tthis._unlit = v;\n\t\t\tthis.materialsNeedUpdate = true;\n\n\t\t}\n\n\t}\n\n\tget colorMode() {\n\n\t\treturn this._colorMode;\n\n\t}\n\n\tset colorMode( v ) {\n\n\t\tif ( v !== this._colorMode ) {\n\n\t\t\tthis._colorMode = v;\n\t\t\tthis.materialsNeedUpdate = true;\n\n\t\t}\n\n\t}\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\t\t\tdisplayParentBounds: false,\n\t\t\tdisplayBoxBounds: false,\n\t\t\tdisplaySphereBounds: false,\n\t\t\tdisplayRegionBounds: false,\n\t\t\tcolorMode: NONE,\n\t\t\tmaxDebugDepth: - 1,\n\t\t\tmaxDebugDistance: - 1,\n\t\t\tmaxDebugError: - 1,\n\t\t\tcustomColorCallback: null,\n\t\t\tunlit: false,\n\t\t\tenabled: true,\n\t\t\t...options,\n\t\t};\n\n\t\tthis.name = 'DEBUG_TILES_PLUGIN';\n\t\tthis.tiles = null;\n\n\t\tthis._colorMode = null;\n\t\tthis._unlit = null;\n\t\tthis.materialsNeedUpdate = false;\n\n\t\tthis.extremeDebugDepth = - 1;\n\t\tthis.extremeDebugError = - 1;\n\t\tthis.boxGroup = null;\n\t\tthis.sphereGroup = null;\n\t\tthis.regionGroup = null;\n\n\t\t// options\n\t\tthis._enabled = options.enabled;\n\t\tthis._displayParentBounds = options.displayParentBounds;\n\t\tthis.displayBoxBounds = options.displayBoxBounds;\n\t\tthis.displaySphereBounds = options.displaySphereBounds;\n\t\tthis.displayRegionBounds = options.displayRegionBounds;\n\t\tthis.colorMode = options.colorMode;\n\t\tthis.maxDebugDepth = options.maxDebugDepth;\n\t\tthis.maxDebugDistance = options.maxDebugDistance;\n\t\tthis.maxDebugError = options.maxDebugError;\n\t\tthis.customColorCallback = options.customColorCallback;\n\t\tthis.unlit = options.unlit;\n\n\t\tthis.getDebugColor = ( value, target ) => {\n\n\t\t\ttarget.setRGB( value, value, value );\n\n\t\t};\n\n\t}\n\n\tget enabled() {\n\n\t\treturn this._enabled;\n\n\t}\n\n\tset enabled( v ) {\n\n\t\tif ( v !== this._enabled && this.tiles !== null ) {\n\n\t\t\tif ( v ) {\n\n\t\t\t\tthis.init( this.tiles );\n\n\t\t\t} else {\n\n\t\t\t\tthis.dispose();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._enabled = v;\n\n\t}\n\n\tget displayParentBounds() {\n\n\t\treturn this._displayParentBounds;\n\n\t}\n\n\tset displayParentBounds( v ) {\n\n\t\tif ( this._displayParentBounds !== v ) {\n\n\t\t\tthis._displayParentBounds = v;\n\n\t\t\tif ( ! v ) {\n\n\t\t\t\t// Reset all ref counts\n\t\t\t\ttraverseSet( this.tiles.root, null, tile => {\n\n\t\t\t\t\ttile[ PARENT_BOUND_REF_COUNT ] = null;\n\t\t\t\t\tthis._onTileVisibilityChange( tile, tile.__visible );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\t// Initialize ref count for existing tiles\n\t\t\t\tthis.tiles.traverse( tile => {\n\n\t\t\t\t\tif ( tile.__visible ) {\n\n\t\t\t\t\t\tthis._onTileVisibilityChange( tile, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the groups for displaying helpers, register events, and initialize existing tiles\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// initialize groups\n\t\tconst tilesGroup = tiles.group;\n\t\tthis.boxGroup = new Group();\n\t\tthis.boxGroup.name = 'DebugTilesRenderer.boxGroup';\n\t\ttilesGroup.add( this.boxGroup );\n\t\tthis.boxGroup.updateMatrixWorld();\n\n\t\tthis.sphereGroup = new Group();\n\t\tthis.sphereGroup.name = 'DebugTilesRenderer.sphereGroup';\n\t\ttilesGroup.add( this.sphereGroup );\n\t\tthis.sphereGroup.updateMatrixWorld();\n\n\t\tthis.regionGroup = new Group();\n\t\tthis.regionGroup.name = 'DebugTilesRenderer.regionGroup';\n\t\ttilesGroup.add( this.regionGroup );\n\t\tthis.regionGroup.updateMatrixWorld();\n\n\t\t// register events\n\t\tthis._onLoadTileSetCB = () => {\n\n\t\t\tthis._initExtremes();\n\n\t\t};\n\n\t\tthis._onLoadModelCB = ( { scene, tile } ) => {\n\n\t\t\tthis._onLoadModel( scene, tile );\n\n\t\t};\n\n\t\tthis._onDisposeModelCB = ( { tile } ) => {\n\n\t\t\tthis._onDisposeModel( tile );\n\n\t\t};\n\n\t\tthis._onUpdateAfterCB = () => {\n\n\t\t\tthis._onUpdateAfter();\n\n\t\t};\n\n\t\tthis._onTileVisibilityChangeCB = ( { scene, tile, visible } ) => {\n\n\t\t\tthis._onTileVisibilityChange( tile, visible );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'load-tile-set', this._onLoadTileSetCB );\n\t\ttiles.addEventListener( 'load-model', this._onLoadModelCB );\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModelCB );\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfterCB );\n\t\ttiles.addEventListener( 'tile-visibility-change', this._onTileVisibilityChangeCB );\n\n\t\tthis._initExtremes();\n\n\t\t// initialize an already-loaded tiles\n\t\ttiles.traverse( tile => {\n\n\t\t\tif ( tile.cached.scene ) {\n\n\t\t\t\tthis._onLoadModel( tile.cached.scene, tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttiles.visibleTiles.forEach( tile => {\n\n\t\t\tthis._onTileVisibilityChange( tile, true );\n\n\t\t} );\n\n\t}\n\n\tgetTileInformationFromActiveObject( object ) {\n\n\t\t// Find which tile this scene is associated with. This is slow and\n\t\t// intended for debug purposes only.\n\t\tlet targetTile = null;\n\t\tconst activeTiles = this.tiles.activeTiles;\n\t\tactiveTiles.forEach( tile => {\n\n\t\t\tif ( targetTile ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tconst scene = tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.traverse( c => {\n\n\t\t\t\t\tif ( c === object ) {\n\n\t\t\t\t\t\ttargetTile = tile;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( targetTile ) {\n\n\t\t\treturn {\n\n\t\t\t\tdistanceToCamera: targetTile.__distanceFromCamera,\n\t\t\t\tgeometricError: targetTile.geometricError,\n\t\t\t\tscreenSpaceError: targetTile.__error,\n\t\t\t\tdepth: targetTile.__depth,\n\t\t\t\tisLeaf: targetTile.__isLeaf\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t_initExtremes() {\n\n\t\tif ( ! ( this.tiles && this.tiles.root ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// initialize the extreme values of the hierarchy\n\t\tlet maxDepth = - 1;\n\t\tlet maxError = - 1;\n\n\t\t// Note that we are not using this.tiles.traverse()\n\t\t// as we don't want to pay the cost of preprocessing tiles.\n\t\ttraverseSet( this.tiles.root, null, ( tile, _, depth ) => {\n\n\t\t\tmaxDepth = Math.max( maxDepth, depth );\n\t\t\tmaxError = Math.max( maxError, tile.geometricError );\n\n\t\t} );\n\n\t\tthis.extremeDebugDepth = maxDepth;\n\t\tthis.extremeDebugError = maxError;\n\n\t}\n\n\t_onUpdateAfter() {\n\n\t\tconst { tiles, colorMode } = this;\n\n\t\tif ( ! tiles.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.materialsNeedUpdate ) {\n\n\t\t\ttiles.forEachLoadedModel( scene => {\n\n\t\t\t\tthis._updateMaterial( scene );\n\n\t\t\t} );\n\t\t\tthis.materialsNeedUpdate = false;\n\n\t\t}\n\n\t\t// set box or sphere visibility\n\t\tthis.boxGroup.visible = this.displayBoxBounds;\n\t\tthis.sphereGroup.visible = this.displaySphereBounds;\n\t\tthis.regionGroup.visible = this.displayRegionBounds;\n\n\t\t// get max values to use for materials\n\t\tlet maxDepth = - 1;\n\t\tif ( this.maxDebugDepth === - 1 ) {\n\n\t\t\tmaxDepth = this.extremeDebugDepth;\n\n\t\t} else {\n\n\t\t\tmaxDepth = this.maxDebugDepth;\n\n\t\t}\n\n\t\tlet maxError = - 1;\n\t\tif ( this.maxDebugError === - 1 ) {\n\n\t\t\tmaxError = this.extremeDebugError;\n\n\t\t} else {\n\n\t\t\tmaxError = this.maxDebugError;\n\n\t\t}\n\n\t\tlet maxDistance = - 1;\n\t\tif ( this.maxDebugDistance === - 1 ) {\n\n\t\t\ttiles.getBoundingSphere( _sphere );\n\t\t\tmaxDistance = _sphere.radius;\n\n\t\t} else {\n\n\t\t\tmaxDistance = this.maxDebugDistance;\n\n\t\t}\n\n\t\tconst { errorTarget, visibleTiles } = tiles;\n\t\tlet sortedTiles;\n\t\tif ( colorMode === LOAD_ORDER ) {\n\n\t\t\tsortedTiles = Array.from( visibleTiles ).sort( ( a, b ) => {\n\n\t\t\t\treturn a[ LOAD_TIME ] - b[ LOAD_TIME ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// update plugins\n\t\tvisibleTiles.forEach( tile => {\n\n\t\t\tconst scene = tile.cached.scene;\n\n\t\t\t// create a random color per-tile\n\t\t\tlet h, s, l;\n\t\t\tif ( colorMode === RANDOM_COLOR ) {\n\n\t\t\t\th = Math.random();\n\t\t\t\ts = 0.5 + Math.random() * 0.5;\n\t\t\t\tl = 0.375 + Math.random() * 0.25;\n\n\t\t\t}\n\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( colorMode === RANDOM_NODE_COLOR ) {\n\n\t\t\t\t\th = Math.random();\n\t\t\t\t\ts = 0.5 + Math.random() * 0.5;\n\t\t\t\t\tl = 0.375 + Math.random() * 0.25;\n\n\t\t\t\t}\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tif ( colorMode !== RANDOM_COLOR ) {\n\n\t\t\t\t\t\tdelete c.material[ HAS_RANDOM_COLOR ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( colorMode !== RANDOM_NODE_COLOR ) {\n\n\t\t\t\t\t\tdelete c.material[ HAS_RANDOM_NODE_COLOR ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the color on the basic material\n\t\t\t\t\tswitch ( colorMode ) {\n\n\t\t\t\t\t\tcase DEPTH: {\n\n\t\t\t\t\t\t\tconst val = tile.__depth / maxDepth;\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RELATIVE_DEPTH: {\n\n\t\t\t\t\t\t\tconst val = tile.__depthFromRenderedParent / maxDepth;\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase SCREEN_ERROR: {\n\n\t\t\t\t\t\t\tconst val = tile.__error / errorTarget;\n\t\t\t\t\t\t\tif ( val > 1.0 ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setRGB( 1.0, 0.0, 0.0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase GEOMETRIC_ERROR: {\n\n\t\t\t\t\t\t\tconst val = Math.min( tile.geometricError / maxError, 1 );\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase DISTANCE: {\n\n\t\t\t\t\t\t\t// We don't update the distance if the geometric error is 0.0 so\n\t\t\t\t\t\t\t// it will always be black.\n\t\t\t\t\t\t\tconst val = Math.min( tile.__distanceFromCamera / maxDistance, 1 );\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase IS_LEAF: {\n\n\t\t\t\t\t\t\tif ( ! tile.children || tile.children.length === 0 ) {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( 1.0, c.material.color );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( 0.0, c.material.color );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RANDOM_NODE_COLOR: {\n\n\t\t\t\t\t\t\tif ( ! c.material[ HAS_RANDOM_NODE_COLOR ] ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setHSL( h, s, l );\n\t\t\t\t\t\t\t\tc.material[ HAS_RANDOM_NODE_COLOR ] = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RANDOM_COLOR: {\n\n\t\t\t\t\t\t\tif ( ! c.material[ HAS_RANDOM_COLOR ] ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setHSL( h, s, l );\n\t\t\t\t\t\t\t\tc.material[ HAS_RANDOM_COLOR ] = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase CUSTOM_COLOR: {\n\n\t\t\t\t\t\t\tif ( this.customColorCallback ) {\n\n\t\t\t\t\t\t\t\tthis.customColorCallback( tile, c );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'DebugTilesRenderer: customColorCallback not defined' );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase LOAD_ORDER: {\n\n\t\t\t\t\t\t\tconst value = sortedTiles.indexOf( tile );\n\t\t\t\t\t\t\tthis.getDebugColor( value / ( sortedTiles.length - 1 ), c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t_onTileVisibilityChange( tile, visible ) {\n\n\t\tif ( this.displayParentBounds ) {\n\n\t\t\ttraverseAncestors( tile, current => {\n\n\t\t\t\tif ( current[ PARENT_BOUND_REF_COUNT ] == null ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( visible ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] ++;\n\n\t\t\t\t} else if ( current[ PARENT_BOUND_REF_COUNT ] > 0 ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] --;\n\n\t\t\t\t}\n\n\t\t\t\tconst tileVisible = ( current === tile && visible ) || ( this.displayParentBounds && current[ PARENT_BOUND_REF_COUNT ] > 0 );\n\n\t\t\t\tthis._updateBoundHelper( current, tileVisible );\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tthis._updateBoundHelper( tile, visible );\n\n\t\t}\n\n\t}\n\n\t_createBoundHelper( tile ) {\n\n\t\tconst tiles = this.tiles;\n\t\tconst cached = tile.cached;\n\t\tconst { sphere, obb, region } = cached.boundingVolume;\n\t\tif ( obb ) {\n\n\t\t\t// Create debug bounding box\n\t\t\t// In some cases the bounding box may have a scale of 0 in one dimension resulting\n\t\t\t// in the NaNs in an extracted rotation so we disable matrix updates instead.\n\t\t\tconst boxHelperGroup = new Group();\n\t\t\tboxHelperGroup.name = 'DebugTilesRenderer.boxHelperGroup';\n\t\t\tboxHelperGroup.matrix.copy( obb.transform );\n\t\t\tboxHelperGroup.matrixAutoUpdate = false;\n\n\t\t\tconst boxHelper = new Box3Helper( obb.box, getIndexedRandomColor( tile.__depth ) );\n\t\t\tboxHelper.raycast = emptyRaycast;\n\t\t\tboxHelperGroup.add( boxHelper );\n\n\t\t\tcached.boxHelperGroup = boxHelperGroup;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displayBoxBounds ) {\n\n\t\t\t\tthis.boxGroup.add( boxHelperGroup );\n\t\t\t\tboxHelperGroup.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sphere ) {\n\n\t\t\t// Create debug bounding sphere\n\t\t\tconst sphereHelper = new SphereHelper( sphere, getIndexedRandomColor( tile.__depth ) );\n\t\t\tsphereHelper.raycast = emptyRaycast;\n\t\t\tcached.sphereHelper = sphereHelper;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displaySphereBounds ) {\n\n\t\t\t\tthis.sphereGroup.add( sphereHelper );\n\t\t\t\tsphereHelper.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( region ) {\n\n\t\t\t// Create debug bounding region\n\t\t\tconst regionHelper = new EllipsoidRegionLineHelper( region, getIndexedRandomColor( tile.__depth ) );\n\t\t\tregionHelper.raycast = emptyRaycast;\n\n\t\t\t// recenter the geometry to avoid rendering artifacts\n\t\t\tconst sphere = new Sphere();\n\t\t\tregion.getBoundingSphere( sphere );\n\t\t\tregionHelper.position.copy( sphere.center );\n\n\t\t\tsphere.center.multiplyScalar( - 1 );\n\t\t\tregionHelper.geometry.translate( ...sphere.center );\n\n\t\t\tcached.regionHelper = regionHelper;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displayRegionBounds ) {\n\n\t\t\t\tthis.regionGroup.add( regionHelper );\n\t\t\t\tregionHelper.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateHelperMaterial( tile, material ) {\n\n\t\tif ( tile.__visible || ! this.displayParentBounds ) {\n\n\t\t\tmaterial.opacity = 1;\n\n\t\t} else {\n\n\t\t\tmaterial.opacity = 0.2;\n\n\t\t}\n\n\t\tconst transparent = material.transparent;\n\t\tmaterial.transparent = material.opacity < 1;\n\t\tif ( material.transparent !== transparent ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t_updateBoundHelper( tile, visible ) {\n\n\t\tconst cached = tile.cached;\n\n\t\tif ( ! cached ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst sphereGroup = this.sphereGroup;\n\t\tconst boxGroup = this.boxGroup;\n\t\tconst regionGroup = this.regionGroup;\n\n\t\tif ( visible && ( cached.boxHelperGroup == null && cached.sphereHelper == null && cached.regionHelper == null ) ) {\n\n\t\t\tthis._createBoundHelper( tile );\n\n\t\t}\n\n\t\tconst boxHelperGroup = cached.boxHelperGroup;\n\t\tconst sphereHelper = cached.sphereHelper;\n\t\tconst regionHelper = cached.regionHelper;\n\n\t\tif ( ! visible ) {\n\n\t\t\tif ( boxHelperGroup ) {\n\n\t\t\t\tboxGroup.remove( boxHelperGroup );\n\n\t\t\t}\n\n\t\t\tif ( sphereHelper ) {\n\n\t\t\t\tsphereGroup.remove( sphereHelper );\n\n\t\t\t}\n\n\t\t\tif ( regionHelper ) {\n\n\t\t\t\tregionGroup.remove( regionHelper );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// TODO: consider updating the volumes based on the bounding regions here in case they've been changed\n\t\t\tif ( boxHelperGroup ) {\n\n\t\t\t\tboxGroup.add( boxHelperGroup );\n\t\t\t\tboxHelperGroup.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, boxHelperGroup.children[ 0 ].material );\n\n\t\t\t}\n\n\t\t\tif ( sphereHelper ) {\n\n\t\t\t\tsphereGroup.add( sphereHelper );\n\t\t\t\tsphereHelper.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, sphereHelper.material );\n\n\t\t\t}\n\n\t\t\tif ( regionHelper ) {\n\n\t\t\t\tregionGroup.add( regionHelper );\n\t\t\t\tregionHelper.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, regionHelper.material );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateMaterial( scene ) {\n\n\t\t// update the materials for debug rendering\n\t\tconst { colorMode, unlit } = this;\n\t\tscene.traverse( c => {\n\n\t\t\tif ( ! c.material ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currMaterial = c.material;\n\t\t\tconst originalMaterial = c[ ORIGINAL_MATERIAL ];\n\n\t\t\t// dispose the previous material\n\t\t\tif ( currMaterial !== originalMaterial ) {\n\n\t\t\t\tcurrMaterial.dispose();\n\n\t\t\t}\n\n\t\t\t// assign the new material\n\t\t\tif ( colorMode !== NONE || unlit ) {\n\n\t\t\t\tif ( c.isPoints ) {\n\n\t\t\t\t\tconst pointsMaterial = new PointsMaterial();\n\t\t\t\t\tpointsMaterial.size = originalMaterial.size;\n\t\t\t\t\tpointsMaterial.sizeAttenuation = originalMaterial.sizeAttenuation;\n\t\t\t\t\tc.material = pointsMaterial;\n\n\t\t\t\t} else if ( unlit ) {\n\n\t\t\t\t\tc.material = new MeshBasicMaterial();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = new MeshStandardMaterial();\n\t\t\t\t\tc.material.flatShading = true;\n\n\t\t\t\t}\n\n\t\t\t\t// if no debug rendering is happening then assign the material properties\n\t\t\t\tif ( colorMode === NONE ) {\n\n\t\t\t\t\tc.material.map = originalMaterial.map;\n\t\t\t\t\tc.material.color.set( originalMaterial.color );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tc.material = originalMaterial;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t_onLoadModel( scene, tile ) {\n\n\t\ttile[ LOAD_TIME ] = performance.now();\n\n\t\t// Cache the original materials\n\t\tscene.traverse( c => {\n\n\t\t\tconst material = c.material;\n\t\t\tif ( material ) {\n\n\t\t\t\tc[ ORIGINAL_MATERIAL ] = material;\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Update the materials to align with the settings\n\t\tthis._updateMaterial( scene );\n\n\t}\n\n\t_onDisposeModel( tile ) {\n\n\t\tconst cached = tile.cached;\n\t\tif ( cached.boxHelperGroup ) {\n\n\t\t\tcached.boxHelperGroup.children[ 0 ].geometry.dispose();\n\t\t\tdelete cached.boxHelperGroup;\n\n\t\t}\n\n\t\tif ( cached.sphereHelper ) {\n\n\t\t\tcached.sphereHelper.geometry.dispose();\n\t\t\tdelete cached.sphereHelper;\n\n\t\t}\n\n\t\tif ( cached.regionHelper ) {\n\n\t\t\tcached.regionHelper.geometry.dispose();\n\t\t\tdelete cached.regionHelper;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst tiles = this.tiles;\n\n\t\ttiles.removeEventListener( 'load-tile-set', this._onLoadTileSetCB );\n\t\ttiles.removeEventListener( 'load-model', this._onLoadModelCB );\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModelCB );\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfterCB );\n\t\ttiles.removeEventListener( 'tile-visibility-change', this._onTileVisibilityChangeCB );\n\n\t\t// reset all materials\n\t\tthis.colorMode = NONE;\n\t\tthis.unlit = false;\n\t\ttiles.forEachLoadedModel( scene => {\n\n\t\t\tthis._updateMaterial( scene );\n\n\t\t} );\n\n\t\t// dispose of all helper objects\n\t\ttiles.traverse( tile => {\n\n\t\t\tthis._onDisposeModel( tile );\n\n\t\t} );\n\n\t\tthis.boxGroup?.removeFromParent();\n\t\tthis.sphereGroup?.removeFromParent();\n\t\tthis.regionGroup?.removeFromParent();\n\n\t}\n\n}\n"],"names":["ORIGINAL_MATERIAL","HAS_RANDOM_COLOR","HAS_RANDOM_NODE_COLOR","LOAD_TIME","PARENT_BOUND_REF_COUNT","_sphere","Sphere","emptyRaycast","colors","getIndexedRandomColor","index","h","s","l","Color","NONE","SCREEN_ERROR","GEOMETRIC_ERROR","DISTANCE","DEPTH","RELATIVE_DEPTH","IS_LEAF","RANDOM_COLOR","RANDOM_NODE_COLOR","CUSTOM_COLOR","LOAD_ORDER","ColorModes","DebugTilesPlugin","v","options","value","target","tile","traverseSet","tiles","tilesGroup","Group","scene","visible","object","targetTile","c","maxDepth","maxError","_","depth","colorMode","maxDistance","errorTarget","visibleTiles","sortedTiles","b","val","traverseAncestors","current","tileVisible","cached","sphere","obb","region","boxHelperGroup","boxHelper","Box3Helper","sphereHelper","SphereHelper","regionHelper","EllipsoidRegionLineHelper","material","transparent","sphereGroup","boxGroup","regionGroup","unlit","currMaterial","originalMaterial","pointsMaterial","PointsMaterial","MeshBasicMaterial","MeshStandardMaterial","_a","_b","_c"],"mappings":"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"}