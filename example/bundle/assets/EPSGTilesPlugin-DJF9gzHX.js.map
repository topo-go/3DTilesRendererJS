{"version":3,"file":"EPSGTilesPlugin-DJF9gzHX.js","sources":["../../../src/three/plugins/images/utils/getCartographicToMeterDerivative.js","../../../src/three/plugins/images/EllipsoidProjectionTilesPlugin.js","../../../src/three/plugins/images/sources/WMTSImageSource.js","../../../src/three/plugins/images/EPSGTilesPlugin.js"],"sourcesContent":["import { Vector3 } from 'three';\n\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\n\nexport function getCartographicToMeterDerivative( ellipsoid, lat, lon ) {\n\n\tconst EPS = 1e-5;\n\tconst lonp = lon + EPS;\n\tlet latp = lat + EPS;\n\tif ( Math.abs( latp ) > Math.PI / 2 ) {\n\n\t\tlatp = latp - EPS;\n\n\t}\n\n\tellipsoid.getCartographicToPosition( lat, lon, 0, _v0 );\n\n\tellipsoid.getCartographicToPosition( latp, lon, 0, _v1 );\n\tconst dy = _v0.distanceTo( _v1 ) / EPS;\n\n\tellipsoid.getCartographicToPosition( lat, lonp, 0, _v1 );\n\tconst dx = _v0.distanceTo( _v1 ) / EPS;\n\n\treturn [ dx, dy ];\n\n}\n","import { ImageFormatPlugin, TILE_LEVEL, TILE_X, TILE_Y } from './ImageFormatPlugin.js';\nimport { MathUtils, PlaneGeometry, Sphere, Vector2, Vector3 } from 'three';\nimport { getCartographicToMeterDerivative } from './utils/getCartographicToMeterDerivative.js';\n\nconst MIN_LON_VERTS = 30;\nconst MIN_LAT_VERTS = 15;\n\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _uv = /* @__PURE__ */ new Vector2();\nconst _sphere = /* @__PURE__ */ new Sphere();\n\nexport class EllipsoidProjectionTilesPlugin extends ImageFormatPlugin {\n\n\tget projection() {\n\n\t\treturn this.tiling.projection;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tshape = 'planar',\n\t\t\tendCaps = true,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\t// options\n\t\tthis.shape = shape;\n\t\tthis.endCaps = endCaps;\n\n\t}\n\n\t// override the parse to mesh logic to support a region mesh\n\tasync parseToMesh( buffer, tile, ...args ) {\n\n\t\tconst mesh = await super.parseToMesh( buffer, tile, ...args );\n\n\t\t// if displaying the tiles as an ellipsoid\n\t\tconst { shape, projection, tiles, tiling } = this;\n\t\tif ( shape === 'ellipsoid' ) {\n\n\t\t\tconst ellipsoid = tiles.ellipsoid;\n\t\t\tconst level = tile[ TILE_LEVEL ];\n\t\t\tconst x = tile[ TILE_X ];\n\t\t\tconst y = tile[ TILE_Y ];\n\n\t\t\t// new geometry\n\t\t\t// default to a minimum number of vertices per degree on each axis\n\t\t\tconst [ west, south, east, north ] = tile.boundingVolume.region;\n\t\t\tconst latVerts = Math.ceil( ( north - south ) * MathUtils.RAD2DEG * 0.25 );\n\t\t\tconst lonVerts = Math.ceil( ( east - west ) * MathUtils.RAD2DEG * 0.25 );\n\t\t\tconst yVerts = Math.max( MIN_LAT_VERTS, latVerts );\n\t\t\tconst xVerts = Math.max( MIN_LON_VERTS, lonVerts );\n\t\t\tconst geometry = new PlaneGeometry( 1, 1, xVerts, yVerts );\n\n\t\t\tconst [ minU, minV, maxU, maxV ] = tiling.getTileBounds( x, y, level, true, true );\n\t\t\tconst uvRange = tiling.getTileContentUVBounds( x, y, level );\n\n\t\t\t// adjust the geometry to position it at the region\n\t\t\tconst { position, normal, uv } = geometry.attributes;\n\t\t\tconst vertCount = position.count;\n\t\t\ttile.cached.boundingVolume.getSphere( _sphere );\n\t\t\tfor ( let i = 0; i < vertCount; i ++ ) {\n\n\t\t\t\t// retrieve attributes\n\t\t\t\t_pos.fromBufferAttribute( position, i );\n\t\t\t\t_uv.fromBufferAttribute( uv, i );\n\n\t\t\t\t// convert the plane position to lat / lon\n\t\t\t\tconst lon = projection.convertProjectionToLongitude( MathUtils.mapLinear( _uv.x, 0, 1, minU, maxU ) );\n\t\t\t\tlet lat = projection.convertProjectionToLatitude( MathUtils.mapLinear( _uv.y, 0, 1, minV, maxV ) );\n\n\t\t\t\t// snap the edges to the poles if using mercator projection and end caps are enabled\n\t\t\t\tif ( projection.isMercator && this.endCaps ) {\n\n\t\t\t\t\tif ( maxV === 1 && _uv.y === 1 ) {\n\n\t\t\t\t\t\tlat = Math.PI / 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( minV === 0 && _uv.y === 0 ) {\n\n\t\t\t\t\t\tlat = - Math.PI / 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// ensure we have an edge loop positioned at the mercator limit to avoid UV distortion\n\t\t\t\t// as much as possible at low LoDs.\n\t\t\t\tif ( projection.isMercator && _uv.y !== 0 && _uv.y !== 1 ) {\n\n\t\t\t\t\tconst latLimit = projection.convertProjectionToLatitude( 1 );\n\t\t\t\t\tconst vStep = 1 / yVerts;\n\n\t\t\t\t\tconst prevLat = MathUtils.mapLinear( _uv.y - vStep, 0, 1, south, north );\n\t\t\t\t\tconst nextLat = MathUtils.mapLinear( _uv.y + vStep, 0, 1, south, north );\n\t\t\t\t\tif ( lat > latLimit && prevLat < latLimit ) {\n\n\t\t\t\t\t\tlat = latLimit;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( lat < - latLimit && nextLat > - latLimit ) {\n\n\t\t\t\t\t\tlat = - latLimit;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// get the position and normal\n\t\t\t\tellipsoid.getCartographicToPosition( lat, lon, 0, _pos ).sub( _sphere.center );\n\t\t\t\tellipsoid.getCartographicToNormal( lat, lon, _norm );\n\n\t\t\t\t// map from the uvs for the tile into the uv range\n\t\t\t\tconst u = MathUtils.mapLinear( projection.convertLongitudeToProjection( lon ), minU, maxU, uvRange[ 0 ], uvRange[ 2 ] );\n\t\t\t\tconst v = MathUtils.mapLinear( projection.convertLatitudeToProjection( lat ), minV, maxV, uvRange[ 1 ], uvRange[ 3 ] );\n\n\t\t\t\t// update the geometry\n\t\t\t\tuv.setXY( i, u, v );\n\t\t\t\tposition.setXYZ( i, ..._pos );\n\t\t\t\tnormal.setXYZ( i, ..._norm );\n\n\t\t\t}\n\n\t\t\tmesh.geometry = geometry;\n\t\t\tmesh.position.copy( _sphere.center );\n\n\t\t}\n\n\t\treturn mesh;\n\n\t}\n\n\tcreateBoundingVolume( x, y, level ) {\n\n\t\tif ( this.shape === 'ellipsoid' ) {\n\n\t\t\tconst { tiling, endCaps } = this;\n\t\t\tconst isRoot = level === - 1;\n\t\t\tconst normalizedBounds = isRoot ? tiling.getContentBounds( true ) : tiling.getTileBounds( x, y, level, true, true );\n\t\t\tconst cartBounds = isRoot ? tiling.getContentBounds() : tiling.getTileBounds( x, y, level, false, true );\n\n\t\t\tif ( endCaps ) {\n\n\t\t\t\t// if the north side is at the edge\n\t\t\t\tif ( normalizedBounds[ 3 ] === 1 ) {\n\n\t\t\t\t\tcartBounds[ 3 ] = Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t\t// if the south side is at the edge\n\t\t\t\tif ( normalizedBounds[ 1 ] === 0 ) {\n\n\t\t\t\t\tcartBounds[ 1 ] = - Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tregion: [ ...cartBounds, - 1, 1 ],\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn super.createBoundingVolume( x, y, level );\n\n\t\t}\n\n\t}\n\n\tcreateChild( ...args ) {\n\n\t\tconst tile = super.createChild( ...args );\n\n\t\tconst { shape, projection, tiling } = this;\n\t\tif ( tile && shape === 'ellipsoid' ) {\n\n\t\t\tconst level = tile[ TILE_LEVEL ];\n\t\t\tconst x = tile[ TILE_X ];\n\t\t\tconst y = tile[ TILE_Y ];\n\n\t\t\t// if this is the root node then skip calculating the geometric error\n\t\t\tif ( level === - 1 ) {\n\n\t\t\t\ttile.geometricError = 1e50;\n\t\t\t\treturn parent;\n\n\t\t\t}\n\n\t\t\tconst [ minU, minV, maxU, maxV ] = tiling.getTileBounds( x, y, level, true );\n\t\t\tconst { tilePixelWidth, tilePixelHeight } = tiling.getLevel( level );\n\n\t\t\t// one pixel width in uv space\n\t\t\tconst tileUWidth = ( maxU - minU ) / tilePixelWidth;\n\t\t\tconst tileVWidth = ( maxV - minV ) / tilePixelHeight;\n\n\t\t\t// calculate the region ranges\n\t\t\tconst [ /* west */, south, east, north ] = tiling.getTileBounds( x, y, level );\n\n\t\t\t// calculate the changes in lat / lon at the given point\n\t\t\t// find the most bowed point of the latitude range since the amount that latitude changes is\n\t\t\t// dependent on the Y value of the image\n\t\t\tconst midLat = ( south > 0 ) !== ( north > 0 ) ? 0 : Math.min( Math.abs( south ), Math.abs( north ) );\n\t\t\tconst midV = projection.convertLatitudeToProjection( midLat );\n\t\t\tconst lonFactor = projection.getLongitudeDerivativeAtProjection( minU );\n\t\t\tconst latFactor = projection.getLatitudeDerivativeAtProjection( midV );\n\n\t\t\t// calculate the size of a pixel on the surface\n\t\t\tconst [ xDeriv, yDeriv ] = getCartographicToMeterDerivative( this.tiles.ellipsoid, midLat, east );\n\t\t\tconst projectedPixelWidth = Math.max( tileUWidth * lonFactor * xDeriv, tileVWidth * latFactor * yDeriv );\n\t\t\ttile.geometricError = projectedPixelWidth;\n\n\t\t}\n\n\t\treturn tile;\n\n\t}\n\n}\n\n","import { TiledImageSource } from './TiledImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\n\nexport class WMTSImageSource extends TiledImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\tcapabilities = null,\n\t\t\tlayer = null,\n\t\t\ttileMatrixSet = null,\n\t\t\tstyle = null,\n\t\t\turl = null,\n\t\t\tdimensions = {},\n\t\t} = options;\n\n\t\tthis.capabilities = capabilities;\n\t\tthis.layer = layer;\n\t\tthis.tileMatrixSet = tileMatrixSet;\n\t\tthis.style = style;\n\t\tthis.dimensions = dimensions;\n\t\tthis.url = url;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn this.url\n\t\t\t.replace( /{\\s*TileMatrix\\s*}/gi, level )\n\t\t\t.replace( /{\\s*TileCol\\s*}/gi, x )\n\t\t\t.replace( /{\\s*TileRow\\s*}/gi, y );\n\n\t}\n\n\tinit() {\n\n\t\tconst { tiling, dimensions, capabilities } = this;\n\t\tlet { layer, tileMatrixSet, style, url } = this;\n\n\t\t// extract the layer to use\n\t\tif ( ! layer ) {\n\n\t\t\tlayer = capabilities.layers[ 0 ];\n\n\t\t} else if ( typeof layer === 'string' ) {\n\n\t\t\tlayer = capabilities.layers.find( l => l.identifier === layer );\n\n\t\t}\n\n\t\t// extract the tile matrix set\n\t\tif ( ! tileMatrixSet ) {\n\n\t\t\ttileMatrixSet = layer.tileMatrixSets[ 0 ];\n\n\t\t} else if ( typeof tileMatrixSet === 'string' ) {\n\n\t\t\ttileMatrixSet = layer.tileMatrixSets.find( tms => tms.identifier === tileMatrixSet );\n\n\t\t}\n\n\t\t// extract the style\n\t\tif ( ! style ) {\n\n\t\t\tstyle = layer.styles.find( style => style.isDefault ).identifier;\n\n\t\t}\n\n\t\t// extract the url template\n\t\tif ( ! url ) {\n\n\t\t\turl = layer.resourceUrls[ 0 ].template;\n\n\t\t}\n\n\t\t// determine the projection\n\t\tconst projection = tileMatrixSet.supportedCRS.includes( '4326' ) ? 'EPSG:4326' : 'EPSG:3857';\n\n\t\t// generate the tiling scheme\n\t\ttiling.flipY = true;\n\t\ttiling.setProjection( new ProjectionScheme( projection ) );\n\t\ttiling.setContentBounds( ...tiling.projection.getBounds() );\n\t\ttileMatrixSet.tileMatrices.forEach( ( tm, i ) => {\n\n\t\t\t// TODO: needs to set tileCountX from matrix width?\n\t\t\t// TODO: How does bounds and tile count work together here?\n\t\t\t// Can one typically be generated from the other?\n\n\t\t\tconst { tileWidth, tileHeight, matrixWidth, matrixHeight } = tm;\n\t\t\ttiling.setLevel( i, {\n\t\t\t\ttilePixelWidth: tileWidth,\n\t\t\t\ttilePixelHeight: tileHeight,\n\t\t\t\ttileCountX: matrixWidth || tiling.projection.tileCountX * 2 ** i,\n\t\t\t\ttileCountY: matrixHeight || tiling.projection.tileCountY * 2 ** i,\n\t\t\t\ttileBounds: tm.bounds,\n\t\t\t} );\n\n\t\t} );\n\n\t\t// construct the url\n\t\turl = url\n\t\t\t.replace( /{\\s*TileMatrixSet\\s*}/g, tileMatrixSet.identifier )\n\t\t\t.replace( /{\\s*Style\\s*}/g, style );\n\n\t\t// fill in the dimension values\n\t\tfor ( const key in dimensions ) {\n\n\t\t\turl = url.replace( new RegExp( `{\\\\s*${ key }\\\\s*}` ), dimensions[ key ] );\n\n\t\t}\n\n\t\tlayer.dimensions.forEach( dim => {\n\n\t\t\turl = url.replace( new RegExp( `{\\\\s*${ dim.identifier }\\\\s*}` ), dim.defaultValue );\n\n\t\t} );\n\n\t\tthis.url = url;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n","\n// Support for XYZ / Slippy tile systems\n\nimport { EllipsoidProjectionTilesPlugin } from './EllipsoidProjectionTilesPlugin.js';\nimport { XYZImageSource } from './sources/XYZImageSource.js';\nimport { TMSImageSource } from './sources/TMSImageSource.js';\nimport { WMTSImageSource } from './sources/WMTSImageSource.js';\n\n// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames\nexport class XYZTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tlevels,\n\t\t\ttileDimension,\n\t\t\tprojection,\n\t\t\tbounds,\n\t\t\turl,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'XYZ_TILES_PLUGIN';\n\t\tthis.imageSource = new XYZImageSource( { url, levels, tileDimension, projection, bounds } );\n\n\t}\n\n}\n\n// Support for TMS tiles\n// https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification\n// NOTE: Most, if not all, TMS generation implementations do not correctly support the Origin tag\n// and tile index offsets, including CesiumJS and Ion.\nexport class TMSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst { url, ...rest } = options;\n\t\tsuper( rest );\n\n\t\tthis.name = 'TMS_TILES_PLUGIN';\n\t\tthis.imageSource = new TMSImageSource( { url } );\n\n\t}\n\n}\n\n// Support for WMTS tiles via a url template\nexport class WMTSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tcapabilities,\n\t\t\tlayer,\n\t\t\ttileMatrixSet,\n\t\t\tstyle,\n\t\t\tdimensions,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'WTMS_TILES_PLUGIN';\n\t\tthis.imageSource = new WMTSImageSource( {\n\t\t\tcapabilities,\n\t\t\tlayer,\n\t\t\ttileMatrixSet,\n\t\t\tstyle,\n\t\t\tdimensions\n\t\t} );\n\n\t}\n\n}\n"],"names":["_v0","Vector3","_v1","getCartographicToMeterDerivative","ellipsoid","lat","lon","lonp","latp","dy","MIN_LON_VERTS","MIN_LAT_VERTS","_pos","_norm","_uv","Vector2","_sphere","Sphere","EllipsoidProjectionTilesPlugin","ImageFormatPlugin","options","shape","endCaps","rest","buffer","tile","args","mesh","projection","tiles","tiling","level","TILE_LEVEL","x","TILE_X","y","TILE_Y","west","south","east","north","latVerts","MathUtils","lonVerts","yVerts","xVerts","geometry","PlaneGeometry","minU","minV","maxU","maxV","uvRange","position","normal","uv","vertCount","i","latLimit","vStep","prevLat","nextLat","u","v","isRoot","normalizedBounds","cartBounds","tilePixelWidth","tilePixelHeight","tileUWidth","tileVWidth","midLat","midV","lonFactor","latFactor","xDeriv","yDeriv","projectedPixelWidth","WMTSImageSource","TiledImageSource","capabilities","layer","tileMatrixSet","style","url","dimensions","l","tms","ProjectionScheme","tm","tileWidth","tileHeight","matrixWidth","matrixHeight","key","dim","XYZTilesPlugin","levels","tileDimension","bounds","XYZImageSource","TMSTilesPlugin","TMSImageSource","WMTSTilesPlugin"],"mappings":"6QAEA,MAAMA,EAAsB,IAAIC,EAC1BC,EAAsB,IAAID,EAEzB,SAASE,GAAkCC,EAAWC,EAAKC,EAAM,CAGvE,MAAMC,EAAOD,EAAM,KACnB,IAAIE,EAAOH,EAAM,KACZ,KAAK,IAAKG,CAAM,EAAG,KAAK,GAAK,IAEjCA,EAAOA,EAAO,MAIfJ,EAAU,0BAA2BC,EAAKC,EAAK,EAAGN,CAAK,EAEvDI,EAAU,0BAA2BI,EAAMF,EAAK,EAAGJ,CAAK,EACxD,MAAMO,EAAKT,EAAI,WAAYE,CAAK,EAAG,KAEnC,OAAAE,EAAU,0BAA2BC,EAAKE,EAAM,EAAGL,CAAK,EAGjD,CAFIF,EAAI,WAAYE,CAAK,EAAG,KAEtBO,CAAI,CAElB,CCtBA,MAAMC,GAAgB,GAChBC,GAAgB,GAEhBC,EAAuB,IAAIX,EAC3BY,EAAwB,IAAIZ,EAC5Ba,EAAsB,IAAIC,GAC1BC,EAA0B,IAAIC,GAE7B,MAAMC,UAAuCC,CAAkB,CAErE,IAAI,YAAa,CAEhB,OAAO,KAAK,OAAO,UAErB,CAEC,YAAaC,EAAU,GAAK,CAE3B,KAAM,CACL,MAAAC,EAAQ,SACR,QAAAC,EAAU,GACV,GAAGC,CACN,EAAMH,EAEJ,MAAOG,CAAM,EAGb,KAAK,MAAQF,EACb,KAAK,QAAUC,CAEjB,CAGC,MAAM,YAAaE,EAAQC,KAASC,EAAO,CAE1C,MAAMC,EAAO,MAAM,MAAM,YAAaH,EAAQC,EAAM,GAAGC,CAAM,EAGvD,CAAE,MAAAL,EAAO,WAAAO,EAAY,MAAAC,EAAO,OAAAC,CAAQ,EAAG,KAC7C,GAAKT,IAAU,YAAc,CAE5B,MAAMjB,EAAYyB,EAAM,UAClBE,EAAQN,EAAMO,CAAY,EAC1BC,EAAIR,EAAMS,CAAQ,EAClBC,EAAIV,EAAMW,CAAQ,EAIlB,CAAEC,EAAMC,EAAOC,EAAMC,GAAUf,EAAK,eAAe,OACnDgB,EAAW,KAAK,MAAQD,EAAQF,GAAUI,EAAU,QAAU,GAAM,EACpEC,EAAW,KAAK,MAAQJ,EAAOF,GAASK,EAAU,QAAU,GAAM,EAClEE,EAAS,KAAK,IAAKjC,GAAe8B,CAAU,EAC5CI,EAAS,KAAK,IAAKnC,GAAeiC,CAAU,EAC5CG,EAAW,IAAIC,EAAe,EAAG,EAAGF,EAAQD,CAAQ,EAEpD,CAAEI,EAAMC,EAAMC,EAAMC,CAAI,EAAKrB,EAAO,cAAeG,EAAGE,EAAGJ,EAAO,GAAM,EAAM,EAC5EqB,EAAUtB,EAAO,uBAAwBG,EAAGE,EAAGJ,CAAO,EAGtD,CAAE,SAAAsB,EAAU,OAAAC,EAAQ,GAAAC,CAAI,EAAGT,EAAS,WACpCU,EAAYH,EAAS,MAC3B5B,EAAK,OAAO,eAAe,UAAWT,CAAS,EAC/C,QAAUyC,EAAI,EAAGA,EAAID,EAAWC,IAAO,CAGtC7C,EAAK,oBAAqByC,EAAUI,CAAG,EACvC3C,EAAI,oBAAqByC,EAAIE,CAAG,EAGhC,MAAMnD,EAAMsB,EAAW,6BAA8Bc,EAAU,UAAW5B,EAAI,EAAG,EAAG,EAAGkC,EAAME,CAAI,CAAI,EACrG,IAAI7C,EAAMuB,EAAW,4BAA6Bc,EAAU,UAAW5B,EAAI,EAAG,EAAG,EAAGmC,EAAME,CAAI,CAAI,EAqBlG,GAlBKvB,EAAW,YAAc,KAAK,UAE7BuB,IAAS,GAAKrC,EAAI,IAAM,IAE5BT,EAAM,KAAK,GAAK,GAIZ4C,IAAS,GAAKnC,EAAI,IAAM,IAE5BT,EAAM,CAAE,KAAK,GAAK,IAQfuB,EAAW,YAAcd,EAAI,IAAM,GAAKA,EAAI,IAAM,EAAI,CAE1D,MAAM4C,EAAW9B,EAAW,4BAA6B,CAAG,EACtD+B,EAAQ,EAAIf,EAEZgB,EAAUlB,EAAU,UAAW5B,EAAI,EAAI6C,EAAO,EAAG,EAAGrB,EAAOE,CAAO,EAClEqB,EAAUnB,EAAU,UAAW5B,EAAI,EAAI6C,EAAO,EAAG,EAAGrB,EAAOE,CAAO,EACnEnC,EAAMqD,GAAYE,EAAUF,IAEhCrD,EAAMqD,GAIFrD,EAAM,CAAEqD,GAAYG,EAAU,CAAEH,IAEpCrD,EAAM,CAAEqD,EAId,CAGItD,EAAU,0BAA2BC,EAAKC,EAAK,EAAGM,GAAO,IAAKI,EAAQ,MAAQ,EAC9EZ,EAAU,wBAAyBC,EAAKC,EAAKO,CAAO,EAGpD,MAAMiD,EAAIpB,EAAU,UAAWd,EAAW,6BAA8BtB,CAAG,EAAI0C,EAAME,EAAME,EAAS,CAAG,EAAEA,EAAS,CAAC,CAAI,EACjHW,EAAIrB,EAAU,UAAWd,EAAW,4BAA6BvB,CAAG,EAAI4C,EAAME,EAAMC,EAAS,CAAG,EAAEA,EAAS,CAAC,CAAI,EAGtHG,EAAG,MAAOE,EAAGK,EAAGC,CAAG,EACnBV,EAAS,OAAQI,EAAG,GAAG7C,CAAM,EAC7B0C,EAAO,OAAQG,EAAG,GAAG5C,CAAO,CAEhC,CAEGc,EAAK,SAAWmB,EAChBnB,EAAK,SAAS,KAAMX,EAAQ,MAAQ,CAEvC,CAEE,OAAOW,CAET,CAEC,qBAAsBM,EAAGE,EAAGJ,EAAQ,CAEnC,GAAK,KAAK,QAAU,YAAc,CAEjC,KAAM,CAAE,OAAAD,EAAQ,QAAAR,CAAO,EAAK,KACtB0C,EAASjC,IAAU,GACnBkC,EAAmBD,EAASlC,EAAO,iBAAkB,EAAM,EAAGA,EAAO,cAAeG,EAAGE,EAAGJ,EAAO,GAAM,EAAM,EAC7GmC,EAAaF,EAASlC,EAAO,iBAAgB,EAAKA,EAAO,cAAeG,EAAGE,EAAGJ,EAAO,GAAO,EAAM,EAExG,OAAKT,IAGC2C,EAAkB,CAAG,IAAK,IAE9BC,EAAY,CAAC,EAAK,KAAK,GAAK,GAKxBD,EAAkB,CAAG,IAAK,IAE9BC,EAAY,CAAG,EAAG,CAAE,KAAK,GAAK,IAMzB,CACN,OAAQ,CAAE,GAAGA,EAAY,GAAK,CAAG,CACjC,CAEJ,KAEG,QAAO,MAAM,qBAAsBjC,EAAGE,EAAGJ,CAAO,CAInD,CAEC,eAAgBL,EAAO,CAEtB,MAAMD,EAAO,MAAM,YAAa,GAAGC,CAAM,EAEnC,CAAE,MAAAL,EAAO,WAAAO,EAAY,OAAAE,CAAQ,EAAG,KACtC,GAAKL,GAAQJ,IAAU,YAAc,CAEpC,MAAMU,EAAQN,EAAMO,CAAY,EAC1BC,EAAIR,EAAMS,CAAQ,EAClBC,EAAIV,EAAMW,CAAQ,EAGxB,GAAKL,IAAU,GAEd,OAAAN,EAAK,eAAiB,KACf,OAIR,KAAM,CAAEuB,EAAMC,EAAMC,EAAMC,CAAM,EAAGrB,EAAO,cAAeG,EAAGE,EAAGJ,EAAO,EAAM,EACtE,CAAE,eAAAoC,EAAgB,gBAAAC,CAAe,EAAKtC,EAAO,SAAUC,CAAO,EAG9DsC,GAAenB,EAAOF,GAASmB,EAC/BG,GAAenB,EAAOF,GAASmB,EAG/B,CAAc,CAAA9B,EAAOC,EAAMC,CAAO,EAAGV,EAAO,cAAeG,EAAGE,EAAGJ,CAAO,EAKxEwC,EAAWjC,EAAQ,GAAUE,EAAQ,EAAM,EAAI,KAAK,IAAK,KAAK,IAAKF,CAAK,EAAI,KAAK,IAAKE,EAAS,EAC/FgC,EAAO5C,EAAW,4BAA6B2C,CAAQ,EACvDE,EAAY7C,EAAW,mCAAoCoB,CAAM,EACjE0B,EAAY9C,EAAW,kCAAmC4C,CAAM,EAGhE,CAAEG,EAAQC,CAAM,EAAKzE,GAAkC,KAAK,MAAM,UAAWoE,EAAQhC,CAAM,EAC3FsC,EAAsB,KAAK,IAAKR,EAAaI,EAAYE,EAAQL,EAAaI,EAAYE,CAAQ,EACxGnD,EAAK,eAAiBoD,CAEzB,CAEE,OAAOpD,CAET,CAEA,CChOO,MAAMqD,WAAwBC,EAAiB,CAErD,YAAa3D,EAAU,GAAK,CAE3B,MAAO,EAEP,KAAM,CACL,aAAA4D,EAAe,KACf,MAAAC,EAAQ,KACR,cAAAC,EAAgB,KAChB,MAAAC,EAAQ,KACR,IAAAC,EAAM,KACN,WAAAC,EAAa,CAAE,CAClB,EAAMjE,EAEJ,KAAK,aAAe4D,EACpB,KAAK,MAAQC,EACb,KAAK,cAAgBC,EACrB,KAAK,MAAQC,EACb,KAAK,WAAaE,EAClB,KAAK,IAAMD,CAEb,CAEC,OAAQnD,EAAGE,EAAGJ,EAAQ,CAErB,OAAO,KAAK,IACV,QAAS,uBAAwBA,CAAK,EACtC,QAAS,oBAAqBE,CAAC,EAC/B,QAAS,oBAAqBE,CAAG,CAErC,CAEC,MAAO,CAEN,KAAM,CAAE,OAAAL,EAAQ,WAAAuD,EAAY,aAAAL,CAAc,EAAG,KAC7C,GAAI,CAAE,MAAAC,EAAO,cAAAC,EAAe,MAAAC,EAAO,IAAAC,CAAK,EAAG,KAGpCH,EAIK,OAAOA,GAAU,WAE5BA,EAAQD,EAAa,OAAO,KAAMM,GAAKA,EAAE,aAAeL,CAAO,GAJ/DA,EAAQD,EAAa,OAAQ,CAAG,EAS1BE,EAIK,OAAOA,GAAkB,WAEpCA,EAAgBD,EAAM,eAAe,KAAMM,GAAOA,EAAI,aAAeL,CAAe,GAJpFA,EAAgBD,EAAM,eAAgB,CAAG,EASnCE,IAENA,EAAQF,EAAM,OAAO,KAAME,GAASA,EAAM,SAAS,EAAG,YAKhDC,IAENA,EAAMH,EAAM,aAAc,CAAG,EAAC,UAK/B,MAAMrD,EAAasD,EAAc,aAAa,SAAU,MAAM,EAAK,YAAc,YAGjFpD,EAAO,MAAQ,GACfA,EAAO,cAAe,IAAI0D,GAAkB5D,CAAU,CAAI,EAC1DE,EAAO,iBAAkB,GAAGA,EAAO,WAAW,UAAS,CAAI,EAC3DoD,EAAc,aAAa,QAAS,CAAEO,EAAIhC,IAAO,CAMhD,KAAM,CAAE,UAAAiC,EAAW,WAAAC,EAAY,YAAAC,EAAa,aAAAC,CAAc,EAAGJ,EAC7D3D,EAAO,SAAU2B,EAAG,CACnB,eAAgBiC,EAChB,gBAAiBC,EACjB,WAAYC,GAAe9D,EAAO,WAAW,WAAa,GAAK2B,EAC/D,WAAYoC,GAAgB/D,EAAO,WAAW,WAAa,GAAK2B,EAChE,WAAYgC,EAAG,MACnB,CAAM,CAEN,CAAK,EAGHL,EAAMA,EACJ,QAAS,yBAA0BF,EAAc,UAAU,EAC3D,QAAS,iBAAkBC,CAAO,EAGpC,UAAYW,KAAOT,EAElBD,EAAMA,EAAI,QAAS,IAAI,OAAQ,QAASU,CAAG,OAAQ,EAAIT,EAAYS,CAAG,CAAI,EAI3E,OAAAb,EAAM,WAAW,QAASc,GAAO,CAEhCX,EAAMA,EAAI,QAAS,IAAI,OAAQ,QAASW,EAAI,UAAU,SAAYA,EAAI,YAAc,CAEvF,CAAK,EAEH,KAAK,IAAMX,EAEJ,QAAQ,QAAS,CAE1B,CAEA,CCpHO,MAAMY,WAAuB9E,CAA+B,CAElE,YAAaE,EAAU,GAAK,CAE3B,KAAM,CACL,OAAA6E,EACA,cAAAC,EACA,WAAAtE,EACA,OAAAuE,EACA,IAAAf,EACA,GAAG7D,CACN,EAAMH,EAEJ,MAAOG,CAAM,EAEb,KAAK,KAAO,mBACZ,KAAK,YAAc,IAAI6E,GAAgB,CAAE,IAAAhB,EAAK,OAAAa,EAAQ,cAAAC,EAAe,WAAAtE,EAAY,OAAAuE,EAAU,CAE7F,CAEA,CAMO,MAAME,WAAuBnF,CAA+B,CAElE,YAAaE,EAAU,GAAK,CAE3B,KAAM,CAAE,IAAAgE,EAAK,GAAG7D,CAAI,EAAKH,EACzB,MAAOG,CAAM,EAEb,KAAK,KAAO,mBACZ,KAAK,YAAc,IAAI+E,GAAgB,CAAE,IAAAlB,CAAG,CAAI,CAElD,CAEA,CAGO,MAAMmB,WAAwBrF,CAA+B,CAEnE,YAAaE,EAAU,GAAK,CAE3B,KAAM,CACL,aAAA4D,EACA,MAAAC,EACA,cAAAC,EACA,MAAAC,EACA,WAAAE,EACA,GAAG9D,CACN,EAAMH,EAEJ,MAAOG,CAAM,EAEb,KAAK,KAAO,oBACZ,KAAK,YAAc,IAAIuD,GAAiB,CACvC,aAAAE,EACA,MAAAC,EACA,cAAAC,EACA,MAAAC,EACA,WAAAE,CACH,CAAK,CAEL,CAEA"}