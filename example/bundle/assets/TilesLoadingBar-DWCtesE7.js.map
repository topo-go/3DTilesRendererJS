{"version":3,"file":"TilesLoadingBar-DWCtesE7.js","sources":["../../../src/r3f/components/CompassGizmo.jsx","../../../src/r3f/components/CameraTransition.jsx","../../r3f/components/TilesLoadingBar.jsx"],"sourcesContent":["import { createPortal, useFrame, useThree } from '@react-three/fiber';\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { BackSide, Matrix4, OrthographicCamera, Ray, Scene, Vector3 } from 'three';\nimport { TilesRendererContext } from './TilesRenderer.jsx';\nimport { closestRayEllipsoidSurfacePointEstimate } from '../../three/renderer/controls/utils.js';\n\n// Based in part on @pmndrs/drei's Gizmo component\n\nconst _vec = /*@__PURE__*/ new Vector3();\nconst _axis = /*@__PURE__*/ new Vector3();\nconst _pos = /*@__PURE__*/ new Vector3();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _enuMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _cart = {};\n\n// Returns the \"focus\" point that the camera is facing based on the closest point to the ellipsoid.\n// Used for determining the compass orientation.\nfunction getCameraFocusPoint( camera, ellipsoid, tilesGroup, target ) {\n\n\t// get ray in globe coordinate frame\n\t_ray.origin.copy( camera.position );\n\t_ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t_ray.applyMatrix4( tilesGroup.matrixWorldInverse );\n\n\t// get the closest point to the ray on the globe in the global coordinate frame\n\tclosestRayEllipsoidSurfacePointEstimate( _ray, ellipsoid, _pos );\n\t_pos.applyMatrix4( tilesGroup.matrixWorld );\n\n\t// get ortho camera info\n\t_axis.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t// ensure we move the camera exactly along the forward vector to avoid shifting\n\t// the camera in other directions due to floating point error\n\tconst dist = _pos.sub( camera.position ).dot( _axis );\n\ttarget.copy( camera.position ).addScaledVector( _axis, dist );\n\treturn target;\n\n}\n\n// Renders the portal with an orthographic camera\nfunction RenderPortal( props ) {\n\n\tconst { defaultScene, defaultCamera, overrideRenderLoop = true, renderPriority = 1 } = props;\n\tconst camera = useMemo( () => new OrthographicCamera(), [] );\n\tconst [ set, size, gl, scene ] = useThree( state => [ state.set, state.size, state.gl, state.scene ] );\n\tuseEffect( () => {\n\n\t\tset( { camera } );\n\n\t}, [ set, camera ] );\n\n\tuseEffect( () => {\n\n\t\tcamera.left = - size.width / 2;\n\t\tcamera.right = size.width / 2;\n\t\tcamera.top = size.height / 2;\n\t\tcamera.bottom = - size.height / 2;\n\t\tcamera.near = 0;\n\t\tcamera.far = 2000;\n\t\tcamera.position.z = camera.far / 2;\n\t\tcamera.updateProjectionMatrix();\n\n\t}, [ camera, size ] );\n\n\tuseFrame( () => {\n\n\t\tif ( overrideRenderLoop ) {\n\n\t\t\tgl.render( defaultScene, defaultCamera );\n\n\t\t}\n\n\t\tconst currentAutoClear = gl.autoClear;\n\t\tgl.autoClear = false;\n\n\t\tgl.clearDepth();\n\t\tgl.render( scene, camera );\n\n\t\tgl.autoClear = currentAutoClear;\n\n\t}, renderPriority );\n\n}\n\n// generates an extruded box geometry\nfunction TriangleGeometry() {\n\n\tconst ref = useRef();\n\tuseEffect( () => {\n\n\t\tconst geometry = ref.current;\n\t\tconst position = geometry.attributes.position;\n\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t_vec.fromBufferAttribute( position, i );\n\t\t\tif ( _vec.y > 0 ) {\n\n\t\t\t\t_vec.x = 0;\n\t\t\t\tposition.setXYZ( i, ..._vec );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn <boxGeometry ref={ ref } />;\n\n}\n\n// renders a typical compass graphic with red north triangle, white south, and a tinted circular background\nfunction CompassGraphic( { northColor = 0xEF5350, southColor = 0xFFFFFF } ) {\n\n\tconst [ lightTarget, setLightTarget ] = useState();\n\tconst groupRef = useRef();\n\tuseEffect( () => {\n\n\t\tsetLightTarget( groupRef.current );\n\n\t}, [] );\n\n\treturn (\n\t\t<group scale={ 0.5 } ref={ groupRef }>\n\n\t\t\t{/* Lights */}\n\t\t\t<ambientLight intensity={ 1 } />\n\t\t\t<directionalLight position={ [ 0, 2, 3 ] } intensity={ 3 } target={ lightTarget } />\n\t\t\t<directionalLight position={ [ 0, - 2, - 3 ] } intensity={ 3 } target={ lightTarget } />\n\n\t\t\t{/* Background */}\n\t\t\t<mesh>\n\t\t\t\t<sphereGeometry />\n\t\t\t\t<meshBasicMaterial color={ 0 } opacity={ 0.3 } transparent={ true } side={ BackSide } />\n\t\t\t</mesh>\n\n\t\t\t{/* Compass shape */}\n\t\t\t<group scale={ [ 0.5, 1, 0.15 ] }>\n\t\t\t\t<mesh position-y={ 0.5 }>\n\t\t\t\t\t<TriangleGeometry />\n\t\t\t\t\t<meshStandardMaterial color={ northColor } />\n\t\t\t\t</mesh>\n\t\t\t\t<mesh position-y={ - 0.5 } rotation-x={ Math.PI }>\n\t\t\t\t\t<TriangleGeometry />\n\t\t\t\t\t<meshStandardMaterial color={ southColor } />\n\t\t\t\t</mesh>\n\t\t\t</group>\n\t\t</group>\n\t);\n\n}\n\nexport function CompassGizmo( { children, overrideRenderLoop, mode = '3d', margin = 10, scale = 35, visible = true, ...rest } ) {\n\n\tconst [ defaultCamera, defaultScene, size ] = useThree( state => [ state.camera, state.scene, state.size ] );\n\tconst tiles = useContext( TilesRendererContext );\n\tconst groupRef = useRef( null );\n\tconst scene = useMemo( () => {\n\n\t\treturn new Scene();\n\n\t}, [] );\n\n\tlet marginX, marginY;\n\tif ( Array.isArray( margin ) ) {\n\n\t\tmarginX = margin[ 0 ];\n\t\tmarginY = margin[ 1 ];\n\n\t} else {\n\n\t\tmarginX = margin;\n\t\tmarginY = margin;\n\n\t}\n\n\tuseFrame( () => {\n\n\t\tif ( tiles === null || groupRef.current === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst { ellipsoid } = tiles;\n\t\tconst group = groupRef.current;\n\n\t\t// get the ENU frame in world space\n\t\tgetCameraFocusPoint( defaultCamera, ellipsoid, tiles.group, _pos ).applyMatrix4( tiles.group.matrixWorldInverse );\n\t\tellipsoid.getPositionToCartographic( _pos, _cart );\n\n\t\tellipsoid\n\t\t\t.getEastNorthUpFrame( _cart.lat, _cart.lon, 0, _enuMatrix )\n\t\t\t.premultiply( tiles.group.matrixWorld );\n\n\t\t// get the camera orientation in the local ENU frame\n\t\t_enuMatrix.invert();\n\t\t_matrix.copy( defaultCamera.matrixWorld ).premultiply( _enuMatrix );\n\n\t\tif ( mode.toLowerCase() === '3d' ) {\n\n\t\t\tgroup.quaternion.setFromRotationMatrix( _matrix ).invert();\n\n\t\t} else {\n\n\t\t\t// get the projected facing direction of the camera\n\t\t\t_vec.set( 0, 1, 0 ).transformDirection( _matrix ).normalize();\n\t\t\t_vec.z = 0;\n\t\t\t_vec.normalize();\n\n\t\t\tif ( _vec.length() === 0 ) {\n\n\t\t\t\t// if we're looking exactly top-down\n\t\t\t\tgroup.quaternion.identity();\n\n\t\t\t} else {\n\n\t\t\t\t// compute the 2d looking direction\n\t\t\t\tconst angle = _axis.set( 0, 1, 0 ).angleTo( _vec );\n\t\t\t\t_axis.cross( _vec ).normalize();\n\t\t\t\tgroup.quaternion.setFromAxisAngle( _axis, - angle );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t// default to the compass graphic\n\tif ( ! children ) {\n\n\t\tchildren = <CompassGraphic />;\n\n\t}\n\n\t// remove the portal rendering if not present\n\tif ( ! visible ) {\n\n\t\treturn null;\n\n\t}\n\n\treturn (\n\t\tcreatePortal(\n\t\t\t<>\n\t\t\t\t<group\n\t\t\t\t\tref={ groupRef }\n\t\t\t\t\tscale={ scale }\n\t\t\t\t\tposition={ [\n\t\t\t\t\t\tsize.width / 2 - marginX - scale / 2,\n\t\t\t\t\t\t- size.height / 2 + marginY + scale / 2,\n\t\t\t\t\t\t0,\n\t\t\t\t\t] }\n\n\t\t\t\t\t{ ...rest }\n\t\t\t\t>{ children }</group>\n\t\t\t\t<RenderPortal\n\t\t\t\t\tdefaultCamera={ defaultCamera }\n\t\t\t\t\tdefaultScene={ defaultScene }\n\t\t\t\t\toverrideRenderLoop={ overrideRenderLoop }\n\t\t\t\t\trenderPriority={ 10 }\n\t\t\t\t/>\n\t\t\t</>,\n\t\t\tscene,\n\t\t\t{ events: { priority: 10 } },\n\t\t)\n\t);\n\n}\n","import { forwardRef, useEffect, useMemo } from 'react';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport { CameraTransitionManager } from '../../three/renderer/controls/CameraTransitionManager.js';\nimport { useDeepOptions } from '../utilities/useOptions.js';\nimport { useApplyRefs } from '../utilities/useApplyRefs.js';\n\nexport const CameraTransition = forwardRef( function CameraTransition( props, ref ) {\n\n\tconst {\n\t\tmode = 'perspective',\n\t\tonBeforeToggle,\n\t\tperspectiveCamera,\n\t\torthographicCamera,\n\t\t...options\n\t} = props;\n\n\tconst [ set, get, invalidate, controls, camera, size ] = useThree( state => [ state.set, state.get, state.invalidate, state.controls, state.camera, state.size ] );\n\n\t// create the manager\n\tconst manager = useMemo( () => {\n\n\t\tconst manager = new CameraTransitionManager();\n\t\tmanager.autoSync = false;\n\n\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\tmanager.orthographicCamera.copy( camera );\n\t\t\tmanager.mode = 'orthographic';\n\n\t\t} else {\n\n\t\t\tmanager.perspectiveCamera.copy( camera );\n\n\t\t}\n\n\t\tmanager.syncCameras();\n\t\tmanager.mode = mode;\n\n\t\treturn manager;\n\n\t\t// only respect the camera initially so the default camera settings are automatically used\n\n\t}, [] ); // eslint-disable-line react-hooks/exhaustive-deps\n\n\tuseEffect( () => {\n\n\t\tconst { perspectiveCamera, orthographicCamera } = manager;\n\t\tconst aspect = size.width / size.height;\n\t\tperspectiveCamera.aspect = aspect;\n\t\tperspectiveCamera.updateProjectionMatrix();\n\n\t\torthographicCamera.left = - orthographicCamera.top * aspect;\n\t\torthographicCamera.right = - orthographicCamera.left;\n\t\tperspectiveCamera.updateProjectionMatrix();\n\n\t}, [ manager, size ] );\n\n\t// assign ref\n\tuseApplyRefs( manager, ref );\n\n\t// set the camera\n\tuseEffect( () => {\n\n\t\tconst cameraCallback = ( { camera } ) => {\n\n\t\t\tset( () => ( { camera } ) );\n\n\t\t};\n\n\t\tset( () => ( { camera: manager.camera } ) );\n\t\tmanager.addEventListener( 'camera-change', cameraCallback );\n\t\treturn () => {\n\n\t\t\tmanager.removeEventListener( 'camera-change', cameraCallback );\n\n\t\t};\n\n\t}, [ manager, set ] );\n\n\t// assign cameras\n\tuseEffect( () => {\n\n\t\tconst oldPerspectiveCamera = manager.perspectiveCamera;\n\t\tconst oldOrthographicCamera = manager.orthographicCamera;\n\t\tmanager.perspectiveCamera = perspectiveCamera || oldPerspectiveCamera;\n\t\tmanager.orthographicCamera = orthographicCamera || oldOrthographicCamera;\n\n\t\tset( () => ( { camera: manager.camera } ) );\n\n\t\treturn () => {\n\n\t\t\tmanager.perspectiveCamera = oldPerspectiveCamera;\n\t\t\tmanager.orthographicCamera = oldOrthographicCamera;\n\n\t\t};\n\n\t}, [ perspectiveCamera, orthographicCamera, manager, set ] );\n\n\t// toggle\n\tuseEffect( () => {\n\n\t\tif ( mode !== manager.mode ) {\n\n\t\t\t// calculate the camera being toggled to. Because \"toggle\" has not yet been\n\t\t\t// called this will select the camera that is being transitioned to.\n\t\t\tconst targetCamera = mode === 'orthographic' ? manager.orthographicCamera : manager.perspectiveCamera;\n\t\t\tif ( onBeforeToggle ) {\n\n\t\t\t\tonBeforeToggle( manager, targetCamera );\n\n\t\t\t} else if ( controls && controls.isEnvironmentControls ) {\n\n\t\t\t\tcontrols.getPivotPoint( manager.fixedPoint );\n\t\t\t\tmanager.syncCameras();\n\n\t\t\t\tcontrols.adjustCamera( manager.perspectiveCamera );\n\t\t\t\tcontrols.adjustCamera( manager.orthographicCamera );\n\n\t\t\t} else {\n\n\t\t\t\tmanager.fixedPoint\n\t\t\t\t\t.set( 0, 0, - 1 )\n\t\t\t\t\t.transformDirection( manager.camera.matrixWorld )\n\t\t\t\t\t.multiplyScalar( 50 )\n\t\t\t\t\t.add( manager.camera.position );\n\t\t\t\tmanager.syncCameras();\n\n\t\t\t}\n\n\t\t\tmanager.toggle();\n\t\t\tinvalidate();\n\n\t\t}\n\n\t}, [ mode, manager, invalidate, controls, onBeforeToggle ] );\n\n\t// rerender the frame when the transition animates\n\tuseEffect( () => {\n\n\t\tconst callback = () => invalidate();\n\t\tmanager.addEventListener( 'transition-start', callback );\n\t\tmanager.addEventListener( 'change', callback );\n\t\tmanager.addEventListener( 'transition-end', callback );\n\n\t\treturn () => {\n\n\t\t\tmanager.removeEventListener( 'transition-start', callback );\n\t\t\tmanager.removeEventListener( 'change', callback );\n\t\t\tmanager.removeEventListener( 'transition-end', callback );\n\n\t\t};\n\n\t}, [ manager, invalidate ] );\n\n\tuseDeepOptions( manager, options );\n\n\t// update animation\n\tuseFrame( () => {\n\n\t\tmanager.update();\n\t\tif ( controls ) {\n\n\t\t\tcontrols.enabled = ! manager.animating;\n\n\t\t}\n\n\t\t// ensure the orthographic camera size is resized correctly if the user is not\n\t\t// providing their own camera.\n\t\tconst { camera, size } = get();\n\t\tif ( ! orthographicCamera && camera === manager.orthographicCamera ) {\n\n\t\t\tconst aspect = size.width / size.height;\n\t\t\tconst camera = manager.orthographicCamera;\n\t\t\tif ( aspect !== camera.right ) {\n\n\t\t\t\tcamera.bottom = - 1;\n\t\t\t\tcamera.top = 1;\n\t\t\t\tcamera.left = - aspect;\n\t\t\t\tcamera.right = aspect;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( manager.animating ) {\n\n\t\t\tinvalidate();\n\n\t\t}\n\n\t}, - 1 );\n\n} );\n","import { CanvasDOMOverlay, TilesRendererContext } from '3d-tiles-renderer/r3f';\nimport { useFrame } from '@react-three/fiber';\nimport { useContext, useRef } from 'react';\n\nexport function TilesLoadingBar( props ) {\n\n\tconst tiles = useContext( TilesRendererContext );\n\tconst domRef = useRef();\n\n\tuseFrame( () => {\n\n\t\tconst element = domRef.current;\n\t\tif ( element && tiles ) {\n\n\t\t\telement.style.width = `${ tiles.loadProgress * 100 }%`;\n\t\t\telement.style.opacity = tiles.loadProgress === 1 ? 0 : 1;\n\t\t\telement.style.transition = tiles.loadProgress === 1 ? 'opacity 0.5s linear' : '';\n\n\t\t}\n\n\t} );\n\n\treturn <CanvasDOMOverlay\n\t\tref={ domRef }\n\t\tstyle={ {\n\t\t\tposition: 'absolute',\n\t\t\tleft: 0,\n\t\t\tbottom: 0,\n\t\t\theight: '2px',\n\t\t\tbackground: 'white',\n\t\t\t// transition: 'opacity 0.2s linear',\n\t\t\topacity: 0,\n\t\t\twidth: '100%',\n\t\t} }\n\t/>;\n\n}\n"],"names":["_vec","Vector3","_axis","_pos","_matrix","Matrix4","_enuMatrix","_ray","Ray","_cart","getCameraFocusPoint","camera","ellipsoid","tilesGroup","target","closestRayEllipsoidSurfacePointEstimate","dist","RenderPortal","props","defaultScene","defaultCamera","overrideRenderLoop","renderPriority","useMemo","OrthographicCamera","set","size","gl","scene","useThree","state","useEffect","useFrame","currentAutoClear","TriangleGeometry","ref","useRef","position","i","l","jsx","CompassGraphic","northColor","southColor","lightTarget","setLightTarget","useState","groupRef","jsxs","BackSide","CompassGizmo","children","mode","margin","scale","visible","rest","tiles","useContext","TilesRendererContext","Scene","marginX","marginY","group","angle","createPortal","Fragment","CameraTransition","forwardRef","onBeforeToggle","perspectiveCamera","orthographicCamera","options","get","invalidate","controls","manager","CameraTransitionManager","aspect","useApplyRefs","cameraCallback","oldPerspectiveCamera","oldOrthographicCamera","targetCamera","callback","useDeepOptions","TilesLoadingBar","domRef","element","CanvasDOMOverlay"],"mappings":"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"}