{"version":3,"file":"CameraTransitionManager-BIWFAn1E.js","sources":["../../../src/three/renderer/controls/CameraTransitionManager.js"],"sourcesContent":["import { Clock, EventDispatcher, MathUtils, OrthographicCamera, PerspectiveCamera, Quaternion, Vector3 } from 'three';\n\nconst _forward = new Vector3();\nconst _vec = new Vector3();\nconst _orthographicCamera = new OrthographicCamera();\nconst _targetOffset = new Vector3();\nconst _perspOffset = new Vector3();\nconst _orthoOffset = new Vector3();\nconst _quat = new Quaternion();\nconst _targetQuat = new Quaternion();\n\nexport class CameraTransitionManager extends EventDispatcher {\n\n\tget animating() {\n\n\t\treturn this._alpha !== 0 && this._alpha !== 1;\n\n\t}\n\n\tget alpha() {\n\n\t\t// the transition alpha towards the target camera\n\t\treturn this._target === 0 ? 1 - this._alpha : this._alpha;\n\n\t}\n\n\tget camera() {\n\n\t\tif ( this._alpha === 0 ) return this.perspectiveCamera;\n\t\tif ( this._alpha === 1 ) return this.orthographicCamera;\n\t\treturn this.transitionCamera;\n\n\t}\n\n\tget mode() {\n\n\t\treturn this._target === 0 ? 'perspective' : 'orthographic';\n\n\t}\n\n\tset mode( v ) {\n\n\t\tif ( v === this.mode ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst prevCamera = this.camera;\n\t\tif ( v === 'perspective' ) {\n\n\t\t\tthis._target = 0;\n\t\t\tthis._alpha = 0;\n\n\t\t} else {\n\n\t\t\tthis._target = 1;\n\t\t\tthis._alpha = 1;\n\n\t\t}\n\n\t\tthis.dispatchEvent( { type: 'camera-change', camera: this.camera, prevCamera: prevCamera } );\n\n\t}\n\n\tconstructor( perspectiveCamera = new PerspectiveCamera(), orthographicCamera = new OrthographicCamera() ) {\n\n\t\tsuper();\n\n\t\tthis.perspectiveCamera = perspectiveCamera;\n\t\tthis.orthographicCamera = orthographicCamera;\n\t\tthis.transitionCamera = new PerspectiveCamera();\n\n\t\t// settings\n\t\tthis.orthographicPositionalZoom = true;\n\t\tthis.orthographicOffset = 50;\n\t\tthis.fixedPoint = new Vector3();\n\t\tthis.duration = 200;\n\t\tthis.autoSync = true;\n\t\tthis.easeFunction = x => x;\n\n\t\tthis._target = 0;\n\t\tthis._alpha = 0;\n\t\tthis._clock = new Clock();\n\n\t}\n\n\ttoggle() {\n\n\t\t// reset the clock for cases where we're not calling \"update\" every frame\n\t\tthis._target = this._target === 1 ? 0 : 1;\n\t\tthis._clock.getDelta();\n\n\t\tthis.dispatchEvent( { type: 'toggle' } );\n\n\t}\n\n\tupdate( deltaTime = Math.min( this._clock.getDelta(), 64 / 1000 ) ) {\n\n\t\t// update transforms\n\t\tif ( this.autoSync ) {\n\n\t\t\tthis.syncCameras();\n\n\t\t}\n\n\t\t// perform transition\n\t\tconst { perspectiveCamera, orthographicCamera, transitionCamera, camera } = this;\n\t\tconst delta = deltaTime * 1e3;\n\n\t\tif ( this._alpha !== this._target ) {\n\n\t\t\tconst direction = Math.sign( this._target - this._alpha );\n\t\t\tconst step = direction * delta / this.duration;\n\t\t\tthis._alpha = MathUtils.clamp( this._alpha + step, 0, 1 );\n\n\t\t\tthis.dispatchEvent( { type: 'change', alpha: this.alpha } );\n\n\t\t}\n\n\t\t// find the new camera\n\t\tconst prevCamera = camera;\n\t\tlet newCamera = null;\n\t\tif ( this._alpha === 0 ) {\n\n\t\t\tnewCamera = perspectiveCamera;\n\n\t\t} else if ( this._alpha === 1 ) {\n\n\t\t\tnewCamera = orthographicCamera;\n\n\t\t} else {\n\n\t\t\tnewCamera = transitionCamera;\n\t\t\tthis._updateTransitionCamera();\n\n\t\t}\n\n\t\tif ( prevCamera !== newCamera ) {\n\n\t\t\tif ( newCamera === transitionCamera ) {\n\n\t\t\t\tthis.dispatchEvent( { type: 'transition-start' } );\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( { type: 'camera-change', camera: newCamera, prevCamera: prevCamera } );\n\n\t\t\tif ( prevCamera === transitionCamera ) {\n\n\t\t\t\tthis.dispatchEvent( { type: 'transition-end' } );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsyncCameras() {\n\n\t\tconst fromCamera = this._getFromCamera();\n\t\tconst { perspectiveCamera, orthographicCamera, transitionCamera, fixedPoint } = this;\n\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( fromCamera.matrixWorld ).normalize();\n\n\t\tif ( fromCamera.isPerspectiveCamera ) {\n\n\t\t\t// offset the orthographic camera backwards based on user setting to avoid cases where the ortho\n\t\t\t// camera position will clip into terrain when once transitioned\n\t\t\tif ( this.orthographicPositionalZoom ) {\n\n\t\t\t\torthographicCamera.position.copy( perspectiveCamera.position ).addScaledVector( _forward, - this.orthographicOffset );\n\t\t\t\torthographicCamera.rotation.copy( perspectiveCamera.rotation );\n\t\t\t\torthographicCamera.updateMatrixWorld();\n\n\t\t\t} else {\n\n\t\t\t\tconst orthoDist = _vec.subVectors( fixedPoint, orthographicCamera.position ).dot( _forward );\n\t\t\t\tconst perspDist = _vec.subVectors( fixedPoint, perspectiveCamera.position ).dot( _forward );\n\n\t\t\t\t_vec.copy( perspectiveCamera.position ).addScaledVector( _forward, perspDist );\n\t\t\t\torthographicCamera.rotation.copy( perspectiveCamera.rotation );\n\t\t\t\torthographicCamera.position.copy( _vec ).addScaledVector( _forward, - orthoDist );\n\t\t\t\torthographicCamera.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\t// calculate the necessary orthographic zoom based on the current perspective camera position\n\t\t\tconst distToPoint = Math.abs( _vec.subVectors( perspectiveCamera.position, fixedPoint ).dot( _forward ) );\n\t\t\tconst projectionHeight = 2 * Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov * 0.5 ) * distToPoint;\n\t\t\tconst orthoHeight = orthographicCamera.top - orthographicCamera.bottom;\n\t\t\torthographicCamera.zoom = orthoHeight / projectionHeight;\n\t\t\torthographicCamera.updateProjectionMatrix();\n\n\t\t} else {\n\n\t\t\t// calculate the target distance from the point\n\t\t\tconst distToPoint = Math.abs( _vec.subVectors( orthographicCamera.position, fixedPoint ).dot( _forward ) );\n\t\t\tconst orthoHeight = ( orthographicCamera.top - orthographicCamera.bottom ) / orthographicCamera.zoom;\n\t\t\tconst targetDist = orthoHeight * 0.5 / Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov * 0.5 );\n\n\t\t\t// set the final camera position so the pivot point is stable\n\t\t\tperspectiveCamera.rotation.copy( orthographicCamera.rotation );\n\t\t\tperspectiveCamera.position.copy( orthographicCamera.position )\n\t\t\t\t.addScaledVector( _forward, distToPoint )\n\t\t\t\t.addScaledVector( _forward, - targetDist );\n\n\t\t\tperspectiveCamera.updateMatrixWorld();\n\n\t\t\t// shift the orthographic camera position so it aligns with the perspective cameras position as\n\t\t\t// calculated by the FoV. This ensures a consistent orthographic position on transition.\n\t\t\tif ( this.orthographicPositionalZoom ) {\n\n\t\t\t\torthographicCamera.position.copy( perspectiveCamera.position ).addScaledVector( _forward, - this.orthographicOffset );\n\t\t\t\torthographicCamera.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t}\n\n\t\ttransitionCamera.position.copy( perspectiveCamera.position );\n\t\ttransitionCamera.rotation.copy( perspectiveCamera.rotation );\n\n\t}\n\n\t_getTransitionDirection() {\n\n\t\treturn Math.sign( this._target - this._alpha );\n\n\t}\n\n\t_getToCamera() {\n\n\t\tconst dir = this._getTransitionDirection();\n\t\tif ( dir === 0 ) {\n\n\t\t\treturn this._target === 0 ? this.perspectiveCamera : this.orthographicCamera;\n\n\t\t} else if ( dir > 0 ) {\n\n\t\t\treturn this.orthographicCamera;\n\n\t\t} else {\n\n\t\t\treturn this.perspectiveCamera;\n\n\t\t}\n\n\t}\n\n\t_getFromCamera() {\n\n\t\tconst dir = this._getTransitionDirection();\n\t\tif ( dir === 0 ) {\n\n\t\t\treturn this._target === 0 ? this.perspectiveCamera : this.orthographicCamera;\n\n\t\t} else if ( dir > 0 ) {\n\n\t\t\treturn this.perspectiveCamera;\n\n\t\t} else {\n\n\t\t\treturn this.orthographicCamera;\n\n\t\t}\n\n\t}\n\n\t_updateTransitionCamera() {\n\n\t\t// Perform transition interpolation between the orthographic and perspective camera\n\t\t// alpha === 0 : perspective\n\t\t// alpha === 1 : orthographic\n\n\t\tconst { perspectiveCamera, orthographicCamera, transitionCamera, fixedPoint } = this;\n\t\tconst alpha = this.easeFunction( this._alpha );\n\n\t\t// get the forward vector\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( orthographicCamera.matrixWorld ).normalize();\n\n\t\t_orthographicCamera.copy( orthographicCamera );\n\t\t_orthographicCamera.position.addScaledVector( _forward, orthographicCamera.near );\n\t\torthographicCamera.far -= orthographicCamera.near;\n\t\torthographicCamera.near = 0;\n\n\t\t// compute the projection height based on the perspective camera\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( perspectiveCamera.matrixWorld ).normalize();\n\t\tconst distToPoint = Math.abs( _vec.subVectors( perspectiveCamera.position, fixedPoint ).dot( _forward ) );\n\t\tconst projectionHeight = 2 * Math.tan( MathUtils.DEG2RAD * perspectiveCamera.fov * 0.5 ) * distToPoint;\n\n\t\t// calculate the orientation to transition to\n\t\tconst targetQuat = _targetQuat.slerpQuaternions( perspectiveCamera.quaternion, _orthographicCamera.quaternion, alpha );\n\n\t\t// calculate the target distance and fov to position the camera at\n\t\tconst targetFov = MathUtils.lerp( perspectiveCamera.fov, 1, alpha );\n\t\tconst targetDistance = projectionHeight * 0.5 / Math.tan( MathUtils.DEG2RAD * targetFov * 0.5 );\n\n\t\t// calculate the offset from the fixed point\n\t\tconst orthoOffset = _orthoOffset.copy( _orthographicCamera.position ).sub( fixedPoint ).applyQuaternion( _quat.copy( _orthographicCamera.quaternion ).invert() );\n\t\tconst perspOffset = _perspOffset.copy( perspectiveCamera.position ).sub( fixedPoint ).applyQuaternion( _quat.copy( perspectiveCamera.quaternion ).invert() );\n\t\tconst targetOffset = _targetOffset.lerpVectors( perspOffset, orthoOffset, alpha );\n\t\ttargetOffset.z -= Math.abs( targetOffset.z ) - targetDistance;\n\n\t\t// calculate distances to the target point so the offset can be accounted for in near plane calculations\n\t\tconst distToPersp = - ( perspOffset.z - targetOffset.z );\n\t\tconst distToOrtho = - ( orthoOffset.z - targetOffset.z );\n\n\t\t// calculate the near and far plane positions\n\t\tconst targetNearPlane = MathUtils.lerp( distToPersp + perspectiveCamera.near, distToOrtho + _orthographicCamera.near, alpha );\n\t\tconst targetFarPlane = MathUtils.lerp( distToPersp + perspectiveCamera.far, distToOrtho + _orthographicCamera.far, alpha );\n\t\tconst planeDelta = Math.max( targetFarPlane, 0 ) - Math.max( targetNearPlane, 0 );\n\n\t\t// NOTE: The \"planeDelta * 1e-5\" can wind up being larger than either of the camera near planes, resulting\n\t\t// in some clipping during the transition phase.\n\n\t\t// update the camera state\n\t\ttransitionCamera.aspect = perspectiveCamera.aspect;\n\t\ttransitionCamera.fov = targetFov;\n\t\ttransitionCamera.near = Math.max( targetNearPlane, planeDelta * 1e-5 );\n\t\ttransitionCamera.far = targetFarPlane;\n\t\ttransitionCamera.position.copy( targetOffset ).applyQuaternion( targetQuat ).add( fixedPoint );\n\t\ttransitionCamera.quaternion.copy( targetQuat );\n\t\ttransitionCamera.updateProjectionMatrix();\n\t\ttransitionCamera.updateMatrixWorld();\n\n\t}\n\n}\n"],"names":["_forward","Vector3","_vec","_orthographicCamera","OrthographicCamera","_targetOffset","_perspOffset","_orthoOffset","_quat","Quaternion","_targetQuat","CameraTransitionManager","EventDispatcher","v","prevCamera","perspectiveCamera","PerspectiveCamera","orthographicCamera","x","Clock","deltaTime","transitionCamera","camera","delta","step","MathUtils","newCamera","fromCamera","fixedPoint","orthoDist","perspDist","distToPoint","projectionHeight","orthoHeight","targetDist","dir","alpha","targetQuat","targetFov","targetDistance","orthoOffset","perspOffset","targetOffset","distToPersp","distToOrtho","targetNearPlane","targetFarPlane","planeDelta"],"mappings":"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"}