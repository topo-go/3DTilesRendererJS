{"version":3,"file":"ImageOverlayPlugin-DZWlCL4f.js","sources":["../../../src/three/plugins/images/overlays/TiledTextureComposer.js","../../../src/three/plugins/images/overlays/utils.js","../../../src/three/plugins/images/overlays/wrapOverlaysMaterial.js","../../../src/three/plugins/images/ImageOverlayPlugin.js"],"sourcesContent":["import { ShaderMaterial, MathUtils, Vector2, PlaneGeometry, OrthographicCamera, Mesh, Color, DoubleSide } from 'three';\n\nconst _camera = /* @__PURE__ */ new OrthographicCamera();\nconst _color = /* @__PURE__ */ new Color();\n\n// Utility for composing a series of tiled textures together onto a target texture in a given range\nexport class TiledTextureComposer {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.renderTarget = null;\n\t\tthis.range = [ 0, 0, 1, 1 ];\n\t\tthis.quad = new Mesh( new PlaneGeometry(), new ComposeTextureMaterial() );\n\n\t}\n\n\t// set the target render texture and the range that represents the full span\n\tsetRenderTarget( renderTarget, range ) {\n\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.range = [ ...range ];\n\n\t}\n\n\t// draw the given texture at the given span with the provided projection\n\tdraw( texture, span ) {\n\n\t\t// draw the texture at the given sub range\n\t\tconst { range, renderer, quad, renderTarget } = this;\n\t\tconst material = quad.material;\n\t\tmaterial.map = texture;\n\n\t\t// map the range to draw the texture to\n\t\tmaterial.minRange.x = MathUtils.mapLinear( span[ 0 ], range[ 0 ], range[ 2 ], - 1, 1 );\n\t\tmaterial.minRange.y = MathUtils.mapLinear( span[ 1 ], range[ 1 ], range[ 3 ], - 1, 1 );\n\n\t\tmaterial.maxRange.x = MathUtils.mapLinear( span[ 2 ], range[ 0 ], range[ 2 ], - 1, 1 );\n\t\tmaterial.maxRange.y = MathUtils.mapLinear( span[ 3 ], range[ 1 ], range[ 3 ], - 1, 1 );\n\n\t\t// draw the texture\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.render( quad, _camera );\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\tmaterial.map = null;\n\n\t}\n\n\t// clear the set target\n\tclear( color, alpha = 1 ) {\n\n\t\t// clear the texture\n\t\tconst { renderer, renderTarget } = this;\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentClearColor = renderer.getClearColor( _color );\n\t\tconst currentClearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.setClearColor( color, alpha );\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.clear();\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setClearColor( currentClearColor, currentClearAlpha );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.quad.material.dispose();\n\t\tthis.quad.geometry.dispose();\n\n\t}\n\n}\n\n// Draws the given texture with no depth testing at the given bounds defined by \"minRange\" and \"maxRange\"\nclass ComposeTextureMaterial extends ShaderMaterial {\n\n\t// the [ - 1, 1 ] NDC ranges to draw the texture at\n\tget minRange() {\n\n\t\treturn this.uniforms.minRange.value;\n\n\t}\n\n\tget maxRange() {\n\n\t\treturn this.uniforms.maxRange.value;\n\n\t}\n\n\t// access the map being drawn\n\tget map() {\n\n\t\treturn this.uniforms.map.value;\n\n\t}\n\n\tset map( v ) {\n\n\t\tthis.uniforms.map.value = v;\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( {\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: false,\n\t\t\tside: DoubleSide,\n\t\t\tpremultipliedAlpha: true,\n\t\t\tuniforms: {\n\t\t\t\tmap: { value: null },\n\n\t\t\t\t// the normalized [0, 1] range of the target to draw to\n\t\t\t\tminRange: { value: new Vector2() },\n\t\t\t\tmaxRange: { value: new Vector2() },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tuniform vec2 minRange;\n\t\t\t\tuniform vec2 maxRange;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = vec4( mix( minRange, maxRange, uv ), 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform vec2 minRange;\n\t\t\t\tuniform vec2 maxRange;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// sample the texture\n\t\t\t\t\tgl_FragColor = texture( map, vUv );\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\n\t\t\t`,\n\t\t} );\n\n\n\t}\n\n}\n","import { Vector3, Matrix4, MathUtils } from 'three';\n\n// iterates over all present tiles in the given tile set at the given level in the given range\nexport function forEachTileInBounds( range, level, tiling, normalized, callback ) {\n\n\t// pull the bounds in a bit to avoid loading unnecessary tiles. 1e-8 was chosen since smaller values\n\t// are not larger enough and cause extra tiles to load in cases where 1-to-1 tile-to-image should occur\n\tlet [ minLon, minLat, maxLon, maxLat ] = range;\n\tminLat += 1e-8;\n\tminLon += 1e-8;\n\tmaxLat -= 1e-8;\n\tmaxLon -= 1e-8;\n\n\tconst clampedLevel = Math.max( Math.min( level, tiling.maxLevel ), tiling.minLevel );\n\tconst [ minX, minY, maxX, maxY ] = tiling.getTilesInRange( minLon, minLat, maxLon, maxLat, clampedLevel, normalized );\n\tfor ( let x = minX; x <= maxX; x ++ ) {\n\n\t\tfor ( let y = minY; y <= maxY; y ++ ) {\n\n\t\t\tcallback( x, y, clampedLevel );\n\n\t\t}\n\n\t}\n\n}\n\n// functions for generating UVs for cartographic-projected UVs\nfunction getGeometryCartographicChannel( geometry, geomToEllipsoidMatrix, ellipsoid ) {\n\n\tconst _vec = new Vector3();\n\tconst _cart = {};\n\tconst uv = [];\n\tconst posAttr = geometry.getAttribute( 'position' );\n\n\tgeometry.computeBoundingBox();\n\tgeometry.boundingBox.getCenter( _vec ).applyMatrix4( geomToEllipsoidMatrix );\n\n\t// find a rough mid lat / lon point\n\tellipsoid.getPositionToCartographic( _vec, _cart );\n\tconst centerLat = _cart.lat;\n\tconst centerLon = _cart.lon;\n\n\tlet minLat = Infinity;\n\tlet minLon = Infinity;\n\tlet minHeight = Infinity;\n\tlet maxLat = - Infinity;\n\tlet maxLon = - Infinity;\n\tlet maxHeight = - Infinity;\n\tfor ( let i = 0; i < posAttr.count; i ++ ) {\n\n\t\t// get the lat / lon values per vertex\n\t\t_vec.fromBufferAttribute( posAttr, i ).applyMatrix4( geomToEllipsoidMatrix );\n\t\tellipsoid.getPositionToCartographic( _vec, _cart );\n\n\t\t// The latitude calculations are not so stable at the poles so force the lat value to\n\t\t// the mid point to ensure we don't load an unnecessarily large of tiles\n\t\t// NOTE: this can distort the texture a bit at the poles\n\t\tif ( Math.abs( Math.abs( _cart.lat ) - Math.PI / 2 ) < 1e-5 ) {\n\n\t\t\t_cart.lon = centerLon;\n\n\t\t}\n\n\t\t// ensure we're not wrapping on the same geometry\n\t\tif ( Math.abs( centerLon - _cart.lon ) > Math.PI ) {\n\n\t\t\t_cart.lon += Math.sign( centerLon - _cart.lon ) * Math.PI * 2;\n\n\t\t}\n\n\t\tif ( Math.abs( centerLat - _cart.lat ) > Math.PI ) {\n\n\t\t\t_cart.lat += Math.sign( centerLat - _cart.lat ) * Math.PI * 2;\n\n\t\t}\n\n\t\tuv.push( _cart.lon, _cart.lat, _cart.height );\n\n\t\tminLat = Math.min( minLat, _cart.lat );\n\t\tmaxLat = Math.max( maxLat, _cart.lat );\n\n\t\tminLon = Math.min( minLon, _cart.lon );\n\t\tmaxLon = Math.max( maxLon, _cart.lon );\n\n\t\tminHeight = Math.min( minHeight, _cart.height );\n\t\tmaxHeight = Math.max( maxHeight, _cart.height );\n\n\t}\n\n\tconst range = [ minLon, minLat, maxLon, maxLat ];\n\tconst region = [ ...range, minHeight, maxHeight ];\n\treturn {\n\t\tuv,\n\t\trange,\n\t\tregion,\n\t};\n\n}\n\nexport function getMeshesCartographicRange( meshes, ellipsoid, meshToEllipsoidMatrix = null, tiling = null ) {\n\n\t// find the lat / lon ranges\n\tlet minLat = Infinity;\n\tlet minLon = Infinity;\n\tlet minHeight = Infinity;\n\tlet maxLat = - Infinity;\n\tlet maxLon = - Infinity;\n\tlet maxHeight = - Infinity;\n\tconst uvs = [];\n\n\tconst _matrix = new Matrix4();\n\tmeshes.forEach( mesh => {\n\n\t\t// multiply in the ellipsoid matrix if necessary\n\t\t_matrix.copy( mesh.matrixWorld );\n\t\tif ( meshToEllipsoidMatrix ) {\n\n\t\t\t_matrix.premultiply( meshToEllipsoidMatrix );\n\n\t\t}\n\n\t\tconst { uv, region } = getGeometryCartographicChannel( mesh.geometry, _matrix, ellipsoid );\n\t\tuvs.push( uv );\n\n\t\t// save the min and max values\n\t\tminLat = Math.min( minLat, region[ 1 ] );\n\t\tmaxLat = Math.max( maxLat, region[ 3 ] );\n\n\t\tminLon = Math.min( minLon, region[ 0 ] );\n\t\tmaxLon = Math.max( maxLon, region[ 2 ] );\n\n\t\tminHeight = Math.min( minHeight, region[ 4 ] );\n\t\tmaxHeight = Math.max( maxHeight, region[ 5 ] );\n\n\t} );\n\n\tlet clampedRange = [ minLon, minLat, maxLon, maxLat ];\n\tif ( tiling !== null ) {\n\n\t\t// Clamp the lat lon range to the bounds of the projection scheme. Note that clamping the data\n\t\t// allows for \"stretching\" the texture look at the edges of the projection which leads to a nicer\n\t\t// looking overlay. Eg at the poles of a web-mercator projection - otherwise there will be gaps\n\t\t// that show the underlying tile data. It's arguable which one is better but in all supported\n\t\t// ellipsoid projections (Web mercator, equirect) the projection ranges always span the entire\n\t\t// globe range.\n\t\t// const clampedRange = [ minLon, minLat, maxLon, maxLat ];\n\t\tclampedRange = tiling.clampToProjectionBounds( [ minLon, minLat, maxLon, maxLat ] );\n\t\tconst [ minU, minV, maxU, maxV ] = tiling.toNormalizedRange( clampedRange );\n\t\tuvs.forEach( uv => {\n\n\t\t\tfor ( let i = 0, l = uv.length; i < l; i += 3 ) {\n\n\t\t\t\tconst lon = uv[ i + 0 ];\n\t\t\t\tconst lat = uv[ i + 1 ];\n\t\t\t\tconst h = uv[ i + 2 ];\n\n\t\t\t\tconst [ u, v ] = tiling.toNormalizedPoint( lon, lat );\n\t\t\t\tuv[ i + 0 ] = MathUtils.mapLinear( u, minU, maxU, 0, 1 );\n\t\t\t\tuv[ i + 1 ] = MathUtils.mapLinear( v, minV, maxV, 0, 1 );\n\t\t\t\tuv[ i + 2 ] = MathUtils.mapLinear( h, minHeight, maxHeight, 0, 1 );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\treturn {\n\t\tuvs,\n\t\trange: clampedRange,\n\t\tregion: [ minLon, minLat, maxLon, maxLat, minHeight, maxHeight ],\n\t};\n\n}\n\n// functions for generating UVs for planar-projected UVs\nfunction getGeometryPlanarChannel( geometry, meshToFrame, aspectRatio ) {\n\n\tconst _vec = new Vector3();\n\tconst uv = [];\n\tconst posAttr = geometry.getAttribute( 'position' );\n\n\tlet minU = Infinity;\n\tlet minV = Infinity;\n\tlet minW = Infinity;\n\tlet maxU = - Infinity;\n\tlet maxV = - Infinity;\n\tlet maxW = - Infinity;\n\tfor ( let i = 0; i < posAttr.count; i ++ ) {\n\n\t\t// divide U by the aspect to stretch the U dimension to the aspect of the image\n\t\t_vec.fromBufferAttribute( posAttr, i ).applyMatrix4( meshToFrame );\n\t\t_vec.x /= aspectRatio;\n\n\t\tuv.push( _vec.x, _vec.y, _vec.z );\n\n\t\tminU = Math.min( minU, _vec.x );\n\t\tmaxU = Math.max( maxU, _vec.x );\n\n\t\tminV = Math.min( minV, _vec.y );\n\t\tmaxV = Math.max( maxV, _vec.y );\n\n\t\tminW = Math.min( minW, _vec.z );\n\t\tmaxW = Math.max( maxW, _vec.z );\n\n\t}\n\n\t// TODO: output a more complete bounds definition relative to the frame\n\tconst range = [ minU, minV, maxU, maxV ];\n\treturn {\n\t\tuv,\n\t\trange,\n\t\theightRange: [ minW, maxW ],\n\t};\n\n}\n\nexport function getMeshesPlanarRange( meshes, worldToFrame, tiling ) {\n\n\t// find the U / V ranges\n\tlet minU = Infinity;\n\tlet minV = Infinity;\n\tlet minW = Infinity;\n\tlet maxU = - Infinity;\n\tlet maxV = - Infinity;\n\tlet maxW = - Infinity;\n\tconst uvs = [];\n\n\tconst _matrix = new Matrix4();\n\tmeshes.forEach( mesh => {\n\n\t\t// multiply in the ellipsoid matrix if necessary\n\t\t_matrix.copy( mesh.matrixWorld );\n\t\tif ( worldToFrame ) {\n\n\t\t\t_matrix.premultiply( worldToFrame );\n\n\t\t}\n\n\t\tconst { uv, range, heightRange } = getGeometryPlanarChannel( mesh.geometry, _matrix, tiling.aspectRatio );\n\t\tuvs.push( uv );\n\n\t\t// save the min and max values\n\t\tminU = Math.min( minU, range[ 0 ] );\n\t\tmaxU = Math.max( maxU, range[ 2 ] );\n\n\t\tminV = Math.min( minV, range[ 1 ] );\n\t\tmaxV = Math.max( maxV, range[ 3 ] );\n\n\t\tminW = Math.min( minW, heightRange[ 0 ] );\n\t\tmaxW = Math.max( maxW, heightRange[ 1 ] );\n\n\t} );\n\n\tuvs.forEach( uv => {\n\n\t\tfor ( let i = 0, l = uv.length; i < l; i += 3 ) {\n\n\t\t\tconst u = uv[ i + 0 ];\n\t\t\tconst v = uv[ i + 1 ];\n\n\t\t\tuv[ i + 0 ] = MathUtils.mapLinear( u, minU, maxU, 0, 1 );\n\t\t\tuv[ i + 1 ] = MathUtils.mapLinear( v, minV, maxV, 0, 1 );\n\n\t\t}\n\n\t} );\n\n\t// TODO: output a more complete bounds definition relative to the frame\n\treturn {\n\t\tuvs,\n\t\trange: [ minU, minV, maxU, maxV ],\n\t\theightRange: [ minW, maxW ],\n\t};\n\n}\n","const OVERLAY_PARAMS = Symbol( 'OVERLAY_PARAMS' );\n\n// before compile can be used to chain shader adjustments. Returns the added uniforms used for fading.\nexport function wrapOverlaysMaterial( material, previousOnBeforeCompile ) {\n\n\t// if the material has already been wrapped then return the params\n\tif ( material[ OVERLAY_PARAMS ] ) {\n\n\t\treturn material[ OVERLAY_PARAMS ];\n\n\t}\n\n\tconst params = {\n\t\tlayerMaps: { value: [] },\n\t\tlayerColor: { value: [] },\n\t};\n\n\tmaterial[ OVERLAY_PARAMS ] = params;\n\n\tmaterial.defines = {\n\t\t...( material.defines || {} ),\n\t\tLAYER_COUNT: 0,\n\t};\n\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tif ( previousOnBeforeCompile ) {\n\n\t\t\tpreviousOnBeforeCompile( shader );\n\n\t\t}\n\n\t\tshader.uniforms = {\n\t\t\t...shader.uniforms,\n\t\t\t...params,\n\t\t};\n\n\t\tshader.vertexShader = shader\n\t\t\t.vertexShader\n\t\t\t.replace( /void main\\(\\s*\\)\\s*{/, value => /* glsl */`\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tattribute vec3 layer_uv_UNROLLED_LOOP_INDEX;\n\t\t\t\t\t\t\tvarying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t${ value }\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tv_layer_uv_UNROLLED_LOOP_INDEX = layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t` );\n\n\t\tshader.fragmentShader = shader\n\t\t\t.fragmentShader\n\t\t\t.replace( /void main\\(/, value => /* glsl */`\n\n\t\t\t\t#if LAYER_COUNT != 0\n\t\t\t\t\tstruct LayerTint {\n\t\t\t\t\t\tvec3 color;\n\t\t\t\t\t\tfloat opacity;\n\t\t\t\t\t};\n\n\t\t\t\t\tuniform sampler2D layerMaps[ LAYER_COUNT ];\n\t\t\t\t\tuniform LayerTint layerColor[ LAYER_COUNT ];\n\t\t\t\t#endif\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tvarying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t${ value }\n\n\t\t\t` )\n\t\t\t.replace( /#include <color_fragment>/, value => /* glsl */`\n\n\t\t\t\t${ value }\n\n\t\t\t\t#if LAYER_COUNT != 0\n\t\t\t\t{\n\t\t\t\t\tvec4 tint;\n\t\t\t\t\tvec3 layerUV;\n\t\t\t\t\tfloat layerOpacity;\n\t\t\t\t\tfloat wOpacity;\n\t\t\t\t\tfloat wDelta;\n\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\t\tlayerUV = v_layer_uv_UNROLLED_LOOP_INDEX;\n\t\t\t\t\t\t\t\ttint = texture( layerMaps[ i ], layerUV.xy );\n\n\t\t\t\t\t\t\t\t// discard texture outside 0, 1 on w\n\t\t\t\t\t\t\t\twDelta = fwidth( layerUV.z );\n\t\t\t\t\t\t\t\twOpacity = smoothstep( - wDelta, 0.0, layerUV.z ) * smoothstep( 1.0 + wDelta, 1.0, layerUV.z );\n\n\t\t\t\t\t\t\t\t// apply tint & opacity\n\t\t\t\t\t\t\t\ttint.rgb *= layerColor[ i ].color;\n\t\t\t\t\t\t\t\ttint.rgba *= layerColor[ i ].opacity * wOpacity;\n\n\t\t\t\t\t\t\t\t// premultiplied alpha equation\n\t\t\t\t\t\t\t\tdiffuseColor = tint + diffuseColor * ( 1.0 - tint.a );\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t}\n\t\t\t\t\t#pragma unroll_loop_end\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t` );\n\n\t};\n\n\treturn params;\n\n}\n","import { WebGLRenderTarget, Color, SRGBColorSpace, BufferAttribute, Matrix4, Vector3, Box3, Triangle, CanvasTexture } from 'three';\nimport { TiledTextureComposer } from './overlays/TiledTextureComposer.js';\nimport { XYZImageSource } from './sources/XYZImageSource.js';\nimport { TMSImageSource } from './sources/TMSImageSource.js';\nimport { forEachTileInBounds, getMeshesCartographicRange, getMeshesPlanarRange } from './overlays/utils.js';\nimport { CesiumIonAuth } from '../../../core/plugins/auth/CesiumIonAuth.js';\nimport { PriorityQueue } from '../../../core/renderer/utilities/PriorityQueue.js';\nimport { wrapOverlaysMaterial } from './overlays/wrapOverlaysMaterial.js';\nimport { GoogleCloudAuth } from '../../../core/plugins/auth/GoogleCloudAuth.js';\nimport { GeometryClipper } from '../utilities/GeometryClipper.js';\nimport { safeTextureGetByteLength } from '../../renderer/tiles/utilities.js';\nimport { WMTSImageSource } from './sources/WMTSImageSource.js';\n\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _sphereCenter = /* @__PURE__ */ new Vector3();\nconst _normal = /* @__PURE__ */ new Vector3();\nconst _box = /* @__PURE__ */ new Box3();\nconst SPLIT_TILE_DATA = Symbol( 'SPLIT_TILE_DATA' );\nconst SPLIT_HASH = Symbol( 'SPLIT_HASH' );\n\n// function for marking and releasing images in the given overlay\nfunction markOverlayImages( range, level, overlay, doRelease ) {\n\n\t// return null immediately if possible to allow for drawing without delay where possible\n\tif ( Array.isArray( overlay ) ) {\n\n\t\tconst promises = overlay\n\t\t\t.map( o => markOverlayImages( range, level, o, doRelease ) )\n\t\t\t.filter( p => p !== null );\n\n\t\tif ( promises.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t} else {\n\n\t\t\treturn Promise.all( promises );\n\n\t\t}\n\n\t}\n\n\tif ( ! overlay.isReady ) {\n\n\t\treturn overlay.whenReady().then( markImages );\n\n\t} else {\n\n\t\treturn markImages();\n\n\t}\n\n\tfunction markImages() {\n\n\t\tconst promises = [];\n\t\tconst { imageSource, tiling } = overlay;\n\t\tforEachTileInBounds( range, level, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\tif ( doRelease ) {\n\n\t\t\t\timageSource.release( tx, ty, tl );\n\n\t\t\t} else {\n\n\t\t\t\tpromises.push( imageSource.lock( tx, ty, tl ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst filteredPromises = promises.filter( p => p instanceof Promise );\n\t\tif ( filteredPromises.length !== 0 ) {\n\n\t\t\treturn Promise.all( filteredPromises );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n// returns the total number of tiles that will be drawn for the provided range\nfunction countTilesInRange( range, level, overlay ) {\n\n\tlet total = 0;\n\tforEachTileInBounds( range, level, overlay.tiling, overlay.isPlanarProjection, ( x, y, l ) => {\n\n\t\ttotal ++;\n\n\t} );\n\n\treturn total;\n\n}\n\n// Plugin for overlaying tiled image data on top of 3d tiles geometry.\nexport class ImageOverlayPlugin {\n\n\tget enableTileSplitting() {\n\n\t\treturn this._enableTileSplitting;\n\n\t}\n\n\tset enableTileSplitting( v ) {\n\n\t\tif ( this._enableTileSplitting !== v ) {\n\n\t\t\tthis._enableTileSplitting = v;\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\toverlays = [],\n\t\t\tresolution = 256,\n\t\t\trenderer = null,\n\t\t\tenableTileSplitting = true,\n\t\t} = options;\n\n\t\t// plugin needs to run before other plugins that fetch data since content\n\t\t// is handled and loaded in a custom way\n\t\tthis.name = 'IMAGE_OVERLAY_PLUGIN';\n\t\tthis.priority = - 15;\n\n\t\t// options\n\t\tthis.renderer = renderer;\n\t\tthis.resolution = resolution;\n\t\tthis._enableTileSplitting = enableTileSplitting;\n\t\tthis.overlays = [];\n\n\t\t// internal\n\t\tthis.needsUpdate = false;\n\t\tthis.tiles = null;\n\t\tthis.tileComposer = null;\n\t\tthis.tileControllers = new Map();\n\t\tthis.overlayInfo = new Map();\n\t\tthis.usedTextures = new Set();\n\t\tthis.meshParams = new WeakMap();\n\t\tthis.pendingTiles = new Map();\n\t\tthis.processQueue = null;\n\t\tthis._onUpdateAfter = null;\n\t\tthis._onTileDownloadStart = null;\n\t\tthis._cleanupScheduled = false;\n\t\tthis._virtualChildResetId = 0;\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\toverlays.forEach( overlay => {\n\n\t\t\tthis.addOverlay( overlay );\n\n\t\t} );\n\n\t}\n\n\t// plugin functions\n\tinit( tiles ) {\n\n\t\tconst tileComposer = new TiledTextureComposer( this.renderer );\n\t\tconst processQueue = new PriorityQueue();\n\t\tprocessQueue.maxJobs = 10;\n\t\tprocessQueue.priorityCallback = ( a, b ) => {\n\n\t\t\tconst tileA = a.tile;\n\t\t\tconst tileB = b.tile;\n\n\t\t\tconst visibleA = tiles.visibleTiles.has( tileA );\n\t\t\tconst visibleB = tiles.visibleTiles.has( tileB );\n\t\t\tif ( visibleA !== visibleB ) {\n\n\t\t\t\t// load visible tiles first\n\t\t\t\treturn visibleA ? 1 : - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// the fallback to the download queue tile priority\n\t\t\t\treturn tiles.downloadQueue.priorityCallback( tileA, tileB );\n\n\t\t\t}\n\n\t\t\t// TODO: we could prioritize by overlay order here to ensure consistency\n\n\t\t};\n\n\t\t// save variables\n\t\tthis.tiles = tiles;\n\t\tthis.tileComposer = tileComposer;\n\t\tthis.processQueue = processQueue;\n\n\t\t// init all existing tiles\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._processTileModel( scene, tile, true );\n\n\t\t} );\n\n\t\t// update callback for when overlays have changed\n\t\tthis._onUpdateAfter = async () => {\n\n\t\t\t// check if the projection changed for any of the overlays and refresh them\n\t\t\tlet overlayChanged = false;\n\t\t\tthis.overlayInfo.forEach( ( info, overlay ) => {\n\n\t\t\t\tif (\n\t\t\t\t\tBoolean( overlay.frame ) !== Boolean( info.frame ) ||\n\t\t\t\t\toverlay.frame && info.frame && ! info.frame.equals( overlay.frame )\n\t\t\t\t) {\n\n\t\t\t\t\tconst order = info.order;\n\t\t\t\t\tthis.deleteOverlay( overlay, false );\n\t\t\t\t\tthis.addOverlay( overlay, order );\n\n\t\t\t\t\toverlayChanged = true;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// trigger redraws for visible tiles if overlays updated\n\t\t\tif ( overlayChanged ) {\n\n\t\t\t\tconst maxJobs = processQueue.maxJobs;\n\t\t\t\tlet count = 0;\n\t\t\t\tprocessQueue.items.forEach( info => {\n\n\t\t\t\t\tif ( tiles.visibleTiles.has( info.tile ) ) {\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tprocessQueue.maxJobs = count + processQueue.currJobs;\n\t\t\t\tprocessQueue.tryRunJobs();\n\t\t\t\tprocessQueue.maxJobs = maxJobs;\n\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\t// update all the layer uvs\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.needsUpdate = false;\n\n\t\t\t\tconst { overlays, overlayInfo } = this;\n\t\t\t\toverlays.sort( ( a, b ) => {\n\n\t\t\t\t\treturn overlayInfo.get( a ).order - overlayInfo.get( b ).order;\n\n\t\t\t\t} );\n\n\t\t\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\t\t\tthis._updateLayers( tile );\n\n\t\t\t\t} );\n\n\t\t\t\tthis.resetVirtualChildren( ! this.enableTileSplitting );\n\t\t\t\ttiles.recalculateBytesUsed();\n\n\t\t\t\ttiles.dispatchEvent( { type: 'needs-rerender' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis._onTileDownloadStart = ( { tile } ) => {\n\n\t\t\tthis._initTileOverlayInfo( tile );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.addEventListener( 'tile-download-start', this._onTileDownloadStart );\n\n\t\tthis.overlays.forEach( overlay => {\n\n\t\t\tthis._initOverlay( overlay );\n\n\t\t} );\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tconst { overlayInfo, tileControllers, processQueue, pendingTiles } = this;\n\n\t\t// Cancel any ongoing tasks. If a tile is cancelled while downloading\n\t\t// this will not have been created, yet.\n\t\tif ( tileControllers.has( tile ) ) {\n\n\t\t\ttileControllers.get( tile ).abort();\n\t\t\ttileControllers.delete( tile );\n\t\t\tpendingTiles.delete( tile );\n\n\t\t}\n\n\t\t// stop any tile loads\n\t\toverlayInfo.forEach( ( ( { tileInfo }, overlay ) => {\n\n\t\t\tif ( tileInfo.has( tile ) ) {\n\n\t\t\t\tconst { meshInfo, range, meshRange, level, target, meshRangeMarked, rangeMarked } = tileInfo.get( tile );\n\n\t\t\t\t// release the ranges\n\t\t\t\tif ( meshRange !== null && meshRangeMarked ) {\n\n\t\t\t\t\tmarkOverlayImages( meshRange, level, overlay, true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( range !== null && rangeMarked ) {\n\n\t\t\t\t\tmarkOverlayImages( range, level, overlay, true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( target !== null ) {\n\n\t\t\t\t\t// release the render targets\n\t\t\t\t\ttarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t\ttileInfo.delete( tile );\n\t\t\t\tmeshInfo.clear();\n\n\t\t\t}\n\n\t\t} ) );\n\n\t\t// Remove any items that reference the tile being disposed\n\t\tprocessQueue.removeByFilter( item => {\n\n\t\t\treturn item.tile === tile;\n\n\t\t} );\n\n\t}\n\n\tcalculateBytesUsed( tile ) {\n\n\t\tconst { overlayInfo } = this;\n\t\tconst bytesUsed = this._bytesUsed;\n\n\t\tlet bytes = null;\n\t\toverlayInfo.forEach( ( { tileInfo }, overlay ) => {\n\n\t\t\tif ( tileInfo.has( tile ) ) {\n\n\t\t\t\tconst { target } = tileInfo.get( tile );\n\t\t\t\tbytes = bytes || 0;\n\t\t\t\tbytes += safeTextureGetByteLength( target?.texture );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( bytes !== null ) {\n\n\t\t\tbytesUsed.set( tile, bytes );\n\t\t\treturn bytes;\n\n\t\t} else if ( bytesUsed.has( tile ) ) {\n\n\t\t\treturn bytesUsed.get( tile );\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tprocessTileModel( scene, tile ) {\n\n\t\treturn this._processTileModel( scene, tile );\n\n\t}\n\n\tasync _processTileModel( scene, tile, initialization = false ) {\n\n\t\tthis.tileControllers.set( tile, new AbortController() );\n\n\t\tif ( ! initialization ) {\n\n\t\t\t// we save all these pending tiles so that they can be correctly initialized if an\n\t\t\t// overlay is added in the time between when this function starts and after the async\n\t\t\t// await call. Otherwise the tile could be missed. But if we're initializing the plugin\n\t\t\t// then we don't need to do this because the tiles are already included in the traversal.\n\t\t\tthis.pendingTiles.set( tile, scene );\n\n\t\t}\n\n\t\tthis._wrapMaterials( scene );\n\t\tthis._initTileOverlayInfo( tile );\n\t\tawait this._initTileSceneOverlayInfo( scene, tile );\n\t\tthis.expandVirtualChildren( scene, tile ),\n\t\tthis._updateLayers( tile );\n\n\t\tthis.pendingTiles.delete( tile );\n\n\t}\n\n\tdispose() {\n\n\t\tconst { tileComposer, tiles } = this;\n\n\t\t// dispose textures\n\t\ttileComposer.dispose();\n\n\t\t// dispose of all overlays\n\t\tconst overlays = [ ...this.overlays ];\n\t\toverlays.forEach( overlay => {\n\n\t\t\tthis.deleteOverlay( overlay );\n\n\t\t} );\n\n\t\t// reset the textures of the meshes\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._updateLayers( tile );\n\t\t\tthis.disposeTile( tile );\n\n\t\t\tdelete tile[ SPLIT_HASH ];\n\n\t\t} );\n\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfter );\n\n\t\tthis.resetVirtualChildren( true );\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tthis.overlays.forEach( overlay => {\n\n\t\t\tif ( overlay.opacity > 0 ) {\n\n\t\t\t\toverlay.getAttributions( target );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tparseToMesh( buffer, tile, extension, uri ) {\n\n\t\tif ( extension === 'image_overlay_tile_split' ) {\n\n\t\t\treturn tile[ SPLIT_TILE_DATA ];\n\n\t\t}\n\n\t}\n\n\tasync resetVirtualChildren( fullDispose = false ) {\n\n\t\t// only run this if all the overlays are ready and tile targets have been generated, etc\n\t\t// so we can make an effort to only remove the necessary tiles.\n\t\tthis._virtualChildResetId ++;\n\t\tconst id = this._virtualChildResetId;\n\n\t\tawait Promise.all( this.overlays.map( o => o.whenReady() ) );\n\n\t\tif ( id !== this._virtualChildResetId ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// collect the tiles split into virtual tiles\n\t\tconst { tiles } = this;\n\t\tconst parents = new Set();\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tif ( SPLIT_HASH in tile ) {\n\n\t\t\t\tparents.add( tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// dispose of the virtual children if this tile would not be split or the spilt could change\n\t\t// under the current overlays used.\n\t\tparents.forEach( parent => {\n\n\t\t\tif ( parent.parent === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst clone = parent.cached.scene.clone();\n\t\t\tclone.updateMatrixWorld();\n\n\t\t\tconst { hash } = this._getSplitVectors( clone, parent );\n\t\t\tif ( parent[ SPLIT_HASH ] !== hash || fullDispose ) {\n\n\t\t\t\t// TODO: if are parent tile is forcibly remove then we should make sure that all the children are, too?\n\t\t\t\tconst children = collectChildren( parent );\n\t\t\t\tchildren.sort( ( a, b ) => ( b.__depth || 0 ) - ( a.__depth || 0 ) );\n\n\t\t\t\t// note that we need to remove children from the processing queue in this case\n\t\t\t\t// because we are forcibly evicting them from the cache.\n\t\t\t\tchildren.forEach( child => {\n\n\t\t\t\t\ttiles.processNodeQueue.remove( child );\n\t\t\t\t\ttiles.lruCache.remove( child );\n\t\t\t\t\tchild.parent = null;\n\n\t\t\t\t} );\n\n\t\t\t\tparent.children.length = 0;\n\t\t\t\tparent.__childrenProcessed = 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// re-expand tiles if needed\n\t\tif ( ! fullDispose ) {\n\n\t\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\t\tthis.expandVirtualChildren( scene, tile );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction collectChildren( root, target = [] ) {\n\n\t\t\troot.children.forEach( child => {\n\n\t\t\t\ttarget.push( child );\n\t\t\t\tcollectChildren( child, target );\n\n\t\t\t} );\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n\t_getSplitVectors( scene, tile, centerTarget = _center ) {\n\n\t\tconst { tiles, overlayInfo } = this;\n\n\t\t// get the center of the content\n\t\tconst box = new Box3();\n\t\tbox.setFromObject( scene );\n\t\tbox.getCenter( centerTarget );\n\n\t\t// find the vectors that are orthogonal to every overlay projection\n\t\tconst splitDirections = [];\n\t\tconst hashTokens = [];\n\t\toverlayInfo.forEach( ( { tileInfo }, overlay ) => {\n\n\t\t\t// if the tile has a render target associated with the overlay and the last level of detail\n\t\t\t// is not being displayed, yet, then we need to split\n\t\t\tconst info = tileInfo.get( tile );\n\t\t\tif ( info && info.target && overlay.tiling.maxLevel > info.level ) {\n\n\t\t\t\t// get the vector representing the projection direction\n\t\t\t\tif ( overlay.frame ) {\n\n\t\t\t\t\t_normal.set( 0, 0, 1 ).transformDirection( overlay.frame );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttiles.ellipsoid.getPositionToNormal( centerTarget, _normal );\n\t\t\t\t\tif ( _normal.length() < 1e-6 ) {\n\n\t\t\t\t\t\t_normal.set( 1, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// dedupe vectors in the hash\n\t\t\t\tconst token = `${ _normal.x.toFixed( 3 ) },${ _normal.y.toFixed( 3 ) },${ _normal.z.toFixed( 3 ) }_`;\n\t\t\t\tif ( ! hashTokens.includes( token ) ) {\n\n\t\t\t\t\thashTokens.push( token );\n\n\t\t\t\t}\n\n\t\t\t\t// construct the orthogonal vectors\n\t\t\t\tconst other = _vec.set( 0, 0, 1 );\n\t\t\t\tif ( Math.abs( _normal.dot( other ) ) > 1 - 1e-4 ) {\n\n\t\t\t\t\tother.set( 1, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tconst ortho0 = new Vector3().crossVectors( _normal, other ).normalize();\n\t\t\t\tconst ortho1 = new Vector3().crossVectors( _normal, ortho0 ).normalize();\n\t\t\t\tsplitDirections.push( ortho0, ortho1 );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Generate a reduced set of vectors by averages directions in a 45 degree cone so\n\t\t// we don't split unnecessarily\n\t\tconst directions = [];\n\t\twhile ( splitDirections.length !== 0 ) {\n\n\t\t\tconst normalized = splitDirections.pop().clone();\n\t\t\tconst average = normalized.clone();\n\t\t\tfor ( let i = 0; i < splitDirections.length; i ++ ) {\n\n\t\t\t\tconst dir = splitDirections[ i ];\n\t\t\t\tconst dotProduct = normalized.dot( dir );\n\t\t\t\tif ( Math.abs( dotProduct ) > Math.cos( Math.PI / 8 ) ) {\n\n\t\t\t\t\taverage.addScaledVector( dir, Math.sign( dotProduct ) );\n\t\t\t\t\tnormalized.copy( average ).normalize();\n\t\t\t\t\tsplitDirections.splice( i, 1 );\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdirections.push( average.normalize() );\n\n\t\t}\n\n\t\treturn { directions, hash: hashTokens.join( '' ) };\n\n\t}\n\n\tasync expandVirtualChildren( scene, tile ) {\n\n\t\tif ( tile.children.length !== 0 || this.enableTileSplitting === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// create a copy of the content to transform and split\n\t\tconst clone = scene.clone();\n\t\tclone.updateMatrixWorld();\n\n\t\t// get the directions to split on\n\t\tconst { directions, hash } = this._getSplitVectors( clone, tile, _center );\n\t\ttile[ SPLIT_HASH ] = hash;\n\n\t\t// if there are no directions to split on then exit early\n\t\tif ( directions.length === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// set up the splitter to ignore overlay uvs\n\t\tconst clipper = new GeometryClipper();\n\t\tclipper.attributeList = key => ! /^layer_uv_\\d+/.test( key );\n\t\tdirections.map( splitDirection => {\n\n\t\t\tclipper.addSplitOperation( ( geometry, i0, i1, i2, barycoord, matrixWorld ) => {\n\n\t\t\t\tTriangle.getInterpolatedAttribute( geometry.attributes.position, i0, i1, i2, barycoord, _vec );\n\t\t\t\treturn _vec.applyMatrix4( matrixWorld ).sub( _center ).dot( splitDirection );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t// run the clipping operations by performing every permutation of sides\n\t\t// defined by the split directions\n\t\tconst children = [];\n\t\tclipper.forEachSplitPermutation( () => {\n\n\t\t\t// clip the object itself\n\t\t\tconst result = clipper.clipObject( clone );\n\n\t\t\t// remove the parent transform because it will be multiplied back in after the fact\n\t\t\tresult.matrix\n\t\t\t\t.premultiply( tile.cached.transformInverse )\n\t\t\t\t.decompose( result.position, result.quaternion, result.scale );\n\n\t\t\t// collect the meshes\n\t\t\tconst meshes = [];\n\t\t\tresult.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tconst material = c.material.clone();\n\t\t\t\t\tc.material = material;\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\t\tif ( value.source.data instanceof ImageBitmap ) {\n\n\t\t\t\t\t\t\t\t// clone any image bitmap textures using canvas because if we share the texture then when\n\t\t\t\t\t\t\t\t// the clipped child is disposed then it will dispose of the parent tile texture data, as well.\n\t\t\t\t\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\t\t\t\t\tcanvas.width = value.image.width;\n\t\t\t\t\t\t\t\tcanvas.height = value.image.height;\n\n\t\t\t\t\t\t\t\tconst ctx = canvas.getContext( '2d' );\n\t\t\t\t\t\t\t\tctx.scale( 1, - 1 );\n\t\t\t\t\t\t\t\tctx.drawImage( value.source.data, 0, 0, canvas.width, - canvas.height );\n\n\t\t\t\t\t\t\t\tconst tex = new CanvasTexture( canvas );\n\t\t\t\t\t\t\t\ttex.mapping = value.mapping;\n\t\t\t\t\t\t\t\ttex.wrapS = value.wrapS;\n\t\t\t\t\t\t\t\ttex.wrapT = value.wrapT;\n\t\t\t\t\t\t\t\ttex.minFilter = value.minFilter;\n\t\t\t\t\t\t\t\ttex.magFilter = value.magFilter;\n\t\t\t\t\t\t\t\ttex.format = value.format;\n\t\t\t\t\t\t\t\ttex.type = value.type;\n\t\t\t\t\t\t\t\ttex.anisotropy = value.anisotropy;\n\t\t\t\t\t\t\t\ttex.colorSpace = value.colorSpace;\n\t\t\t\t\t\t\t\ttex.generateMipmaps = value.generateMipmaps;\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = tex;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( meshes.length === 0 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// generate a region bounding volume\n\t\t\tconst boundingVolume = {};\n\t\t\tif ( tile.boundingVolume.region ) {\n\n\t\t\t\tboundingVolume.region = getMeshesCartographicRange( meshes, this.tiles.ellipsoid ).region;\n\n\t\t\t}\n\n\t\t\t// create a sphere bounding volume\n\t\t\tif ( tile.boundingVolume.box || tile.boundingVolume.sphere ) {\n\n\t\t\t\t// TODO: we create a sphere even when a region is present because currently the handling of region volumes\n\t\t\t\t// is a bit flaky especially at small scales. OBBs are generated which can be imperfect resulting rays passing\n\t\t\t\t// through tiles. The same may be the case with frustum checks. In theory, though, we should not need a sphere\n\t\t\t\t// bounds if a region bounds are present.\n\n\t\t\t\t// compute the sphere center\n\t\t\t\t_box\n\t\t\t\t\t.setFromObject( result, true )\n\t\t\t\t\t.getCenter( _sphereCenter );\n\n\t\t\t\t// calculate the sq radius from all vertices\n\t\t\t\tlet maxSqRadius = 0;\n\t\t\t\tresult.traverse( c => {\n\n\t\t\t\t\tconst geometry = c.geometry;\n\t\t\t\t\tif ( geometry ) {\n\n\t\t\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst sqRadius = _vec\n\t\t\t\t\t\t\t\t.fromBufferAttribute( position, i )\n\t\t\t\t\t\t\t\t.applyMatrix4( c.matrixWorld )\n\t\t\t\t\t\t\t\t.distanceToSquared( _sphereCenter );\n\n\t\t\t\t\t\t\tmaxSqRadius = Math.max( maxSqRadius, sqRadius );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tboundingVolume.sphere = [ ..._sphereCenter, Math.sqrt( maxSqRadius ) ];\n\n\t\t\t}\n\n\t\t\tchildren.push( {\n\t\t\t\trefine: 'REPLACE',\n\t\t\t\tgeometricError: tile.geometricError * 0.5,\n\t\t\t\tboundingVolume: boundingVolume,\n\t\t\t\tcontent: { uri: './child.image_overlay_tile_split' },\n\t\t\t\tchildren: [],\n\t\t\t\t[ SPLIT_TILE_DATA ]: result,\n\t\t\t} );\n\n\t\t} );\n\n\t\ttile.children.push( ...children );\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\t// if this is our custom url indicating a tile split then return fake response\n\t\tif ( /image_overlay_tile_split/.test( uri ) ) {\n\n\t\t\treturn new ArrayBuffer();\n\n\t\t}\n\n\t}\n\n\t// public\n\taddOverlay( overlay, order = null ) {\n\n\t\tconst { tiles, overlays, overlayInfo } = this;\n\n\t\tif ( order === null ) {\n\n\t\t\t// set the order to the next largest order value\n\t\t\torder = overlays.reduce( ( v, o ) => Math.max( v, o.order + 1 ), 0 );\n\n\t\t}\n\n\t\tconst controller = new AbortController();\n\t\toverlays.push( overlay );\n\t\toverlayInfo.set( overlay, {\n\t\t\torder: order,\n\t\t\tuniforms: {},\n\t\t\ttileInfo: new Map(),\n\t\t\tcontroller: controller,\n\t\t\tframe: overlay.frame ? overlay.frame.clone() : null,\n\t\t} );\n\n\t\tif ( tiles !== null ) {\n\n\t\t\tthis._initOverlay( overlay );\n\n\t\t}\n\n\t}\n\n\tsetOverlayOrder( overlay, order ) {\n\n\t\tconst index = this.overlays.indexOf( overlay );\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.overlayInfo.get( overlay ).order = order;\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tdeleteOverlay( overlay, forceDispose = true ) {\n\n\t\tconst { overlays, overlayInfo, processQueue } = this;\n\t\tconst index = overlays.indexOf( overlay );\n\t\tif ( index !== - 1 ) {\n\n\t\t\tconst { tileInfo, controller } = overlayInfo.get( overlay );\n\t\t\ttileInfo.forEach( ( { meshInfo, target } ) => {\n\n\t\t\t\tif ( target !== null ) {\n\n\t\t\t\t\ttarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tmeshInfo.clear();\n\n\t\t\t} );\n\n\t\t\ttileInfo.clear();\n\t\t\toverlayInfo.delete( overlay );\n\t\t\tcontroller.abort();\n\n\t\t\t// Remove any items that reference the overlay being disposed\n\t\t\tprocessQueue.removeByFilter( item => {\n\n\t\t\t\treturn item.overlay === overlay;\n\n\t\t\t} );\n\n\t\t\toverlays.splice( index, 1 );\n\t\t\tif ( forceDispose ) {\n\n\t\t\t\toverlay.dispose();\n\n\t\t\t}\n\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\t// internal\n\t_calculateLevelFromOverlay( overlay, range, tile, normalized = false ) {\n\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\tconst { resolution } = this;\n\t\t\tconst { tiling } = overlay;\n\n\t\t\tconst normalizedRange = normalized ? range : tiling.toNormalizedRange( range );\n\t\t\tconst [ minX, minY, maxX, maxY ] = normalizedRange;\n\t\t\tconst w = maxX - minX;\n\t\t\tconst h = maxY - minY;\n\n\t\t\tlet level = 0;\n\t\t\tconst { maxLevel } = tiling;\n\t\t\tfor ( ; level < maxLevel; level ++ ) {\n\n\t\t\t\t// the number of pixels per image on each axis\n\t\t\t\tconst wProj = resolution / w;\n\t\t\t\tconst hProj = resolution / h;\n\n\t\t\t\tconst { pixelWidth, pixelHeight } = tiling.getLevel( level );\n\t\t\t\tif ( pixelWidth >= wProj || pixelHeight >= hProj ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: should this be one layer higher LoD?\n\t\t\treturn level;\n\n\t\t} else {\n\n\t\t\treturn tile.__depthFromRenderedParent - 1;\n\n\t\t}\n\n\t}\n\n\t// initialize the overlay to use the right fetch options, load all data for existing tiles\n\t_initOverlay( overlay ) {\n\n\t\tconst { tiles } = this;\n\t\toverlay.imageSource.fetchOptions = tiles.fetchOptions;\n\t\tif ( ! overlay.isInitialized ) {\n\n\t\t\toverlay.imageSource.fetchData = ( ...args ) => tiles\n\t\t\t\t.downloadQueue\n\t\t\t\t.add( { priority: - performance.now() }, () => {\n\n\t\t\t\t\treturn overlay.fetch( ...args );\n\n\t\t\t\t} );\n\t\t\toverlay.init();\n\n\t\t}\n\n\t\tconst promises = [];\n\t\tconst initTile = async ( scene, tile ) => {\n\n\t\t\tthis._initTileOverlayInfo( tile, overlay );\n\n\t\t\tconst promise = this._initTileSceneOverlayInfo( scene, tile, overlay );\n\t\t\tpromises.push( promise );\n\n\t\t\t// mark tiles as needing an update after initialized so we get a trickle in of tiles\n\t\t\tawait promise;\n\t\t\tthis._updateLayers( tile );\n\n\t\t};\n\n\t\ttiles.forEachLoadedModel( initTile );\n\t\tthis.pendingTiles.forEach( ( scene, tile ) => {\n\n\t\t\tinitTile( scene, tile );\n\n\t\t} );\n\n\t\tPromise.all( promises ).then( () => {\n\n\t\t\tthis._markNeedsUpdate();\n\n\t\t} );\n\n\t}\n\n\t// wrap all materials in the given scene wit the overlay material shader\n\t_wrapMaterials( scene ) {\n\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst params = wrapOverlaysMaterial( c.material, c.material.onBeforeCompile );\n\t\t\t\tthis.meshParams.set( c, params );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// Initialize per-tile overlay information. This function triggers an async function but\n\t// does not need to be awaited for use since it's just locking textures which are awaited later.\n\t_initTileOverlayInfo( tile, overlay = this.overlays ) {\n\n\t\tif ( Array.isArray( overlay ) ) {\n\n\t\t\toverlay.forEach( o => this._initTileOverlayInfo( tile, o ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// This function is resilient to multiple calls in case an overlay is added after a tile starts loading\n\t\t// and before it is loaded, meaning this function needs to be called twice to ensure it's initialized.\n\t\tconst { overlayInfo, processQueue } = this;\n\t\tif ( overlayInfo.get( overlay ).tileInfo.has( tile ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst level = tile.__depthFromRenderedParent - 1;\n\t\tconst info = {\n\t\t\trange: null,\n\t\t\tmeshRange: null,\n\t\t\tlevel: null,\n\t\t\ttarget: null,\n\t\t\tmeshInfo: new Map(),\n\n\t\t\trangeMarked: false,\n\t\t\tmeshRangeMarked: false,\n\t\t};\n\n\t\toverlayInfo\n\t\t\t.get( overlay )\n\t\t\t.tileInfo\n\t\t\t.set( tile, info );\n\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\t// TODO: we could project the shape into the frame, compute 2d bounds, and then mark tiles\n\n\t\t} else {\n\n\t\t\t// If the tile has a region bounding volume then mark the tiles to preload\n\t\t\tif ( tile.boundingVolume.region ) {\n\n\t\t\t\tconst [ minLon, minLat, maxLon, maxLat ] = tile.boundingVolume.region;\n\t\t\t\tconst range = [ minLon, minLat, maxLon, maxLat ];\n\t\t\t\tinfo.range = range;\n\t\t\t\tinfo.level = this._calculateLevelFromOverlay( overlay, range, tile );\n\n\t\t\t\tprocessQueue\n\t\t\t\t\t.add( { tile, overlay }, () => {\n\n\t\t\t\t\t\tinfo.rangeMarked = true;\n\t\t\t\t\t\treturn markOverlayImages( range, level, overlay, false );\n\n\t\t\t\t\t} )\n\t\t\t\t\t.catch( () => {\n\n\t\t\t\t\t\t// the queue throws an error if a task is removed early\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the scene meshes\n\tasync _initTileSceneOverlayInfo( scene, tile, overlay = this.overlays ) {\n\n\t\tif ( Array.isArray( overlay ) ) {\n\n\t\t\treturn Promise.all( overlay.map( o => this._initTileSceneOverlayInfo( scene, tile, o ) ) );\n\n\t\t}\n\n\t\tconst { tiles, overlayInfo, resolution, tileComposer, tileControllers, usedTextures, processQueue } = this;\n\t\tconst { ellipsoid } = tiles;\n\t\tconst { controller, tileInfo } = overlayInfo.get( overlay );\n\t\tconst tileController = tileControllers.get( tile );\n\n\t\t// wait for the overlay to be completely loaded so projection and tiling are available\n\t\tif ( ! overlay.isReady ) {\n\n\t\t\tawait overlay.whenReady();\n\n\t\t}\n\n\t\t// check if the overlay or tile have been disposed since starting this function\n\t\t// if the tileController is not present then the tile has been disposed of already\n\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// find all meshes to project on and ensure matrices are up to date\n\t\tconst meshes = [];\n\t\tscene.updateMatrixWorld();\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst { tiling, imageSource } = overlay;\n\t\tconst info = tileInfo.get( tile );\n\t\tlet range, uvs, heightInRange;\n\n\t\t// retrieve the uvs and range for all the meshes\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\t_matrix.copy( overlay.frame ).invert();\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.multiply( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tlet heightRange;\n\t\t\t( { range, uvs, heightRange } = getMeshesPlanarRange( meshes, _matrix, tiling ) );\n\t\t\theightInRange = ! ( heightRange[ 0 ] > 1 || heightRange[ 1 ] < 0 );\n\n\t\t} else {\n\n\t\t\t_matrix.identity();\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.copy( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\t( { range, uvs } = getMeshesCartographicRange( meshes, ellipsoid, _matrix, tiling ) );\n\t\t\theightInRange = true;\n\n\t\t}\n\n\t\tlet normalizedRange;\n\t\tif ( ! overlay.isPlanarProjection ) {\n\n\t\t\tnormalizedRange = tiling.toNormalizedRange( range );\n\n\t\t} else {\n\n\t\t\tnormalizedRange = range;\n\n\t\t}\n\n\t\t// calculate the tiling level here if not already created\n\t\tif ( info.level === null ) {\n\n\t\t\tinfo.level = this._calculateLevelFromOverlay( overlay, normalizedRange, tile, true );\n\n\t\t}\n\n\t\t// if the image projection is outside the 0, 1 uvw range or there are no textures to draw in\n\t\t// the tiled image set the don't allocate a texture for it.\n\t\tlet target = null;\n\t\tif ( heightInRange && countTilesInRange( range, info.level, overlay ) !== 0 ) {\n\n\t\t\ttarget = new WebGLRenderTarget( resolution, resolution, {\n\t\t\t\tdepthBuffer: false,\n\t\t\t\tstencilBuffer: false,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\tcolorSpace: SRGBColorSpace,\n\t\t\t} );\n\n\t\t}\n\n\t\tinfo.meshRange = range;\n\t\tinfo.target = target;\n\n\t\tmeshes.forEach( ( mesh, i ) => {\n\n\t\t\tconst array = new Float32Array( uvs[ i ] );\n\t\t\tconst attribute = new BufferAttribute( array, 3 );\n\t\t\tinfo.meshInfo.set( mesh, { attribute } );\n\n\t\t} );\n\n\t\tif ( target !== null ) {\n\n\t\t\tawait processQueue\n\t\t\t\t.add( { tile, overlay }, async () => {\n\n\t\t\t\t\tinfo.meshRangeMarked = true;\n\n\t\t\t\t\tconst promise = markOverlayImages( range, info.level, overlay, false );\n\t\t\t\t\tif ( promise ) {\n\n\t\t\t\t\t\t// if the previous layer is present then draw it as an overlay to fill in any gaps while we wait for\n\t\t\t\t\t\t// the next set of textures\n\t\t\t\t\t\ttileComposer.setRenderTarget( target, normalizedRange );\n\t\t\t\t\t\ttileComposer.clear( 0xffffff, 0 );\n\n\t\t\t\t\t\tforEachTileInBounds( range, info.level - 1, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\t\t\t\t\t// draw using normalized bounds since the mercator bounds are non-linear\n\t\t\t\t\t\t\tconst span = tiling.getTileBounds( tx, ty, tl, true, false );\n\t\t\t\t\t\t\tconst tex = imageSource.get( tx, ty, tl );\n\t\t\t\t\t\t\tif ( tex && ! ( tex instanceof Promise ) ) {\n\n\t\t\t\t\t\t\t\ttileComposer.draw( tex, span );\n\t\t\t\t\t\t\t\tusedTextures.add( tex );\n\t\t\t\t\t\t\t\tthis._scheduleCleanup();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tawait promise;\n\n\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t// skip errors since this will throw when aborted\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if the overlay has been disposed since starting this function\n\t\t\t\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// draw the textures\n\t\t\t\t\ttileComposer.setRenderTarget( target, normalizedRange );\n\t\t\t\t\ttileComposer.clear( 0xffffff, 0 );\n\n\t\t\t\t\tforEachTileInBounds( range, info.level, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\t\t\t\t// draw using normalized bounds since the mercator bounds are non-linear\n\t\t\t\t\t\tconst span = tiling.getTileBounds( tx, ty, tl, true, false );\n\t\t\t\t\t\tconst tex = imageSource.get( tx, ty, tl );\n\t\t\t\t\t\ttileComposer.draw( tex, span );\n\t\t\t\t\t\tusedTextures.add( tex );\n\t\t\t\t\t\tthis._scheduleCleanup();\n\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.catch( () => {\n\n\t\t\t\t\t// the queue throws an error if a task is removed early\n\n\t\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t_updateLayers( tile ) {\n\n\t\tconst { overlayInfo, overlays, tileControllers } = this;\n\t\tconst tileController = tileControllers.get( tile );\n\n\t\t// by this point all targets should be present and we can force the memory to update\n\t\tthis.tiles.recalculateBytesUsed( tile );\n\n\t\t// if the tile has been disposed before this function is called then exit early\n\t\tif ( ! tileController || tileController.signal.aborted ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// update the uvs and texture overlays for each mesh\n\t\toverlays.forEach( ( overlay, i ) => {\n\n\t\t\tconst { tileInfo } = overlayInfo.get( overlay );\n\t\t\tconst { meshInfo, target } = tileInfo.get( tile );\n\t\t\tmeshInfo.forEach( ( { attribute }, mesh ) => {\n\n\t\t\t\tconst { geometry, material } = mesh;\n\t\t\t\tconst params = this.meshParams.get( mesh );\n\n\t\t\t\t// assign the new uvs\n\t\t\t\tconst key = `layer_uv_${ i }`;\n\t\t\t\tif ( geometry.getAttribute( key ) !== attribute ) {\n\n\t\t\t\t\tgeometry.setAttribute( key, attribute );\n\t\t\t\t\tgeometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t\t// set the uniform array lengths\n\t\t\t\tparams.layerMaps.length = overlays.length;\n\t\t\t\tparams.layerColor.length = overlays.length;\n\n\t\t\t\t// assign the uniforms\n\t\t\t\tparams.layerMaps.value[ i ] = target !== null ? target.texture : null;\n\t\t\t\tparams.layerColor.value[ i ] = overlay;\n\n\t\t\t\tmaterial.defines.LAYER_COUNT = overlays.length;\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t_scheduleCleanup() {\n\n\t\t// clean up textures used for drawing the tile overlays\n\t\tif ( ! this._cleanupScheduled ) {\n\n\t\t\tthis._cleanupScheduled = true;\n\t\t\trequestAnimationFrame( () => {\n\n\t\t\t\tconst { usedTextures } = this;\n\t\t\t\tusedTextures.forEach( tex => {\n\n\t\t\t\t\ttex.dispose();\n\n\t\t\t\t} );\n\n\t\t\t\tusedTextures.clear();\n\t\t\t\tthis._cleanupScheduled = false;\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t_markNeedsUpdate() {\n\n\t\tif ( this.needsUpdate === false ) {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tif ( this.tiles !== null ) {\n\n\t\t\t\tthis.tiles.dispatchEvent( { type: 'needs-update' } );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nclass ImageOverlay {\n\n\tget tiling() {\n\n\t\treturn this.imageSource.tiling;\n\n\t}\n\n\tget projection() {\n\n\t\treturn this.tiling.projection;\n\n\t}\n\n\tget isPlanarProjection() {\n\n\t\treturn Boolean( this.frame );\n\n\t}\n\n\tget aspectRatio() {\n\n\t\treturn this.tiling && this.isReady ? this.tiling.aspectRatio : 1;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\topacity = 1,\n\t\t\tcolor = 0xffffff,\n\t\t\tframe = null,\n\t\t} = options;\n\t\tthis.imageSource = null;\n\t\tthis.opacity = opacity;\n\t\tthis.color = new Color( color );\n\t\tthis.frame = frame !== null ? frame.clone() : null;\n\t\tthis.isReady = false;\n\t\tthis.isInitialized = false;\n\n\t}\n\n\tinit() {\n\n\t\tthis.isInitialized = true;\n\t\tthis.whenReady().then( () => {\n\n\t\t\tthis.isReady = true;\n\n\t\t} );\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\treturn fetch( ...args );\n\n\t}\n\n\twhenReady() {\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.imageSource.dispose();\n\n\t}\n\n}\n\nexport class XYZTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new XYZImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class WMTSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new WMTSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class TMSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new TMSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis.url = options.url;\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class CesiumIonOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\n\t\tconst { apiToken, autoRefreshToken, assetId } = options;\n\t\tthis.assetId = assetId;\n\t\tthis.auth = new CesiumIonAuth( { apiToken, autoRefreshToken } );\n\t\tthis.imageSource = new TMSImageSource( options );\n\n\t\tthis.auth.authURL = `https://api.cesium.com/v1/assets/${ assetId }/endpoint`;\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis._attributions = [];\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( json => {\n\n\t\t\t\tthis._attributions = json.attributions.map( att => ( {\n\t\t\t\t\tvalue: att.html,\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\tcollapsible: att.collapsible,\n\t\t\t\t} ) );\n\n\t\t\t\tthis.imageSource.url = json.url;\n\t\t\t\treturn this.imageSource.init();\n\n\t\t\t} );\n\n\t\tsuper.init();\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\treturn this.auth.fetch( ...args );\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\ttarget.push( ...this._attributions );\n\n\t}\n\n}\n\nexport class GoogleMapsOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\n\t\tconst { apiToken, sessionOptions, autoRefreshToken, logoUrl } = options;\n\t\tthis.logoUrl = logoUrl;\n\t\tthis.auth = new GoogleCloudAuth( { apiToken, sessionOptions, autoRefreshToken } );\n\t\tthis.imageSource = new XYZImageSource();\n\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis._logoAttribution = {\n\t\t\tvalue: '',\n\t\t\ttype: 'image',\n\t\t\tcollapsible: false,\n\t\t};\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( json => {\n\n\t\t\t\tthis.imageSource.tileDimension = json.tileWidth;\n\t\t\t\tthis.imageSource = 'https://tile.googleapis.com/v1/2dtiles/{z}/{x}/{y}';\n\t\t\t\treturn this.imageSource.init();\n\n\t\t\t} );\n\n\t\tsuper.init();\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\treturn this.auth.fetch( ...args );\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.logoUrl ) {\n\n\t\t\tthis._logoAttribution.value = this.logoUrl;\n\t\t\ttarget.push( this._logoAttribution );\n\n\t\t}\n\n\t}\n\n}\n"],"names":["_camera","OrthographicCamera","_color","Color","TiledTextureComposer","renderer","Mesh","PlaneGeometry","ComposeTextureMaterial","renderTarget","range","texture","span","quad","material","MathUtils","currentRenderTarget","currentAutoClear","color","alpha","currentClearColor","currentClearAlpha","ShaderMaterial","v","DoubleSide","Vector2","forEachTileInBounds","level","tiling","normalized","callback","minLon","minLat","maxLon","maxLat","clampedLevel","minX","minY","maxX","maxY","x","y","getGeometryCartographicChannel","geometry","geomToEllipsoidMatrix","ellipsoid","_vec","Vector3","_cart","uv","posAttr","centerLat","centerLon","minHeight","maxHeight","i","region","getMeshesCartographicRange","meshes","meshToEllipsoidMatrix","uvs","_matrix","Matrix4","mesh","clampedRange","minU","minV","maxU","maxV","l","lon","lat","h","u","getGeometryPlanarChannel","meshToFrame","aspectRatio","minW","maxW","getMeshesPlanarRange","worldToFrame","heightRange","OVERLAY_PARAMS","wrapOverlaysMaterial","previousOnBeforeCompile","params","shader","value","_center","_sphereCenter","_normal","_box","Box3","SPLIT_TILE_DATA","SPLIT_HASH","markOverlayImages","overlay","doRelease","promises","o","p","markImages","imageSource","tx","ty","tl","filteredPromises","countTilesInRange","total","ImageOverlayPlugin","options","overlays","resolution","enableTileSplitting","tiles","tileComposer","processQueue","PriorityQueue","a","b","tileA","tileB","visibleA","visibleB","scene","tile","overlayChanged","info","order","maxJobs","count","overlayInfo","tileControllers","pendingTiles","tileInfo","meshInfo","meshRange","target","meshRangeMarked","rangeMarked","item","bytesUsed","bytes","safeTextureGetByteLength","initialization","buffer","extension","uri","fullDispose","id","parents","parent","clone","hash","children","collectChildren","child","root","centerTarget","box","splitDirections","hashTokens","token","other","ortho0","ortho1","directions","average","dir","dotProduct","clipper","GeometryClipper","key","splitDirection","i0","i1","i2","barycoord","matrixWorld","Triangle","result","c","canvas","ctx","tex","CanvasTexture","boundingVolume","maxSqRadius","position","sqRadius","controller","forceDispose","index","normalizedRange","w","maxLevel","wProj","hProj","pixelWidth","pixelHeight","args","initTile","promise","usedTextures","tileController","heightInRange","WebGLRenderTarget","SRGBColorSpace","array","attribute","BufferAttribute","ImageOverlay","opacity","frame","XYZTilesOverlay","XYZImageSource","CesiumIonOverlay","apiToken","autoRefreshToken","assetId","CesiumIonAuth","TMSImageSource","json","att"],"mappings":"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"}