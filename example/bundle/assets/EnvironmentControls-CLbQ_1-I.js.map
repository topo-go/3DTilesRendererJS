{"version":3,"file":"EnvironmentControls-CLbQ_1-I.js","sources":["../../../src/three/renderer/controls/PivotPointMesh.js","../../../src/three/renderer/controls/PointerTracker.js","../../../src/three/renderer/controls/utils.js","../../../src/three/renderer/controls/EnvironmentControls.js"],"sourcesContent":["import { Mesh, PlaneGeometry, ShaderMaterial, Vector2 } from 'three';\nexport class PivotPointMesh extends Mesh {\n\n\tconstructor() {\n\n\t\tsuper( new PlaneGeometry( 0, 0 ), new PivotMaterial() );\n\t\tthis.renderOrder = Infinity;\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\tconst uniforms = this.material.uniforms;\n\t\trenderer.getSize( uniforms.resolution.value );\n\n\t}\n\n\tupdateMatrixWorld() {\n\n\t\tthis.matrixWorld.makeTranslation( this.position );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PivotMaterial extends ShaderMaterial {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: true,\n\n\t\t\tuniforms: {\n\n\t\t\t\tresolution: { value: new Vector2() },\n\t\t\t\tsize: { value: 15 },\n\t\t\t\tthickness: { value: 2 },\n\t\t\t\topacity: { value: 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tuniform float pixelRatio;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\t\t\t\t\tvec2 offset = uv * 2.0 - vec2( 1.0 );\n\t\t\t\t\toffset.y *= aspect;\n\n\t\t\t\t\tvec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tscreenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;\n\n\t\t\t\t\tgl_Position = screenPoint;\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat ht = 0.5 * thickness;\n\t\t\t\t\tfloat planeDim = size + thickness;\n\t\t\t\t\tfloat offset = ( planeDim - ht - 2.0 ) / planeDim;\n\t\t\t\t\tfloat texelThickness = ht / planeDim;\n\n\t\t\t\t\tvec2 vec = vUv * 2.0 - vec2( 1.0 );\n\t\t\t\t\tfloat dist = abs( length( vec ) - offset );\n\t\t\t\t\tfloat fw = fwidth( dist ) * 0.5;\n\t\t\t\t\tfloat a = smoothstep( texelThickness - fw, texelThickness + fw, dist );\n\n\t\t\t\t\tgl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n","import { Vector2 } from 'three';\n\nconst _vec = new Vector2();\nconst _vec2 = new Vector2();\nexport class PointerTracker {\n\n\tconstructor() {\n\n\t\tthis.domElement = null;\n\t\tthis.buttons = 0;\n\t\tthis.pointerType = null;\n\t\tthis.pointerOrder = [];\n\t\tthis.previousPositions = {};\n\t\tthis.pointerPositions = {};\n\t\tthis.startPositions = {};\n\t\tthis.pointerSetThisFrame = {};\n\t\tthis.hoverPosition = new Vector2();\n\t\tthis.hoverSet = false;\n\n\t}\n\n\treset() {\n\n\t\tthis.buttons = 0;\n\t\tthis.pointerType = null;\n\t\tthis.pointerOrder = [];\n\t\tthis.previousPositions = {};\n\t\tthis.pointerPositions = {};\n\t\tthis.startPositions = {};\n\t\tthis.pointerSetThisFrame = {};\n\t\tthis.hoverPosition = new Vector2();\n\t\tthis.hoverSet = false;\n\n\t}\n\n\t// The pointers can be set multiple times per frame so track whether the pointer has\n\t// been set this frame or not so we don't overwrite the previous position and lose information\n\t// about pointer movement\n\tupdateFrame() {\n\n\t\tconst { previousPositions, pointerPositions } = this;\n\t\tfor ( const id in pointerPositions ) {\n\n\t\t\tpreviousPositions[ id ].copy( pointerPositions[ id ] );\n\n\t\t}\n\n\t}\n\n\tsetHoverEvent( e ) {\n\n\t\tif ( e.pointerType === 'mouse' || e.type === 'wheel' ) {\n\n\t\t\tthis.getAdjustedPointer( e, this.hoverPosition );\n\t\t\tthis.hoverSet = true;\n\n\t\t}\n\n\t}\n\n\tgetLatestPoint( target ) {\n\n\t\tif ( this.pointerType !== null ) {\n\n\t\t\tthis.getCenterPoint( target );\n\t\t\treturn target;\n\n\t\t} else if ( this.hoverSet ) {\n\n\t\t\ttarget.copy( this.hoverPosition );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// get the pointer position in the coordinate system of the target element\n\tgetAdjustedPointer( e, target ) {\n\n\t\tconst domRef = this.domElement ? this.domElement : e.target;\n\t\tconst rect = domRef.getBoundingClientRect();\n\t\tconst x = e.clientX - rect.left;\n\t\tconst y = e.clientY - rect.top;\n\t\ttarget.set( x, y );\n\n\t}\n\n\taddPointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tconst position = new Vector2();\n\t\tthis.getAdjustedPointer( e, position );\n\t\tthis.pointerOrder.push( id );\n\t\tthis.pointerPositions[ id ] = position;\n\t\tthis.previousPositions[ id ] = position.clone();\n\t\tthis.startPositions[ id ] = position.clone();\n\n\t\tif ( this.getPointerCount() === 1 ) {\n\n\t\t\tthis.pointerType = e.pointerType;\n\t\t\tthis.buttons = e.buttons;\n\n\t\t}\n\n\t}\n\n\tupdatePointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tif ( ! ( id in this.pointerPositions ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tthis.getAdjustedPointer( e, this.pointerPositions[ id ] );\n\t\treturn true;\n\n\t}\n\n\tdeletePointer( e ) {\n\n\t\tconst id = e.pointerId;\n\t\tconst pointerOrder = this.pointerOrder;\n\t\tpointerOrder.splice( pointerOrder.indexOf( id ), 1 );\n\t\tdelete this.pointerPositions[ id ];\n\t\tdelete this.previousPositions[ id ];\n\t\tdelete this.startPositions[ id ];\n\n\t\tif ( this.getPointerCount.length === 0 ) {\n\n\t\t\tthis.buttons = 0;\n\t\t\tthis.pointerType = null;\n\n\t\t}\n\n\t}\n\n\tgetPointerCount() {\n\n\t\treturn this.pointerOrder.length;\n\n\t}\n\n\tgetCenterPoint( target, pointerPositions = this.pointerPositions ) {\n\n\t\tconst pointerOrder = this.pointerOrder;\n\t\tif ( this.getPointerCount() === 1 || this.getPointerType() === 'mouse' ) {\n\n\t\t\tconst id = pointerOrder[ 0 ];\n\t\t\ttarget.copy( pointerPositions[ id ] );\n\t\t\treturn target;\n\n\t\t} else if ( this.getPointerCount() === 2 ) {\n\n\t\t\tconst id0 = this.pointerOrder[ 0 ];\n\t\t\tconst id1 = this.pointerOrder[ 1 ];\n\n\t\t\tconst p0 = pointerPositions[ id0 ];\n\t\t\tconst p1 = pointerPositions[ id1 ];\n\n\t\t\ttarget.addVectors( p0, p1 ).multiplyScalar( 0.5 );\n\t\t\treturn target;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetPreviousCenterPoint( target ) {\n\n\t\treturn this.getCenterPoint( target, this.previousPositions );\n\n\t}\n\n\tgetStartCenterPoint( target ) {\n\n\t\treturn this.getCenterPoint( target, this.startPositions );\n\n\t}\n\n\tgetMoveDistance() {\n\n\t\tthis.getCenterPoint( _vec );\n\t\tthis.getPreviousCenterPoint( _vec2 );\n\n\t\treturn _vec.sub( _vec2 ).length();\n\n\t}\n\n\tgetTouchPointerDistance( pointerPositions = this.pointerPositions ) {\n\n\t\tif ( this.getPointerCount() <= 1 || this.getPointerType() === 'mouse' ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst { pointerOrder } = this;\n\t\tconst id0 = pointerOrder[ 0 ];\n\t\tconst id1 = pointerOrder[ 1 ];\n\n\t\tconst p0 = pointerPositions[ id0 ];\n\t\tconst p1 = pointerPositions[ id1 ];\n\n\t\treturn p0.distanceTo( p1 );\n\n\t}\n\n\tgetPreviousTouchPointerDistance() {\n\n\t\treturn this.getTouchPointerDistance( this.previousPositions );\n\n\t}\n\n\tgetStartTouchPointerDistance() {\n\n\t\treturn this.getTouchPointerDistance( this.startPositions );\n\n\t}\n\n\tgetPointerType() {\n\n\t\treturn this.pointerType;\n\n\t}\n\n\tisPointerTouch() {\n\n\t\treturn this.getPointerType() === 'touch';\n\n\t}\n\n\tgetPointerButtons() {\n\n\t\treturn this.buttons;\n\n\t}\n\n\tisLeftClicked() {\n\n\t\treturn Boolean( this.buttons & 1 );\n\n\t}\n\n\tisRightClicked() {\n\n\t\treturn Boolean( this.buttons & 2 );\n\n\t}\n\n}\n","import { Matrix4, Ray, Vector3 } from 'three';\n\nconst _matrix = new Matrix4();\nconst _ray = new Ray();\nconst _vec = new Vector3();\n\n// helper function for constructing a matrix for rotating around a point\nexport function makeRotateAroundPoint( point, quat, target ) {\n\n\ttarget.makeTranslation( - point.x, - point.y, - point.z );\n\n\t_matrix.makeRotationFromQuaternion( quat );\n\ttarget.premultiply( _matrix );\n\n\t_matrix.makeTranslation( point.x, point.y, point.z );\n\ttarget.premultiply( _matrix );\n\n\treturn target;\n\n}\n\n// get the three.js pointer coords from an event\nexport function mouseToCoords( clientX, clientY, element, target ) {\n\n\ttarget.x = ( ( clientX - element.offsetLeft ) / element.clientWidth ) * 2 - 1;\n\ttarget.y = - ( ( clientY - element.offsetTop ) / element.clientHeight ) * 2 + 1;\n\n\tif ( target.isVector3 ) {\n\n\t\ttarget.z = 0;\n\n\t}\n\n}\n\n// Returns an estimate of the closest point on the ellipsoid to the ray. Returns\n// the surface intersection if they collide.\nexport function closestRayEllipsoidSurfacePointEstimate( ray, ellipsoid, target ) {\n\n\tif ( ellipsoid.intersectRay( ray, target ) ) {\n\n\t\treturn target;\n\n\t} else {\n\n\t\t_matrix.makeScale( ...ellipsoid.radius ).invert();\n\t\t_ray.copy( ray ).applyMatrix4( _matrix );\n\n\t\t_vec.set( 0, 0, 0 );\n\t\t_ray.closestPointToPoint( _vec, target ).normalize();\n\n\t\t_matrix.makeScale( ...ellipsoid.radius );\n\t\treturn target.applyMatrix4( _matrix );\n\n\t}\n\n}\n\n// find the closest ray on the horizon when the ray passes above the sphere\nexport function closestRaySpherePointFromRotation( ray, radius, target ) {\n\n\tconst hypotenuse = ray.origin.length();\n\n\t// angle inside the sphere\n\tconst theta = Math.acos( radius / hypotenuse );\n\n\t// the direction to the camera\n\ttarget\n\t\t.copy( ray.origin )\n\t\t.multiplyScalar( - 1 )\n\t\t.normalize();\n\n\t// get the normal of the plane the ray and origin lie in\n\tconst rotationVec = _vec\n\t\t.crossVectors( target, ray.direction )\n\t\t.normalize();\n\n\t// rotate the camera direction by angle and scale it to the surface\n\ttarget\n\t\t.multiplyScalar( - 1 )\n\t\t.applyAxisAngle( rotationVec, - theta )\n\t\t.normalize()\n\t\t.multiplyScalar( radius );\n\n}\n\n\n// custom version of set raycaster from camera that relies on the underlying matrices\n// so the ray origin is position at the camera near clip.\nexport function setRaycasterFromCamera( raycaster, coords, camera ) {\n\n\tconst ray = raycaster instanceof Ray ? raycaster : raycaster.ray;\n\tconst { origin, direction } = ray;\n\n\t// get the origin and direction of the frustum ray\n\torigin\n\t\t.set( coords.x, coords.y, - 1 )\n\t\t.unproject( camera );\n\n\tdirection\n\t\t.set( coords.x, coords.y, 1 )\n\t\t.unproject( camera )\n\t\t.sub( origin );\n\n\tif ( ! raycaster.isRay ) {\n\n\t\t// compute the far value based on the distance from point on the near\n\t\t// plane and point on the far plane. Then normalize the direction.\n\t\traycaster.near = 0;\n\t\traycaster.far = direction.length();\n\t\traycaster.camera = camera;\n\n\t}\n\n\t// normalize the ray direction\n\tdirection.normalize();\n\n}\n","import {\n\tMatrix4,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tRaycaster,\n\tPlane,\n\tEventDispatcher,\n\tMathUtils,\n\tClock,\n\tRay,\n} from 'three';\nimport { PivotPointMesh } from './PivotPointMesh.js';\nimport { PointerTracker } from './PointerTracker.js';\nimport { mouseToCoords, makeRotateAroundPoint, setRaycasterFromCamera } from './utils.js';\n\nexport const NONE = 0;\nexport const DRAG = 1;\nexport const ROTATE = 2;\nexport const ZOOM = 3;\nexport const WAITING = 4;\n\nconst DRAG_PLANE_THRESHOLD = 0.05;\nconst DRAG_UP_THRESHOLD = 0.025;\n\nconst _rotMatrix = /* @__PURE__ */ new Matrix4();\nconst _invMatrix = /* @__PURE__ */ new Matrix4();\nconst _delta = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _forward = /* @__PURE__ */ new Vector3();\nconst _right = /* @__PURE__ */ new Vector3();\nconst _targetRight = /* @__PURE__ */ new Vector3();\nconst _rotationAxis = /* @__PURE__ */ new Vector3();\nconst _quaternion = /* @__PURE__ */ new Quaternion();\nconst _plane = /* @__PURE__ */ new Plane();\nconst _localUp = /* @__PURE__ */ new Vector3();\nconst _mouseBefore = /* @__PURE__ */ new Vector3();\nconst _mouseAfter = /* @__PURE__ */ new Vector3();\nconst _identityQuat = /* @__PURE__ */ new Quaternion();\nconst _ray = /* @__PURE__ */ new Ray();\n\nconst _zoomPointPointer = /* @__PURE__ */ new Vector2();\nconst _pointer = /* @__PURE__ */ new Vector2();\nconst _prevPointer = /* @__PURE__ */ new Vector2();\nconst _deltaPointer = /* @__PURE__ */ new Vector2();\nconst _centerPoint = /* @__PURE__ */ new Vector2();\nconst _startCenterPoint = /* @__PURE__ */ new Vector2();\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nexport class EnvironmentControls extends EventDispatcher {\n\n\tget enabled() {\n\n\t\treturn this._enabled;\n\n\t}\n\n\tset enabled( v ) {\n\n\t\tif ( v !== this.enabled ) {\n\n\t\t\tthis._enabled = v;\n\t\t\tthis.resetState();\n\t\t\tthis.pointerTracker.reset();\n\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\t\t\tthis.rotationInertia.set( 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconstructor( scene = null, camera = null, domElement = null, tilesRenderer = null ) {\n\n\t\tsuper();\n\n\t\tthis.isEnvironmentControls = true;\n\n\t\tthis.domElement = null;\n\t\tthis.camera = null;\n\t\tthis.scene = null;\n\t\tthis.tilesRenderer = null;\n\n\t\t// settings\n\t\tthis._enabled = true;\n\t\tthis.cameraRadius = 5;\n\t\tthis.rotationSpeed = 1;\n\t\tthis.minAltitude = 0;\n\t\tthis.maxAltitude = 0.45 * Math.PI;\n\t\tthis.minDistance = 10;\n\t\tthis.maxDistance = Infinity;\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\t\tthis.zoomSpeed = 1;\n\t\tthis.adjustHeight = true;\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.15;\n\n\t\tthis.fallbackPlane = new Plane( new Vector3( 0, 1, 0 ), 0 );\n\t\tthis.useFallbackPlane = true;\n\n\t\t// settings for GlobeControls\n\t\tthis.scaleZoomOrientationAtEdges = false;\n\t\tthis.autoAdjustCameraRotation = true;\n\n\t\t// internal state\n\t\tthis.state = NONE;\n\t\tthis.pointerTracker = new PointerTracker();\n\t\tthis.needsUpdate = false;\n\t\tthis.actionHeightOffset = 0;\n\n\t\tthis.pivotPoint = new Vector3();\n\n\t\t// used for zoom\n\t\tthis.zoomDirectionSet = false;\n\t\tthis.zoomPointSet = false;\n\t\tthis.zoomDirection = new Vector3();\n\t\tthis.zoomPoint = new Vector3();\n\t\tthis.zoomDelta = 0;\n\n\t\t// fields used for inertia\n\t\tthis.rotationInertiaPivot = new Vector3();\n\t\tthis.rotationInertia = new Vector2();\n\t\tthis.dragInertia = new Vector3();\n\t\tthis.inertiaTargetDistance = Infinity; \t\t// track the distance from the camera that we want to use to calculate the inertia end threshold\n\t\tthis.inertiaStableFrames = 0; \t\t\t\t// the number of frames that the camera has not moved while the user is interacting\n\n\t\t// circular pivot mesh\n\t\tthis.pivotMesh = new PivotPointMesh();\n\t\tthis.pivotMesh.raycast = () => {};\n\t\tthis.pivotMesh.scale.setScalar( 0.25 );\n\n\t\t// raycaster\n\t\tthis.raycaster = new Raycaster();\n\t\tthis.raycaster.firstHitOnly = true;\n\n\t\tthis.up = new Vector3( 0, 1, 0 );\n\t\tthis.clock = new Clock();\n\n\t\tthis._detachCallback = null;\n\t\tthis._upInitialized = false;\n\t\tthis._lastUsedState = NONE;\n\t\tthis._zoomPointWasSet = false;\n\n\t\t// always update the zoom target point in case the tiles are changing\n\t\tthis._tilesOnChangeCallback = () => this.zoomPointSet = false;\n\n\t\t// init\n\t\tif ( domElement ) this.attach( domElement );\n\t\tif ( camera ) this.setCamera( camera );\n\t\tif ( scene ) this.setScene( scene );\n\t\tif ( tilesRenderer ) this.setTilesRenderer( tilesRenderer );\n\n\t}\n\n\tsetScene( scene ) {\n\n\t\tthis.scene = scene;\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tthis.camera = camera;\n\t\tthis._upInitialized = false;\n\t\tthis.zoomDirectionSet = false;\n\t\tthis.zoomPointSet = false;\n\t\tthis.needsUpdate = true;\n\t\tthis.raycaster.camera = camera;\n\t\tthis.resetState();\n\n\t}\n\n\tsetTilesRenderer( tilesRenderer ) {\n\n\t\tconsole.warn( 'EnvironmentControls: \"setTilesRenderer\" has been deprecated. Use \"setScene\" and \"setEllipsoid\", instead.' );\n\n\t\tthis.tilesRenderer = tilesRenderer;\n\t\tif ( this.tilesRenderer !== null ) {\n\n\t\t\tthis.setScene( this.tilesRenderer.group );\n\n\t\t}\n\n\t}\n\n\tattach( domElement ) {\n\n\t\tif ( this.domElement ) {\n\n\t\t\tthrow new Error( 'EnvironmentControls: Controls already attached to element' );\n\n\t\t}\n\n\t\t// set the touch action to none so the browser does not\n\t\t// drag the page to refresh or scroll\n\t\tthis.domElement = domElement;\n\t\tthis.pointerTracker.domElement = domElement;\n\t\tdomElement.style.touchAction = 'none';\n\n\t\tconst contextMenuCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t};\n\n\t\tconst pointerdownCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst {\n\t\t\t\tcamera,\n\t\t\t\traycaster,\n\t\t\t\tdomElement,\n\t\t\t\tup,\n\t\t\t\tpivotMesh,\n\t\t\t\tpointerTracker,\n\t\t\t\tscene,\n\t\t\t\tpivotPoint,\n\t\t\t\tenabled,\n\t\t\t} = this;\n\n\t\t\t// init the pointer\n\t\t\tpointerTracker.addPointer( e );\n\t\t\tthis.needsUpdate = true;\n\n\t\t\t// handle cases where we need to capture the pointer or\n\t\t\t// reset state when we have too many pointers\n\t\t\tif ( pointerTracker.isPointerTouch() ) {\n\n\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t\tif ( pointerTracker.getPointerCount() === 0 ) {\n\n\t\t\t\t\t// TODO: is it correct to only capture a single pointer? Or do we need to do it for\n\t\t\t\t\t// every unique pointer id?\n\t\t\t\t\tdomElement.setPointerCapture( e.pointerId );\n\n\t\t\t\t} else if ( pointerTracker.getPointerCount() > 2 ) {\n\n\t\t\t\t\tthis.resetState();\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// the \"pointer\" for zooming and rotating should be based on the center point\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _pointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// prevent the drag distance from getting too severe by limiting the drag point\n\t\t\t// to a reasonable angle and reasonable distance with the drag plane\n\t\t\tconst dot = Math.abs( raycaster.ray.direction.dot( up ) );\n\t\t\tif ( dot < DRAG_PLANE_THRESHOLD || dot < DRAG_UP_THRESHOLD ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// find the hit point\n\t\t\tconst hit = this._raycast( raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\t// if two fingers, right click, or shift click are being used then we trigger\n\t\t\t\t// a rotation action to begin\n\t\t\t\tif (\n\t\t\t\t\tpointerTracker.getPointerCount() === 2 ||\n\t\t\t\t\tpointerTracker.isRightClicked() ||\n\t\t\t\t\tpointerTracker.isLeftClicked() && e.shiftKey\n\t\t\t\t) {\n\n\t\t\t\t\tthis.setState( pointerTracker.isPointerTouch() ? WAITING : ROTATE );\n\n\t\t\t\t\tpivotPoint.copy( hit.point );\n\t\t\t\t\tpivotMesh.position.copy( hit.point );\n\t\t\t\t\tpivotMesh.visible = pointerTracker.isPointerTouch() ? false : enabled;\n\t\t\t\t\tpivotMesh.updateMatrixWorld();\n\t\t\t\t\tscene.add( pivotMesh );\n\n\t\t\t\t} else if ( pointerTracker.isLeftClicked() ) {\n\n\t\t\t\t\t// if the clicked point is coming from below the plane then don't perform the drag\n\t\t\t\t\tthis.setState( DRAG );\n\t\t\t\t\tpivotPoint.copy( hit.point );\n\n\t\t\t\t\tpivotMesh.position.copy( hit.point );\n\t\t\t\t\tpivotMesh.updateMatrixWorld();\n\t\t\t\t\tscene.add( pivotMesh );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tlet _pointerMoveQueued = false;\n\t\tconst pointermoveCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tconst { pointerTracker } = this;\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst {\n\t\t\t\tpivotMesh,\n\t\t\t\tenabled,\n\t\t\t} = this;\n\n\t\t\t// whenever the pointer moves we need to re-derive the zoom direction and point\n\t\t\tthis.zoomDirectionSet = false;\n\t\t\tthis.zoomPointSet = false;\n\n\t\t\tif ( this.state !== NONE ) {\n\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tpointerTracker.setHoverEvent( e );\n\t\t\tif ( ! pointerTracker.updatePointer( e ) ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( pointerTracker.isPointerTouch() && pointerTracker.getPointerCount() === 2 ) {\n\n\t\t\t\t// We queue this event to ensure that all pointers have been updated\n\t\t\t\tif ( ! _pointerMoveQueued ) {\n\n\t\t\t\t\t_pointerMoveQueued = true;\n\t\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\t\t_pointerMoveQueued = false;\n\n\t\t\t\t\t\t// adjust the pointer position to be the center point\n\t\t\t\t\t\tpointerTracker.getCenterPoint( _centerPoint );\n\n\t\t\t\t\t\t// detect zoom transition\n\t\t\t\t\t\tconst startDist = pointerTracker.getStartTouchPointerDistance();\n\t\t\t\t\t\tconst pointerDist = pointerTracker.getTouchPointerDistance();\n\t\t\t\t\t\tconst separateDelta = pointerDist - startDist;\n\t\t\t\t\t\tif ( this.state === NONE || this.state === WAITING ) {\n\n\t\t\t\t\t\t\t// check which direction was moved in first - if the pointers are pinching then\n\t\t\t\t\t\t\t// it's a zoom. But if they move in parallel it's a rotation\n\t\t\t\t\t\t\tpointerTracker.getCenterPoint( _centerPoint );\n\t\t\t\t\t\t\tpointerTracker.getStartCenterPoint( _startCenterPoint );\n\n\t\t\t\t\t\t\t// adjust the drag requirement by the dpr\n\t\t\t\t\t\t\tconst dragThreshold = 2.0 * window.devicePixelRatio;\n\t\t\t\t\t\t\tconst parallelDelta = _centerPoint.distanceTo( _startCenterPoint );\n\t\t\t\t\t\t\tif ( Math.abs( separateDelta ) > dragThreshold || parallelDelta > dragThreshold ) {\n\n\t\t\t\t\t\t\t\tif ( Math.abs( separateDelta ) > parallelDelta ) {\n\n\t\t\t\t\t\t\t\t\tthis.setState( ZOOM );\n\t\t\t\t\t\t\t\t\tthis.zoomDirectionSet = false;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tthis.setState( ROTATE );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.state === ZOOM ) {\n\n\t\t\t\t\t\t\tconst previousDist = pointerTracker.getPreviousTouchPointerDistance();\n\t\t\t\t\t\t\tthis.zoomDelta += pointerDist - previousDist;\n\t\t\t\t\t\t\tpivotMesh.visible = false;\n\n\t\t\t\t\t\t} else if ( this.state === ROTATE ) {\n\n\t\t\t\t\t\t\tpivotMesh.visible = enabled;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: we have the potential to fire change multiple times per frame - should we debounce?\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t};\n\n\t\tconst pointerupCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tconst { pointerTracker } = this;\n\t\t\tif ( ! this.enabled || pointerTracker.getPointerCount() === 0 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tpointerTracker.deletePointer( e );\n\n\t\t\tif (\n\t\t\t\tpointerTracker.getPointerType() === 'touch' &&\n\t\t\t\tpointerTracker.getPointerCount() === 0\n\t\t\t) {\n\n\t\t\t\tdomElement.releasePointerCapture( e.pointerId );\n\n\t\t\t}\n\n\t\t\tthis.resetState();\n\t\t\tthis.needsUpdate = true;\n\n\t\t};\n\n\t\tconst wheelCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\te.preventDefault();\n\n\t\t\tconst { pointerTracker } = this;\n\t\t\tpointerTracker.setHoverEvent( e );\n\t\t\tpointerTracker.updatePointer( e );\n\n\t\t\t// TODO: do we need events here?\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tlet delta;\n\t\t\tswitch ( e.deltaMode ) {\n\n\t\t\t\tcase 2: // Pages\n\t\t\t\t\tdelta = e.deltaY * 800;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: // Lines\n\t\t\t\t\tdelta = e.deltaY * 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0: // Pixels\n\t\t\t\t\tdelta = e.deltaY;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// use LOG to scale the scroll delta and hopefully normalize them across platforms\n\t\t\tconst deltaSign = Math.sign( delta );\n\t\t\tconst normalizedDelta = Math.abs( delta );\n\t\t\tthis.zoomDelta -= 0.25 * deltaSign * normalizedDelta;\n\t\t\tthis.needsUpdate = true;\n\n\t\t\tthis._lastUsedState = ZOOM;\n\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t};\n\n\t\tconst pointerleaveCallback = e => {\n\n\t\t\t// exit early if the controls are disabled\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.resetState();\n\n\t\t};\n\n\t\tdomElement.addEventListener( 'contextmenu', contextMenuCallback );\n\t\tdomElement.addEventListener( 'pointerdown', pointerdownCallback );\n\t\tdomElement.addEventListener( 'wheel', wheelCallback, { passive: false } );\n\n\t\t// Register movement events on the root element so dragging does not break when dragging over other elements.\n\t\t// Use \"getRootNode\" to enable offscreenCanvas usage.\n\t\t// \"pointerleave\" event fires when leaving the window.\n\t\tconst document = domElement.getRootNode();\n\t\tdocument.addEventListener( 'pointermove', pointermoveCallback );\n\t\tdocument.addEventListener( 'pointerup', pointerupCallback );\n\t\tdocument.addEventListener( 'pointerleave', pointerleaveCallback );\n\n\t\tthis._detachCallback = () => {\n\n\t\t\tdomElement.removeEventListener( 'contextmenu', contextMenuCallback );\n\t\t\tdomElement.removeEventListener( 'pointerdown', pointerdownCallback );\n\t\t\tdomElement.removeEventListener( 'wheel', wheelCallback );\n\n\t\t\tdocument.removeEventListener( 'pointermove', pointermoveCallback );\n\t\t\tdocument.removeEventListener( 'pointerup', pointerupCallback );\n\t\t\tdocument.removeEventListener( 'pointerleave', pointerleaveCallback );\n\n\t\t};\n\n\t}\n\n\tdetach() {\n\n\t\tthis.domElement = null;\n\n\t\tif ( this._detachCallback ) {\n\n\t\t\tthis._detachCallback();\n\t\t\tthis._detachCallback = null;\n\t\t\tthis.pointerTracker.reset();\n\n\t\t}\n\n\t}\n\n\t// override-able functions for retrieving the up direction at a point\n\tgetUpDirection( point, target ) {\n\n\t\ttarget.copy( this.up );\n\n\t}\n\n\tgetCameraUpDirection( target ) {\n\n\t\tthis.getUpDirection( this.camera.position, target );\n\n\t}\n\n\t// returns the active / last used pivot point for the scene\n\tgetPivotPoint( target ) {\n\n\t\tlet result = null;\n\n\t\t// get the last interacted point as the focus\n\t\tif ( this._lastUsedState === ZOOM ) {\n\n\t\t\tif ( this._zoomPointWasSet ) {\n\n\t\t\t\tresult = target.copy( this.zoomPoint );\n\n\t\t\t}\n\n\t\t} else if ( this._lastUsedState === ROTATE || this._lastUsedState === DRAG ) {\n\n\t\t\tresult = target.copy( this.pivotPoint );\n\n\t\t}\n\n\t\t// If the last used point is outside the camera view then skip it\n\t\tconst { camera, raycaster } = this;\n\t\tif ( result !== null ) {\n\n\t\t\t_vec.copy( result ).project( camera );\n\t\t\tif ( _vec.x < - 1 || _vec.x > 1 || _vec.y < - 1 || _vec.y > 1 ) {\n\n\t\t\t\tresult = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// default to the raycast hit if we have not result or the hit is closer to the camera\n\t\t// set a ray in the local ellipsoid frame\n\t\tsetRaycasterFromCamera( raycaster, { x: 0, y: 0 }, camera );\n\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\tif ( result === null || hit.distance < result.distanceTo( raycaster.ray.origin ) ) {\n\n\t\t\t\tresult = target.copy( hit.point );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tresetState() {\n\n\t\tif ( this.state !== NONE ) {\n\n\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tthis.state = NONE;\n\t\tthis.pivotMesh.removeFromParent();\n\t\tthis.pivotMesh.visible = this.enabled;\n\t\tthis.actionHeightOffset = 0;\n\t\tthis.pointerTracker.reset();\n\n\t}\n\n\tsetState( state = this.state, fireEvent = true ) {\n\n\t\tif ( this.state === state ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.state === NONE && fireEvent ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t}\n\n\t\tthis.pivotMesh.visible = this.enabled;\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.inertiaStableFrames = 0;\n\t\tthis.state = state;\n\n\t\tif ( state !== NONE && state !== WAITING ) {\n\n\t\t\tthis._lastUsedState = state;\n\n\t\t}\n\n\t}\n\n\tupdate( deltaTime = Math.min( this.clock.getDelta(), 64 / 1000 ) ) {\n\n\t\tif ( ! this.enabled || ! this.camera || deltaTime === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tpivotPoint,\n\t\t\tup,\n\t\t\tstate,\n\t\t\tadjustHeight,\n\t\t\tautoAdjustCameraRotation,\n\t\t} = this;\n\n\t\tcamera.updateMatrixWorld();\n\n\t\t// set the \"up\" vector immediately so it's available in the following functions\n\t\tthis.getCameraUpDirection( _localUp );\n\t\tif ( ! this._upInitialized ) {\n\n\t\t\tthis._upInitialized = true;\n\t\t\tthis.up.copy( _localUp );\n\n\t\t}\n\n\t\t// we need to update the zoom point whenever we update in case the scene is animating or changing\n\t\tthis.zoomPointSet = false;\n\n\t\t// update the actions\n\t\tconst inertiaNeedsUpdate = this._inertiaNeedsUpdate();\n\t\tconst adjustCameraRotation = this.needsUpdate || inertiaNeedsUpdate;\n\t\tif ( this.needsUpdate || inertiaNeedsUpdate ) {\n\n\t\t\tconst zoomDelta = this.zoomDelta;\n\n\t\t\tthis._updateZoom();\n\t\t\tthis._updatePosition( deltaTime );\n\t\t\tthis._updateRotation( deltaTime );\n\n\t\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\t\tthis.inertiaTargetDistance = _vec.copy( pivotPoint ).sub( camera.position ).dot( _forward );\n\n\t\t\t} else if ( state === NONE ) {\n\n\t\t\t\tthis._updateInertia( deltaTime );\n\n\t\t\t}\n\n\t\t\tif ( state !== NONE || zoomDelta !== 0 || inertiaNeedsUpdate ) {\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t\t// update the up direction based on where the camera moved to\n\t\t// if using an orthographic camera then rotate around drag pivot\n\t\t// reuse the \"hit\" information since it can be slow to perform multiple hits\n\t\tconst hit = camera.isOrthographicCamera ? null : adjustHeight && this._getPointBelowCamera() || null;\n\t\tthis.getCameraUpDirection( _localUp );\n\t\tthis._setFrame( _localUp );\n\n\t\t// when dragging the camera and drag point may be moved\n\t\t// to accommodate terrain so we try to move it back down\n\t\t// to the original point.\n\t\tif ( ( this.state === DRAG || this.state === ROTATE ) && this.actionHeightOffset !== 0 ) {\n\n\t\t\tconst { actionHeightOffset } = this;\n\t\t\tcamera.position.addScaledVector( up, - actionHeightOffset );\n\t\t\tpivotPoint.addScaledVector( up, - actionHeightOffset );\n\n\t\t\t// adjust the height\n\t\t\tif ( hit ) {\n\n\t\t\t\thit.distance -= actionHeightOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.actionHeightOffset = 0;\n\n\t\tif ( hit ) {\n\n\t\t\tconst dist = hit.distance;\n\t\t\tif ( dist < cameraRadius ) {\n\n\t\t\t\tconst delta = cameraRadius - dist;\n\t\t\t\tcamera.position.addScaledVector( up, delta );\n\t\t\t\tpivotPoint.addScaledVector( up, delta );\n\t\t\t\tthis.actionHeightOffset = delta;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.pointerTracker.updateFrame();\n\n\t\tif ( adjustCameraRotation && autoAdjustCameraRotation ) {\n\n\t\t\tthis.getCameraUpDirection( _localUp );\n\t\t\tthis._alignCameraUp( _localUp, 1 );\n\n\t\t\tthis.getCameraUpDirection( _localUp );\n\t\t\tthis._clampRotation( _localUp );\n\n\n\t\t}\n\n\t}\n\n\t// updates the camera to position it based on the constraints of the controls\n\tadjustCamera( camera ) {\n\n\t\tconst { adjustHeight, cameraRadius } = this;\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t// adjust the camera height\n\t\t\tthis.getUpDirection( camera.position, _localUp );\n\t\t\tconst hit = adjustHeight && this._getPointBelowCamera( camera.position, _localUp ) || null;\n\t\t\tif ( hit ) {\n\n\t\t\t\tconst dist = hit.distance;\n\t\t\t\tif ( dist < cameraRadius ) {\n\n\t\t\t\t\tcamera.position.addScaledVector( _localUp, cameraRadius - dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.detach();\n\n\t}\n\n\t// private\n\t_updateInertia( deltaTime ) {\n\n\t\t// update the damping of momentum variables\n\t\tconst {\n\t\t\trotationInertia,\n\t\t\tpivotPoint,\n\t\t\tdragInertia,\n\t\t\tenableDamping,\n\t\t\tdampingFactor,\n\t\t\tcamera,\n\t\t\tcameraRadius,\n\t\t\tminDistance,\n\t\t\tinertiaTargetDistance,\n\t\t} = this;\n\n\t\tif ( ! this.enableDamping || this.inertiaStableFrames > 1 ) {\n\n\t\t\tdragInertia.set( 0, 0, 0 );\n\t\t\trotationInertia.set( 0, 0, 0 );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Based on Freya Holmer's frame-rate independent lerp function\n\t\tconst factor = Math.pow( 2, - deltaTime / dampingFactor );\n\t\tconst stableDistance = Math.max( camera.near, cameraRadius, minDistance, inertiaTargetDistance );\n\t\tconst resolution = 2 * 1e3;\n\t\tconst pixelWidth = 2 / resolution;\n\t\tconst pixelThreshold = 0.25 * pixelWidth;\n\n\t\t// scale the residual rotation motion\n\t\tif ( rotationInertia.lengthSq() > 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _delta.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _delta );\n\t\t\t_delta.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// get implied angle\n\t\t\t_vec.sub( pivotPoint ).normalize();\n\t\t\t_delta.sub( pivotPoint ).normalize();\n\n\t\t\t// calculate the rotation threshold\n\t\t\tconst threshold = _vec.angleTo( _delta ) / deltaTime;\n\t\t\trotationInertia.multiplyScalar( factor );\n\t\t\tif ( rotationInertia.lengthSq() < threshold ** 2 || ! enableDamping ) {\n\n\t\t\t\trotationInertia.set( 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scale the residual translation motion\n\t\tif ( dragInertia.lengthSq() > 0 ) {\n\n\t\t\t// calculate two screen points at 1 pixel apart in our notional resolution so we can stop when the delta is ~ 1 pixel\n\t\t\t// projected into world space\n\t\t\tsetRaycasterFromCamera( _ray, _vec.set( 0, 0, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _vec );\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\tsetRaycasterFromCamera( _ray, _delta.set( pixelThreshold, pixelThreshold, - 1 ), camera );\n\t\t\t_ray.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t_ray.direction.normalize();\n\t\t\t_ray.recast( - _ray.direction.dot( _ray.origin ) ).at( stableDistance / _ray.direction.z, _delta );\n\t\t\t_delta.applyMatrix4( camera.matrixWorld );\n\n\t\t\t// calculate movement threshold\n\t\t\tconst threshold = _vec.distanceTo( _delta ) / deltaTime;\n\t\t\tdragInertia.multiplyScalar( factor );\n\t\t\tif ( dragInertia.lengthSq() < threshold ** 2 || ! enableDamping ) {\n\n\t\t\t\tdragInertia.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply the inertia changes\n\t\tif ( rotationInertia.lengthSq() > 0 ) {\n\n\t\t\tthis._applyRotation( rotationInertia.x * deltaTime, rotationInertia.y * deltaTime, pivotPoint );\n\n\t\t}\n\n\t\tif ( dragInertia.lengthSq() > 0 ) {\n\n\t\t\tcamera.position.addScaledVector( dragInertia, deltaTime );\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\t_inertiaNeedsUpdate() {\n\n\t\tconst { rotationInertia, dragInertia } = this;\n\t\treturn rotationInertia.lengthSq() !== 0 || dragInertia.lengthSq() !== 0;\n\n\t}\n\n\t_updateZoom() {\n\n\t\tconst {\n\t\t\tzoomPoint,\n\t\t\tzoomDirection,\n\t\t\tcamera,\n\t\t\tminDistance,\n\t\t\tmaxDistance,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tminZoom,\n\t\t\tmaxZoom,\n\t\t\tzoomSpeed,\n\t\t\tstate,\n\t\t} = this;\n\n\t\tlet scale = this.zoomDelta;\n\t\tthis.zoomDelta = 0;\n\n\t\t// get the latest hover / touch point\n\t\tif ( ! pointerTracker.getLatestPoint( _pointer ) || ( scale === 0 && state !== ZOOM ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// reset momentum\n\t\tthis.rotationInertia.set( 0, 0 );\n\t\tthis.dragInertia.set( 0, 0, 0 );\n\n\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\t// update the zoom direction\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// zoom straight into the globe if we haven't hit anything\n\t\t\tconst zoomIntoPoint = this.zoomPointSet || this._updateZoomPoint();\n\n\t\t\t// get the mouse position before zoom\n\t\t\t_mouseBefore.unproject( camera );\n\n\t\t\t// zoom the camera\n\t\t\tconst normalizedDelta = Math.pow( 0.95, Math.abs( scale * 0.05 ) );\n\t\t\tlet scaleFactor = scale > 0 ? 1 / Math.abs( normalizedDelta ) : normalizedDelta;\n\t\t\tscaleFactor *= zoomSpeed;\n\n\t\t\tif ( scaleFactor > 1 ) {\n\n\t\t\t\tif ( maxZoom < camera.zoom * scaleFactor ) {\n\n\t\t\t\t\tscaleFactor = 1;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( minZoom > camera.zoom * scaleFactor ) {\n\n\t\t\t\t\tscaleFactor = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcamera.zoom *= scaleFactor;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t// adjust the surface point to be in the same position if the globe is hovered over\n\t\t\tif ( zoomIntoPoint ) {\n\n\t\t\t\t// get the mouse position after zoom\n\t\t\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _mouseAfter );\n\t\t\t\t_mouseAfter.unproject( camera );\n\n\t\t\t\t// shift the camera on the near plane so the mouse is in the same spot\n\t\t\t\tcamera.position.sub( _mouseAfter ).add( _mouseBefore );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// initialize the zoom direction\n\t\t\tthis._updateZoomDirection();\n\n\t\t\t// track the zoom direction we're going to use\n\t\t\tconst finalZoomDirection = _vec.copy( zoomDirection );\n\n\t\t\tif ( this.zoomPointSet || this._updateZoomPoint() ) {\n\n\t\t\t\tconst dist = zoomPoint.distanceTo( camera.position );\n\n\t\t\t\t// scale the distance based on how far there is to move\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\tconst remainingDistance = Math.min( 0, dist - maxDistance );\n\t\t\t\t\tscale = scale * dist * zoomSpeed * 0.0025;\n\t\t\t\t\tscale = Math.max( scale, remainingDistance );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst remainingDistance = Math.max( 0, dist - minDistance );\n\t\t\t\t\tscale = scale * Math.max( dist - minDistance, 0 ) * zoomSpeed * 0.0025;\n\t\t\t\t\tscale = Math.min( scale, remainingDistance );\n\n\t\t\t\t}\n\n\t\t\t\tcamera.position.addScaledVector( zoomDirection, scale );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t} else {\n\n\t\t\t\t// if we're zooming into nothing then use the distance from the ground to scale movement\n\t\t\t\tconst hit = this._getPointBelowCamera();\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tconst dist = hit.distance;\n\t\t\t\t\tfinalZoomDirection.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\t\t\tcamera.position.addScaledVector( finalZoomDirection, scale * dist * 0.01 );\n\t\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateZoomDirection() {\n\n\t\tif ( this.zoomDirectionSet ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { domElement, raycaster, camera, zoomDirection, pointerTracker } = this;\n\t\tpointerTracker.getLatestPoint( _pointer );\n\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _mouseBefore );\n\t\tsetRaycasterFromCamera( raycaster, _mouseBefore, camera );\n\t\tzoomDirection.copy( raycaster.ray.direction ).normalize();\n\t\tthis.zoomDirectionSet = true;\n\n\t}\n\n\t// update the point being zoomed in to based on the zoom direction\n\t_updateZoomPoint() {\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tzoomDirectionSet,\n\t\t\tzoomDirection,\n\t\t\traycaster,\n\t\t\tzoomPoint,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t} = this;\n\n\t\tthis._zoomPointWasSet = false;\n\n\t\tif ( ! zoomDirectionSet ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// If using an orthographic camera we have to account for the mouse position when picking the point\n\t\tif ( camera.isOrthographicCamera && pointerTracker.getLatestPoint( _zoomPointPointer ) ) {\n\n\t\t\tmouseToCoords( _zoomPointPointer.x, _zoomPointPointer.y, domElement, _zoomPointPointer );\n\t\t\tsetRaycasterFromCamera( raycaster, _zoomPointPointer, camera );\n\n\t\t} else {\n\n\t\t\traycaster.ray.origin.copy( camera.position );\n\t\t\traycaster.ray.direction.copy( zoomDirection );\n\t\t\traycaster.near = 0;\n\t\t\traycaster.far = Infinity;\n\n\t\t}\n\n\t\t// get the hit point\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\tzoomPoint.copy( hit.point );\n\t\t\tthis.zoomPointSet = true;\n\t\t\tthis._zoomPointWasSet = true;\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// returns the point below the camera\n\t_getPointBelowCamera( point = this.camera.position, up = this.up ) {\n\n\t\tconst { raycaster } = this;\n\t\traycaster.ray.direction.copy( up ).multiplyScalar( - 1 );\n\t\traycaster.ray.origin.copy( point ).addScaledVector( up, 1e5 );\n\t\traycaster.near = 0;\n\t\traycaster.far = Infinity;\n\n\t\tconst hit = this._raycast( raycaster );\n\t\tif ( hit ) {\n\n\t\t\thit.distance -= 1e5;\n\n\t\t}\n\n\t\treturn hit;\n\n\t}\n\n\t// update the drag action\n\t_updatePosition( deltaTime ) {\n\n\t\tconst {\n\t\t\traycaster,\n\t\t\tcamera,\n\t\t\tpivotPoint,\n\t\t\tup,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tstate,\n\t\t\tdragInertia,\n\t\t} = this;\n\n\t\tif ( state === DRAG ) {\n\n\t\t\t// get the pointer and plane\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tmouseToCoords( _pointer.x, _pointer.y, domElement, _pointer );\n\n\t\t\t_plane.setFromNormalAndCoplanarPoint( up, pivotPoint );\n\t\t\tsetRaycasterFromCamera( raycaster, _pointer, camera );\n\n\t\t\t// prevent the drag distance from getting too severe by limiting the drag point\n\t\t\t// to a reasonable angle with the drag plane\n\t\t\tif ( Math.abs( raycaster.ray.direction.dot( up ) ) < DRAG_PLANE_THRESHOLD ) {\n\n\t\t\t\t// rotate the pointer direction down to the correct angle for horizontal dragging\n\t\t\t\tconst angle = Math.acos( DRAG_PLANE_THRESHOLD );\n\n\t\t\t\t_rotationAxis\n\t\t\t\t\t.crossVectors( raycaster.ray.direction, up )\n\t\t\t\t\t.normalize();\n\n\t\t\t\traycaster.ray.direction\n\t\t\t\t\t.copy( up )\n\t\t\t\t\t.applyAxisAngle( _rotationAxis, angle )\n\t\t\t\t\t.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\t// TODO: dragging causes the camera to rise because we're getting \"pushed\" up by lower resolution tiles and\n\t\t\t// don't lower back down. We should maintain a target height above tiles where possible\n\t\t\t// prevent the drag from inverting\n\n\t\t\t// if we drag to a point that's near the edge of the earth then we want to prevent it\n\t\t\t// from wrapping around and causing unexpected rotations\n\t\t\tthis.getUpDirection( pivotPoint, _localUp );\n\t\t\tif ( Math.abs( raycaster.ray.direction.dot( _localUp ) ) < DRAG_UP_THRESHOLD ) {\n\n\t\t\t\tconst angle = Math.acos( DRAG_UP_THRESHOLD );\n\n\t\t\t\t_rotationAxis\n\t\t\t\t\t.crossVectors( raycaster.ray.direction, _localUp )\n\t\t\t\t\t.normalize();\n\n\t\t\t\traycaster.ray.direction\n\t\t\t\t\t.copy( _localUp )\n\t\t\t\t\t.applyAxisAngle( _rotationAxis, angle )\n\t\t\t\t\t.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\t// find the point on the plane that we should drag to\n\t\t\tif ( raycaster.ray.intersectPlane( _plane, _vec ) ) {\n\n\t\t\t\t_delta.subVectors( pivotPoint, _vec );\n\t\t\t\tcamera.position.add( _delta );\n\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t// update the drag inertia\n\t\t\t\t_delta.multiplyScalar( 1 / deltaTime );\n\t\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdragInertia.copy( _delta );\n\t\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateRotation( deltaTime ) {\n\n\t\tconst {\n\t\t\tpivotPoint,\n\t\t\tpointerTracker,\n\t\t\tdomElement,\n\t\t\tstate,\n\t\t\trotationInertia,\n\t\t} = this;\n\n\t\tif ( state === ROTATE ) {\n\n\t\t\t// get the rotation motion and divide out the container height to normalize for element size\n\t\t\tpointerTracker.getCenterPoint( _pointer );\n\t\t\tpointerTracker.getPreviousCenterPoint( _prevPointer );\n\t\t\t_deltaPointer.subVectors( _pointer, _prevPointer ).multiplyScalar( 2 * Math.PI / domElement.clientHeight );\n\n\t\t\tthis._applyRotation( _deltaPointer.x, _deltaPointer.y, pivotPoint );\n\n\t\t\t// update rotation inertia\n\t\t\t_deltaPointer.multiplyScalar( 1 / deltaTime );\n\t\t\tif ( pointerTracker.getMoveDistance() / deltaTime < 2 * window.devicePixelRatio ) {\n\n\t\t\t\tthis.inertiaStableFrames ++;\n\n\t\t\t} else {\n\n\t\t\t\trotationInertia.copy( _deltaPointer );\n\t\t\t\tthis.inertiaStableFrames = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_applyRotation( x, y, pivotPoint ) {\n\n\t\tif ( x === 0 && y === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst {\n\t\t\tcamera,\n\t\t\tminAltitude,\n\t\t\tmaxAltitude,\n\t\t\trotationSpeed,\n\t\t} = this;\n\n\t\tconst azimuth = - x * rotationSpeed;\n\t\tlet altitude = y * rotationSpeed;\n\n\t\t// calculate current angles and clamp\n\t\t_forward.set( 0, 0, 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\t\tthis.getUpDirection( pivotPoint, _localUp );\n\n\t\t// get the signed angle relative to the top down view\n\t\tlet angle;\n\t\tif ( _localUp.dot( _forward ) > 1 - 1e-10 ) {\n\n\t\t\tangle = 0;\n\n\t\t} else {\n\n\t\t\t_vec.crossVectors( _localUp, _forward ).normalize();\n\n\t\t\tconst sign = Math.sign( _vec.dot( _right ) );\n\t\t\tangle = sign * _localUp.angleTo( _forward );\n\n\t\t}\n\n\t\t// clamp the rotation to be within the provided limits\n\t\t// clamp to 0 here, as well, so we don't \"pop\" to the the value range\n\t\tif ( altitude > 0 ) {\n\n\t\t\taltitude = Math.min( angle - minAltitude, altitude );\n\t\t\taltitude = Math.max( 0, altitude );\n\n\t\t} else {\n\n\t\t\taltitude = Math.max( angle - maxAltitude, altitude );\n\t\t\taltitude = Math.min( 0, altitude );\n\n\t\t}\n\n\t\t// rotate around the up axis\n\t\t_quaternion.setFromAxisAngle( _localUp, azimuth );\n\t\tmakeRotateAroundPoint( pivotPoint, _quaternion, _rotMatrix );\n\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\n\t\t// get a rotation axis for altitude and rotate\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\t\t_quaternion.setFromAxisAngle( _right, - altitude );\n\t\tmakeRotateAroundPoint( pivotPoint, _quaternion, _rotMatrix );\n\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\n\t\t// update the transform members\n\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t}\n\n\t// sets the \"up\" axis for the current surface of the tile set\n\t_setFrame( newUp ) {\n\n\t\tconst {\n\t\t\tup,\n\t\t\tcamera,\n\t\t\tzoomPoint,\n\t\t\tzoomDirectionSet,\n\t\t\tzoomPointSet,\n\t\t\tscaleZoomOrientationAtEdges,\n\t\t} = this;\n\n\t\t// If we're zooming then reorient around the zoom point\n\t\tif ( zoomDirectionSet && ( zoomPointSet || this._updateZoomPoint() ) ) {\n\n\t\t\t// get the amount needed to rotate\n\t\t\t_quaternion.setFromUnitVectors( up, newUp );\n\n\t\t\tif ( scaleZoomOrientationAtEdges ) {\n\n\t\t\t\tthis.getUpDirection( zoomPoint, _vec );\n\n\t\t\t\tlet amt = Math.max( _vec.dot( up ) - 0.6, 0 ) / 0.4;\n\t\t\t\tamt = MathUtils.mapLinear( amt, 0, 0.5, 0, 1 );\n\t\t\t\tamt = Math.min( amt, 1 );\n\n\t\t\t\t// scale the value if we're using an orthographic camera so\n\t\t\t\t// GlobeControls works correctly\n\t\t\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\t\t\tamt *= 0.1;\n\n\t\t\t\t}\n\n\t\t\t\t_quaternion.slerp( _identityQuat, 1.0 - amt );\n\n\t\t\t}\n\n\t\t\t// rotates the camera position around the point being zoomed in to\n\t\t\tmakeRotateAroundPoint( zoomPoint, _quaternion, _rotMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\tcamera.matrixWorld.premultiply( _rotMatrix );\n\t\t\tcamera.matrixWorld.decompose( camera.position, camera.quaternion, _vec );\n\n\t\t\t// recompute the zoom direction after updating rotation to align with frame\n\t\t\tthis.zoomDirectionSet = false;\n\t\t\tthis._updateZoomDirection();\n\n\t\t}\n\n\t\tup.copy( newUp );\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t_raycast( raycaster ) {\n\n\t\tconst { scene, useFallbackPlane, fallbackPlane } = this;\n\t\tconst result = raycaster.intersectObject( scene )[ 0 ] || null;\n\t\tif ( result ) {\n\n\t\t\treturn result;\n\n\t\t} else if ( useFallbackPlane ) {\n\n\t\t\t// if we don't hit any geometry then try to intersect the fallback\n\t\t\t// plane so the camera can still be manipulated\n\t\t\tconst plane = fallbackPlane;\n\t\t\tif ( raycaster.ray.intersectPlane( plane, _vec ) ) {\n\n\t\t\t\tconst planeHit = {\n\t\t\t\t\tpoint: _vec.clone(),\n\t\t\t\t\tdistance: raycaster.ray.origin.distanceTo( _vec ),\n\t\t\t\t};\n\n\t\t\t\treturn planeHit;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// tilt the camera to align with the provided \"up\" value\n\t_alignCameraUp( up, alpha = 1 ) {\n\n\t\tconst { camera, state, pivotPoint, zoomPoint, zoomPointSet } = this;\n\n\t\t// get the transform vectors\n\t\tcamera.updateMatrixWorld();\n\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( - 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\n\t\t// compute an alpha based on the camera direction so we don't try to update the up direction\n\t\t// when the camera is facing that way.\n\t\tlet multiplier = MathUtils.mapLinear( 1 - Math.abs( _forward.dot( up ) ), 0, 0.2, 0, 1 );\n\t\tmultiplier = MathUtils.clamp( multiplier, 0, 1 );\n\t\talpha *= multiplier;\n\n\t\t// calculate the target direction for the right-facing vector\n\t\t_targetRight.crossVectors( up, _forward );\n\t\t_targetRight.lerp( _right, 1 - alpha ).normalize();\n\n\t\t// adjust the camera transformation\n\t\t_quaternion.setFromUnitVectors( _right, _targetRight );\n\t\tcamera.quaternion.premultiply( _quaternion );\n\n\t\t// calculate the active point\n\t\tlet fixedPoint = null;\n\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\tfixedPoint = _pos.copy( pivotPoint );\n\n\t\t} else if ( zoomPointSet ) {\n\n\t\t\tfixedPoint = _pos.copy( zoomPoint );\n\n\t\t}\n\n\t\t// shift the camera in an effort to keep the fixed point in the same spot\n\t\tif ( fixedPoint ) {\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.copy( fixedPoint ).applyMatrix4( _invMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\t_center.subVectors( fixedPoint, _vec );\n\t\t\tcamera.position.add( _center );\n\n\t\t}\n\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n\t// clamp rotation to the given \"up\" vector\n\t_clampRotation( up ) {\n\n\t\tconst { camera, minAltitude, maxAltitude, state, pivotPoint, zoomPoint, zoomPointSet } = this;\n\n\t\tcamera.updateMatrixWorld();\n\n\t\t// calculate current angles and clamp\n\t\t_forward.set( 0, 0, 1 ).transformDirection( camera.matrixWorld );\n\t\t_right.set( 1, 0, 0 ).transformDirection( camera.matrixWorld );\n\n\t\t// get the signed angle relative to the top down view\n\t\tlet angle;\n\t\tif ( up.dot( _forward ) > 1 - 1e-10 ) {\n\n\t\t\tangle = 0;\n\n\t\t} else {\n\n\t\t\t_vec.crossVectors( up, _forward );\n\n\t\t\tconst sign = Math.sign( _vec.dot( _right ) );\n\t\t\tangle = sign * up.angleTo( _forward );\n\n\t\t}\n\n\t\t// find the angle to target\n\t\tlet targetAngle;\n\t\tif ( angle > maxAltitude ) {\n\n\t\t\ttargetAngle = maxAltitude;\n\n\t\t} else if ( angle < minAltitude ) {\n\n\t\t\ttargetAngle = minAltitude;\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// construct a rotation basis\n\t\t_forward.copy( up );\n\t\t_quaternion.setFromAxisAngle( _right, targetAngle );\n\t\t_forward.applyQuaternion( _quaternion ).normalize();\n\t\t_vec.crossVectors( _forward, _right ).normalize();\n\n\t\t_rotMatrix.makeBasis( _right, _vec, _forward );\n\t\tcamera.quaternion.setFromRotationMatrix( _rotMatrix );\n\n\t\t// calculate the active point\n\t\tlet fixedPoint = null;\n\t\tif ( state === DRAG || state === ROTATE ) {\n\n\t\t\tfixedPoint = _pos.copy( pivotPoint );\n\n\t\t} else if ( zoomPointSet ) {\n\n\t\t\tfixedPoint = _pos.copy( zoomPoint );\n\n\t\t}\n\n\t\t// shift the camera in an effort to keep the fixed point in the same spot\n\t\tif ( fixedPoint ) {\n\n\t\t\t_invMatrix.copy( camera.matrixWorld ).invert();\n\t\t\t_vec.copy( fixedPoint ).applyMatrix4( _invMatrix );\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\t_vec.applyMatrix4( camera.matrixWorld );\n\n\t\t\t_center.subVectors( fixedPoint, _vec );\n\t\t\tcamera.position.add( _center );\n\n\t\t}\n\n\t\tcamera.updateMatrixWorld();\n\n\t}\n\n}\n"],"names":["PivotPointMesh","Mesh","PlaneGeometry","PivotMaterial","renderer","uniforms","ShaderMaterial","Vector2","_vec","_vec2","PointerTracker","previousPositions","pointerPositions","id","e","target","rect","x","y","position","pointerOrder","id0","id1","p0","p1","_matrix","Matrix4","_ray","Ray","Vector3","makeRotateAroundPoint","point","quat","mouseToCoords","clientX","clientY","element","closestRayEllipsoidSurfacePointEstimate","ray","ellipsoid","setRaycasterFromCamera","raycaster","coords","camera","origin","direction","NONE","DRAG","ROTATE","ZOOM","WAITING","DRAG_PLANE_THRESHOLD","DRAG_UP_THRESHOLD","_rotMatrix","_invMatrix","_delta","_pos","_center","_forward","_right","_targetRight","_rotationAxis","_quaternion","Quaternion","_plane","Plane","_localUp","_mouseBefore","_mouseAfter","_identityQuat","_zoomPointPointer","_pointer","_prevPointer","_deltaPointer","_centerPoint","_startCenterPoint","_changeEvent","_startEvent","_endEvent","EnvironmentControls","EventDispatcher","v","scene","domElement","tilesRenderer","Raycaster","Clock","contextMenuCallback","pointerdownCallback","up","pivotMesh","pointerTracker","pivotPoint","enabled","dot","hit","_pointerMoveQueued","pointermoveCallback","startDist","pointerDist","separateDelta","dragThreshold","parallelDelta","previousDist","pointerupCallback","wheelCallback","delta","deltaSign","normalizedDelta","pointerleaveCallback","document","result","state","fireEvent","deltaTime","cameraRadius","adjustHeight","autoAdjustCameraRotation","inertiaNeedsUpdate","adjustCameraRotation","zoomDelta","actionHeightOffset","dist","rotationInertia","dragInertia","enableDamping","dampingFactor","minDistance","inertiaTargetDistance","factor","stableDistance","pixelThreshold","threshold","zoomPoint","zoomDirection","maxDistance","minZoom","maxZoom","zoomSpeed","scale","zoomIntoPoint","scaleFactor","finalZoomDirection","remainingDistance","zoomDirectionSet","angle","minAltitude","maxAltitude","rotationSpeed","azimuth","altitude","newUp","zoomPointSet","scaleZoomOrientationAtEdges","amt","MathUtils","useFallbackPlane","fallbackPlane","plane","alpha","multiplier","fixedPoint","targetAngle"],"mappings":"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"}